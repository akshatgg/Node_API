
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    otps: OtpPayload<ExtArgs>[]
    businessProfile: BusinessProfilePayload<ExtArgs> | null
    invoices: InvoicePayload<ExtArgs>[]
    categories: CategoryPayload<ExtArgs>[]
    items: ItemPayload<ExtArgs>[]
    parties: PartyPayload<ExtArgs>[]
    payments: PaymentPayload<ExtArgs>[]
    orders: OrderPayload<ExtArgs>[]
    posts: PostPayload<ExtArgs>[]
    accounts: AccountPayload<ExtArgs>[]
    bankAccounts: BankDetailsPayload<ExtArgs>[]
    loans: LoanApplicationPayload<ExtArgs>[]
    documents: UploadedDocumentPayload<ExtArgs>[]
    insurances: InsurancePayload<ExtArgs>[]
    registerStartup: RegisterStartupPayload<ExtArgs>[]
    contactUs: ContactUsPayload<ExtArgs>[]
    journalEntries: JournalEntryPayload<ExtArgs>[]
    legders: LedgerPayload<ExtArgs>[]
    transactions: TransactionPayload<ExtArgs>[]
    agentId: AgentPayload<ExtArgs> | null
    clientAccounts: ClientPayload<ExtArgs>[]
    gstr1: Gstr1_4APayload<ExtArgs>[]
    gstr1_5A: Gstr1_5APayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    createdAt: Date
    email: string
    password: string
    firstName: string
    lastName: string | null
    fatherName: string | null
    phone: string | null
    gender: UserGender
    address: string | null
    pin: string | null
    aadhaar: string | null
    pan: string | null
    dob: Date | null
    avatar: string | null
    adminId: number | null
    superadminId: number | null
    verified: boolean
    userType: UserType
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type OtpPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Otp"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    createdAt: Date
    otp: string
    userId: number
    used: boolean
  }, ExtArgs["result"]["otp"]>
  composites: {}
}

/**
 * Model Otp
 * 
 */
export type Otp = runtime.Types.DefaultSelection<OtpPayload>
export type BusinessProfilePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BusinessProfile"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    businessName: string
    pan: string | null
    tan: string | null
    gstin: string | null
    address: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    bankBranch: string | null
    state: string | null
    userId: number
    createdAt: Date
    updatedAt: Date
    isAddressVerified: boolean | null
    isBusinessNameVerified: boolean | null
    isGstinVerified: boolean | null
    isPanVerified: boolean | null
    isStateVerified: boolean | null
  }, ExtArgs["result"]["businessProfile"]>
  composites: {}
}

/**
 * Model BusinessProfile
 * 
 */
export type BusinessProfile = runtime.Types.DefaultSelection<BusinessProfilePayload>
export type LedgerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Ledger"
  objects: {
    user: UserPayload<ExtArgs>
    transactions: TransactionPayload<ExtArgs>[]
    party: PartyPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    ledgerName: string
    openingBalance: Prisma.Decimal
    balance: Prisma.Decimal
    userId: number
    partyId: string | null
    year: number
    month: number
    ledgerType: LedgerType
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["ledger"]>
  composites: {}
}

/**
 * Model Ledger
 * 
 */
export type Ledger = runtime.Types.DefaultSelection<LedgerPayload>
export type JournalEntryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "JournalEntry"
  objects: {
    user: UserPayload<ExtArgs>
    transactions: TransactionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    entryDate: Date
    description: string
    userId: number
  }, ExtArgs["result"]["journalEntry"]>
  composites: {}
}

/**
 * Model JournalEntry
 * 
 */
export type JournalEntry = runtime.Types.DefaultSelection<JournalEntryPayload>
export type TransactionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Transaction"
  objects: {
    ledger: LedgerPayload<ExtArgs>
    journalEntry: JournalEntryPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    ledgerId: string
    journalEntryId: string
    amount: Prisma.Decimal
    transactionType: TransactionType
    userId: number
  }, ExtArgs["result"]["transaction"]>
  composites: {}
}

/**
 * Model Transaction
 * 
 */
export type Transaction = runtime.Types.DefaultSelection<TransactionPayload>
export type PartyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Party"
  objects: {
    invoices: InvoicePayload<ExtArgs>[]
    items: ItemPayload<ExtArgs>[]
    user: UserPayload<ExtArgs>
    ledgers: LedgerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    partyName: string
    type: PartyType
    gstin: string | null
    pan: string | null
    tan: string | null
    upi: string | null
    email: string | null
    phone: string | null
    address: string | null
    bankName: string | null
    bankAccountNumber: string | null
    bankIfsc: string | null
    bankBranch: string | null
    userId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["party"]>
  composites: {}
}

/**
 * Model Party
 * 
 */
export type Party = runtime.Types.DefaultSelection<PartyPayload>
export type CategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Category"
  objects: {
    user: UserPayload<ExtArgs>
    items: ItemPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    categoryName: string
    userId: number
  }, ExtArgs["result"]["category"]>
  composites: {}
}

/**
 * Model Category
 * 
 */
export type Category = runtime.Types.DefaultSelection<CategoryPayload>
export type ItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Item"
  objects: {
    category: CategoryPayload<ExtArgs> | null
    supplier: PartyPayload<ExtArgs> | null
    invoiceItems: InvoiceItemPayload<ExtArgs>[]
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    itemName: string
    unit: ItemUnit
    price: Prisma.Decimal
    openingStock: Prisma.Decimal | null
    closingStock: Prisma.Decimal | null
    purchasePrice: Prisma.Decimal | null
    gst: Prisma.Decimal | null
    taxExempted: boolean
    description: string | null
    hsnCode: string | null
    categoryId: string | null
    supplierId: string | null
    userId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["item"]>
  composites: {}
}

/**
 * Model Item
 * 
 */
export type Item = runtime.Types.DefaultSelection<ItemPayload>
export type InvoicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Invoice"
  objects: {
    user: UserPayload<ExtArgs>
    party: PartyPayload<ExtArgs>
    invoiceItems: InvoiceItemPayload<ExtArgs>[]
    accounts: AccountPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    invoiceNumber: string | null
    type: InvoiceType
    totalAmount: number
    totalGst: number | null
    stateOfSupply: string
    cgst: number | null
    sgst: number | null
    igst: number | null
    utgst: number | null
    details: string | null
    extraDetails: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    userId: number
    partyId: string
    gstNumber: string | null
    createdAt: Date
    updatedAt: Date
    status: InvoiceStatus
  }, ExtArgs["result"]["invoice"]>
  composites: {}
}

/**
 * Model Invoice
 * 
 */
export type Invoice = runtime.Types.DefaultSelection<InvoicePayload>
export type InvoiceItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "InvoiceItem"
  objects: {
    item: ItemPayload<ExtArgs>
    invoice: InvoicePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    itemId: string
    quantity: number
    discount: Prisma.Decimal
    invoiceId: string
  }, ExtArgs["result"]["invoiceItem"]>
  composites: {}
}

/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = runtime.Types.DefaultSelection<InvoiceItemPayload>
export type ServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Service"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    serviceName: string
    serviceType: string | null
    imgUrl: string | null
    description: string | null
    price: Prisma.Decimal
    gst: Prisma.Decimal
    documents: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["service"]>
  composites: {}
}

/**
 * Model Service
 * 
 */
export type Service = runtime.Types.DefaultSelection<ServicePayload>
export type OrderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Order"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    services: Prisma.JsonValue
    status: OrderStatus
    price: Prisma.Decimal
    gst: Prisma.Decimal
    orderTotal: Prisma.Decimal
    stateOfSupply: string
    userId: number
  }, ExtArgs["result"]["order"]>
  composites: {}
}

/**
 * Model Order
 * 
 */
export type Order = runtime.Types.DefaultSelection<OrderPayload>
export type PaymentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Payment"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    razorpay_order_id: string
    razorpay_payment_id: string
    status: PaymentStatus
    userId: number
    orderId: number
  }, ExtArgs["result"]["payment"]>
  composites: {}
}

/**
 * Model Payment
 * 
 */
export type Payment = runtime.Types.DefaultSelection<PaymentPayload>
export type LibraryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Library"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    pan: string
    section: string
    sub_section: string | null
    subject: string
    ao_order: string
    itat_no: string
    rsa_no: string | null
    bench: string
    appeal_no: string | null
    appellant: string | null
    respondent: string
    appeal_type: string
    appeal_filed_by: string
    order_result: string
    tribunal_order_date: string
    assessment_year: string
    judgment: string
    conclusion: string
    download: string
    upload: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["library"]>
  composites: {}
}

/**
 * Model Library
 * 
 */
export type Library = runtime.Types.DefaultSelection<LibraryPayload>
export type PostPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Post"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: number
    title: string
    contentheading: string
    contentdiscription: string
    category: string
    imageUrl: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["post"]>
  composites: {}
}

/**
 * Model Post
 * 
 */
export type Post = runtime.Types.DefaultSelection<PostPayload>
export type AccountPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Account"
  objects: {
    user: UserPayload<ExtArgs>
    invoices: InvoicePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    accountName: string
    totalDebit: Prisma.Decimal
    totalCredit: Prisma.Decimal
    debitBalance: Prisma.Decimal
    creditBalance: Prisma.Decimal
    date: Date
    userId: number
  }, ExtArgs["result"]["account"]>
  composites: {}
}

/**
 * Model Account
 * 
 */
export type Account = runtime.Types.DefaultSelection<AccountPayload>
export type CareerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Career"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    address: string
    pin: string
    email: string
    mobile: string
    skills: string
    gender: UserGender
    cv: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["career"]>
  composites: {}
}

/**
 * Model Career
 * 
 */
export type Career = runtime.Types.DefaultSelection<CareerPayload>
export type BillrecievePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Billrecieve"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    billNumber: string
    amount: string
    tax: string
    customerName: string
    customerAddress: string
    contact: string
    itemQuantity: string
    itemPrice: string
    itemDescription: string
    paymentStatus: paymentStatus
    paymentMethod: paymentMethod
    dueDate: string
    comment: string | null
  }, ExtArgs["result"]["billrecieve"]>
  composites: {}
}

/**
 * Model Billrecieve
 * 
 */
export type Billrecieve = runtime.Types.DefaultSelection<BillrecievePayload>
export type BillpayablePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Billpayable"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    supplierName: string
    supplierAddress: string
    contact: string
    billDate: string
    dueDate: string
    billAmount: string
    billNumber: string
    billDiscription: string
    paymentMethod: paymentMethod
    transactionId: string | null
    paymentDate: string
    paymentAmount: string
    tax: string
    comment: string | null
    invoiceNumber: string | null
  }, ExtArgs["result"]["billpayable"]>
  composites: {}
}

/**
 * Model Billpayable
 * 
 */
export type Billpayable = runtime.Types.DefaultSelection<BillpayablePayload>
export type UploadedDocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UploadedDocument"
  objects: {
    user: UserPayload<ExtArgs>
    docs: LoanDocumentPayload<ExtArgs>[]
    application: LoanApplicationPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: number
    fileName: string
    applicationId: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["uploadedDocument"]>
  composites: {}
}

/**
 * Model UploadedDocument
 * 
 */
export type UploadedDocument = runtime.Types.DefaultSelection<UploadedDocumentPayload>
export type LoanDocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "LoanDocument"
  objects: {
    documents: UploadedDocumentPayload<ExtArgs>[]
    loans: LoanPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    shortName: string
    mandatory: boolean
    type: DocumentType
    description: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["loanDocument"]>
  composites: {}
}

/**
 * Model LoanDocument
 * 
 */
export type LoanDocument = runtime.Types.DefaultSelection<LoanDocumentPayload>
export type LoanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Loan"
  objects: {
    documents: LoanDocumentPayload<ExtArgs>[]
    applications: LoanApplicationPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    type: LoanType
    name: string
    shortName: string | null
    description: string | null
    maxAmount: Prisma.Decimal | null
    minAmount: Prisma.Decimal | null
    interest: Prisma.Decimal
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["loan"]>
  composites: {}
}

/**
 * Model Loan
 * 
 */
export type Loan = runtime.Types.DefaultSelection<LoanPayload>
export type LoanApplicationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "LoanApplication"
  objects: {
    loan: LoanPayload<ExtArgs>
    documents: UploadedDocumentPayload<ExtArgs>[]
    bankDetails: BankDetailsPayload<ExtArgs>
    user: UserPayload<ExtArgs>
    agent: AgentPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    loanId: string
    loanAmount: Prisma.Decimal
    loanStatus: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone: string | null
    email: string | null
    address: string | null
    permanentAddress: string
    userId: number
    agentId: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["loanApplication"]>
  composites: {}
}

/**
 * Model LoanApplication
 * 
 */
export type LoanApplication = runtime.Types.DefaultSelection<LoanApplicationPayload>
export type BankDetailsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BankDetails"
  objects: {
    loans: LoanApplicationPayload<ExtArgs>[]
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    userId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["bankDetails"]>
  composites: {}
}

/**
 * Model BankDetails
 * 
 */
export type BankDetails = runtime.Types.DefaultSelection<BankDetailsPayload>
export type InsurancePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Insurance"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    type: string
    name: string
    mobile: string
    email: string
    address: string
    dob: Date
    maritalStatus: string
    gender: UserGender
    userId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["insurance"]>
  composites: {}
}

/**
 * Model Insurance
 * 
 */
export type Insurance = runtime.Types.DefaultSelection<InsurancePayload>
export type ClientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Client"
  objects: {
    user: UserPayload<ExtArgs>
    agent: AgentPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: number
    agentId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["client"]>
  composites: {}
}

/**
 * Model Client
 * 
 */
export type Client = runtime.Types.DefaultSelection<ClientPayload>
export type AgentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Agent"
  objects: {
    clients: ClientPayload<ExtArgs>[]
    user: UserPayload<ExtArgs>
    loans: LoanApplicationPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["agent"]>
  composites: {}
}

/**
 * Model Agent
 * 
 */
export type Agent = runtime.Types.DefaultSelection<AgentPayload>
export type VisitorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Visitor"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    count: number
    createdAt: Date
  }, ExtArgs["result"]["visitor"]>
  composites: {}
}

/**
 * Model Visitor
 * 
 */
export type Visitor = runtime.Types.DefaultSelection<VisitorPayload>
export type RegisterStartupPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "RegisterStartup"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    title: string
    image: string
    userId: number
    categories: StartupCategory
  }, ExtArgs["result"]["registerStartup"]>
  composites: {}
}

/**
 * Model RegisterStartup
 * 
 */
export type RegisterStartup = runtime.Types.DefaultSelection<RegisterStartupPayload>
export type ContactUsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContactUs"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    email: string
    message: string
    phoneNumber: string
    userId: number
  }, ExtArgs["result"]["contactUs"]>
  composites: {}
}

/**
 * Model ContactUs
 * 
 */
export type ContactUs = runtime.Types.DefaultSelection<ContactUsPayload>
export type AboutPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "About"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    position: string
    image: string
    description: string
  }, ExtArgs["result"]["about"]>
  composites: {}
}

/**
 * Model About
 * 
 */
export type About = runtime.Types.DefaultSelection<AboutPayload>
export type Gstr1_4APayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Gstr1_4A"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userId: number
    LegalName: string
    GSTN: string
    pos: string
    invoice_No: string
    invoice_date: string
    invoice_value: string
    rate: string
    nature: string
    source: string
    cgst: string
    igst: string
    sgst: string
    supply_type: string
    fy: string
    period: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["gstr1_4A"]>
  composites: {}
}

/**
 * Model Gstr1_4A
 * 
 */
export type Gstr1_4A = runtime.Types.DefaultSelection<Gstr1_4APayload>
export type Gstr1_5APayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Gstr1_5A"
  objects: {
    user: UserPayload<ExtArgs>
    gstr1_5A_items: Gstr1_5A_itemPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    userId: number
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
  }, ExtArgs["result"]["gstr1_5A"]>
  composites: {}
}

/**
 * Model Gstr1_5A
 * 
 */
export type Gstr1_5A = runtime.Types.DefaultSelection<Gstr1_5APayload>
export type Gstr1_5A_itemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Gstr1_5A_item"
  objects: {
    gstr1_5A: Gstr1_5APayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    SN: string
    turnover: string
    cgst: string
    sgst: string
    gstr1_5A_id: number
  }, ExtArgs["result"]["gstr1_5A_item"]>
  composites: {}
}

/**
 * Model Gstr1_5A_item
 * 
 */
export type Gstr1_5A_item = runtime.Types.DefaultSelection<Gstr1_5A_itemPayload>

/**
 * Enums
 */

export const UserGender: {
  male: 'male',
  female: 'female',
  other: 'other'
};

export type UserGender = (typeof UserGender)[keyof typeof UserGender]


export const UserType: {
  admin: 'admin',
  normal: 'normal',
  agent: 'agent',
  superadmin: 'superadmin'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const LedgerType: {
  bank: 'bank',
  cash: 'cash',
  purchase: 'purchase',
  sales: 'sales',
  directExpense: 'directExpense',
  indirectExpense: 'indirectExpense',
  directIncome: 'directIncome',
  indirectIncome: 'indirectIncome',
  fixedAssets: 'fixedAssets',
  currentAssets: 'currentAssets',
  loansAndLiabilities: 'loansAndLiabilities',
  accountsReceivable: 'accountsReceivable',
  accountsPayable: 'accountsPayable'
};

export type LedgerType = (typeof LedgerType)[keyof typeof LedgerType]


export const TransactionType: {
  credit: 'credit',
  debit: 'debit'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PartyType: {
  customer: 'customer',
  supplier: 'supplier'
};

export type PartyType = (typeof PartyType)[keyof typeof PartyType]


export const ItemUnit: {
  pieces: 'pieces',
  grams: 'grams',
  kilograms: 'kilograms',
  liters: 'liters',
  milliliters: 'milliliters',
  meters: 'meters',
  centimeters: 'centimeters',
  inches: 'inches',
  feet: 'feet',
  squareMeters: 'squareMeters',
  squareFeet: 'squareFeet',
  cubicMeters: 'cubicMeters',
  cubicFeet: 'cubicFeet',
  dozen: 'dozen',
  pack: 'pack',
  carton: 'carton',
  box: 'box',
  roll: 'roll',
  bundle: 'bundle',
  pair: 'pair',
  set: 'set'
};

export type ItemUnit = (typeof ItemUnit)[keyof typeof ItemUnit]


export const InvoiceType: {
  sales: 'sales',
  purchase: 'purchase',
  sales_return: 'sales_return',
  purchase_return: 'purchase_return'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const ModeOfPayment: {
  cash: 'cash',
  bank: 'bank',
  upi: 'upi',
  credit: 'credit'
};

export type ModeOfPayment = (typeof ModeOfPayment)[keyof typeof ModeOfPayment]


export const InvoiceStatus: {
  unpaid: 'unpaid',
  paid: 'paid',
  overdue: 'overdue'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const OrderStatus: {
  initiated: 'initiated',
  pending: 'pending',
  success: 'success',
  failure: 'failure',
  usercancelled: 'usercancelled',
  dropped: 'dropped',
  bounced: 'bounced'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  created: 'created',
  success: 'success',
  failed: 'failed'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const paymentStatus: {
  paid: 'paid',
  unpaid: 'unpaid',
  overdue: 'overdue'
};

export type paymentStatus = (typeof paymentStatus)[keyof typeof paymentStatus]


export const paymentMethod: {
  cash: 'cash',
  creditcard: 'creditcard',
  upi: 'upi',
  netbanking: 'netbanking',
  cheque: 'cheque'
};

export type paymentMethod = (typeof paymentMethod)[keyof typeof paymentMethod]


export const DocumentType: {
  pdf: 'pdf',
  image: 'image',
  other: 'other'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const LoanType: {
  personal: 'personal',
  education: 'education',
  home: 'home',
  business: 'business',
  car: 'car',
  property: 'property'
};

export type LoanType = (typeof LoanType)[keyof typeof LoanType]


export const LoanStatus: {
  pending: 'pending',
  processing: 'processing',
  review: 'review',
  accepted: 'accepted',
  rejected: 'rejected'
};

export type LoanStatus = (typeof LoanStatus)[keyof typeof LoanStatus]


export const Nationality: {
  resident: 'resident',
  nri: 'nri',
  foreign: 'foreign'
};

export type Nationality = (typeof Nationality)[keyof typeof Nationality]


export const BankAccountType: {
  savings: 'savings',
  current: 'current',
  nri: 'nri',
  fcnr: 'fcnr',
  rd: 'rd',
  fd: 'fd',
  salary: 'salary'
};

export type BankAccountType = (typeof BankAccountType)[keyof typeof BankAccountType]


export const StartupCategory: {
  registration: 'registration',
  companyRegistration: 'companyRegistration',
  returns: 'returns',
  audits: 'audits'
};

export type StartupCategory = (typeof StartupCategory)[keyof typeof StartupCategory]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.businessProfile`: Exposes CRUD operations for the **BusinessProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessProfiles
    * const businessProfiles = await prisma.businessProfile.findMany()
    * ```
    */
  get businessProfile(): Prisma.BusinessProfileDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ledger`: Exposes CRUD operations for the **Ledger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ledgers
    * const ledgers = await prisma.ledger.findMany()
    * ```
    */
  get ledger(): Prisma.LedgerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.party`: Exposes CRUD operations for the **Party** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parties
    * const parties = await prisma.party.findMany()
    * ```
    */
  get party(): Prisma.PartyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.library`: Exposes CRUD operations for the **Library** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Libraries
    * const libraries = await prisma.library.findMany()
    * ```
    */
  get library(): Prisma.LibraryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.career`: Exposes CRUD operations for the **Career** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Careers
    * const careers = await prisma.career.findMany()
    * ```
    */
  get career(): Prisma.CareerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.billrecieve`: Exposes CRUD operations for the **Billrecieve** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billrecieves
    * const billrecieves = await prisma.billrecieve.findMany()
    * ```
    */
  get billrecieve(): Prisma.BillrecieveDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.billpayable`: Exposes CRUD operations for the **Billpayable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billpayables
    * const billpayables = await prisma.billpayable.findMany()
    * ```
    */
  get billpayable(): Prisma.BillpayableDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.uploadedDocument`: Exposes CRUD operations for the **UploadedDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UploadedDocuments
    * const uploadedDocuments = await prisma.uploadedDocument.findMany()
    * ```
    */
  get uploadedDocument(): Prisma.UploadedDocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.loanDocument`: Exposes CRUD operations for the **LoanDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanDocuments
    * const loanDocuments = await prisma.loanDocument.findMany()
    * ```
    */
  get loanDocument(): Prisma.LoanDocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.loan`: Exposes CRUD operations for the **Loan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loans
    * const loans = await prisma.loan.findMany()
    * ```
    */
  get loan(): Prisma.LoanDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.loanApplication`: Exposes CRUD operations for the **LoanApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanApplications
    * const loanApplications = await prisma.loanApplication.findMany()
    * ```
    */
  get loanApplication(): Prisma.LoanApplicationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.bankDetails`: Exposes CRUD operations for the **BankDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankDetails
    * const bankDetails = await prisma.bankDetails.findMany()
    * ```
    */
  get bankDetails(): Prisma.BankDetailsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.insurance`: Exposes CRUD operations for the **Insurance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insurances
    * const insurances = await prisma.insurance.findMany()
    * ```
    */
  get insurance(): Prisma.InsuranceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.visitor`: Exposes CRUD operations for the **Visitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitors
    * const visitors = await prisma.visitor.findMany()
    * ```
    */
  get visitor(): Prisma.VisitorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.registerStartup`: Exposes CRUD operations for the **RegisterStartup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegisterStartups
    * const registerStartups = await prisma.registerStartup.findMany()
    * ```
    */
  get registerStartup(): Prisma.RegisterStartupDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.contactUs`: Exposes CRUD operations for the **ContactUs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactuses
    * const contactuses = await prisma.contactUs.findMany()
    * ```
    */
  get contactUs(): Prisma.ContactUsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.about`: Exposes CRUD operations for the **About** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abouts
    * const abouts = await prisma.about.findMany()
    * ```
    */
  get about(): Prisma.AboutDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gstr1_4A`: Exposes CRUD operations for the **Gstr1_4A** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gstr1_4AS
    * const gstr1_4AS = await prisma.gstr1_4A.findMany()
    * ```
    */
  get gstr1_4A(): Prisma.Gstr1_4ADelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gstr1_5A`: Exposes CRUD operations for the **Gstr1_5A** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gstr1_5AS
    * const gstr1_5AS = await prisma.gstr1_5A.findMany()
    * ```
    */
  get gstr1_5A(): Prisma.Gstr1_5ADelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gstr1_5A_item`: Exposes CRUD operations for the **Gstr1_5A_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gstr1_5A_items
    * const gstr1_5A_items = await prisma.gstr1_5A_item.findMany()
    * ```
    */
  get gstr1_5A_item(): Prisma.Gstr1_5A_itemDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: b20ead4d3ab9e78ac112966e242ded703f4a052c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Otp: 'Otp',
    BusinessProfile: 'BusinessProfile',
    Ledger: 'Ledger',
    JournalEntry: 'JournalEntry',
    Transaction: 'Transaction',
    Party: 'Party',
    Category: 'Category',
    Item: 'Item',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Service: 'Service',
    Order: 'Order',
    Payment: 'Payment',
    Library: 'Library',
    Post: 'Post',
    Account: 'Account',
    Career: 'Career',
    Billrecieve: 'Billrecieve',
    Billpayable: 'Billpayable',
    UploadedDocument: 'UploadedDocument',
    LoanDocument: 'LoanDocument',
    Loan: 'Loan',
    LoanApplication: 'LoanApplication',
    BankDetails: 'BankDetails',
    Insurance: 'Insurance',
    Client: 'Client',
    Agent: 'Agent',
    Visitor: 'Visitor',
    RegisterStartup: 'RegisterStartup',
    ContactUs: 'ContactUs',
    About: 'About',
    Gstr1_4A: 'Gstr1_4A',
    Gstr1_5A: 'Gstr1_5A',
    Gstr1_5A_item: 'Gstr1_5A_item'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'otp' | 'businessProfile' | 'ledger' | 'journalEntry' | 'transaction' | 'party' | 'category' | 'item' | 'invoice' | 'invoiceItem' | 'service' | 'order' | 'payment' | 'library' | 'post' | 'account' | 'career' | 'billrecieve' | 'billpayable' | 'uploadedDocument' | 'loanDocument' | 'loan' | 'loanApplication' | 'bankDetails' | 'insurance' | 'client' | 'agent' | 'visitor' | 'registerStartup' | 'contactUs' | 'about' | 'gstr1_4A' | 'gstr1_5A' | 'gstr1_5A_item'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: OtpPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>,
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      BusinessProfile: {
        payload: BusinessProfilePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BusinessProfileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessProfileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload>
          }
          findFirst: {
            args: Prisma.BusinessProfileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessProfileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload>
          }
          findMany: {
            args: Prisma.BusinessProfileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload>[]
          }
          create: {
            args: Prisma.BusinessProfileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload>
          }
          createMany: {
            args: Prisma.BusinessProfileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BusinessProfileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload>
          }
          update: {
            args: Prisma.BusinessProfileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload>
          }
          deleteMany: {
            args: Prisma.BusinessProfileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessProfileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BusinessProfileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessProfilePayload>
          }
          aggregate: {
            args: Prisma.BusinessProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusinessProfile>
          }
          groupBy: {
            args: Prisma.BusinessProfileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusinessProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessProfileCountArgs<ExtArgs>,
            result: $Utils.Optional<BusinessProfileCountAggregateOutputType> | number
          }
        }
      }
      Ledger: {
        payload: LedgerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LedgerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload>
          }
          findFirst: {
            args: Prisma.LedgerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload>
          }
          findMany: {
            args: Prisma.LedgerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload>[]
          }
          create: {
            args: Prisma.LedgerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload>
          }
          createMany: {
            args: Prisma.LedgerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LedgerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload>
          }
          update: {
            args: Prisma.LedgerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload>
          }
          deleteMany: {
            args: Prisma.LedgerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LedgerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LedgerPayload>
          }
          aggregate: {
            args: Prisma.LedgerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLedger>
          }
          groupBy: {
            args: Prisma.LedgerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerCountArgs<ExtArgs>,
            result: $Utils.Optional<LedgerCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: JournalEntryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>,
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: TransactionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Party: {
        payload: PartyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PartyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload>
          }
          findFirst: {
            args: Prisma.PartyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload>
          }
          findMany: {
            args: Prisma.PartyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload>[]
          }
          create: {
            args: Prisma.PartyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload>
          }
          createMany: {
            args: Prisma.PartyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload>
          }
          update: {
            args: Prisma.PartyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload>
          }
          deleteMany: {
            args: Prisma.PartyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PartyPayload>
          }
          aggregate: {
            args: Prisma.PartyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParty>
          }
          groupBy: {
            args: Prisma.PartyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartyCountArgs<ExtArgs>,
            result: $Utils.Optional<PartyCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: CategoryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: ItemPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: InvoicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: InvoiceItemPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: ServicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: OrderPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: PaymentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Library: {
        payload: LibraryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LibraryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          findFirst: {
            args: Prisma.LibraryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          findMany: {
            args: Prisma.LibraryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>[]
          }
          create: {
            args: Prisma.LibraryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          createMany: {
            args: Prisma.LibraryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LibraryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          update: {
            args: Prisma.LibraryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          deleteMany: {
            args: Prisma.LibraryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LibraryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          aggregate: {
            args: Prisma.LibraryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLibrary>
          }
          groupBy: {
            args: Prisma.LibraryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LibraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryCountArgs<ExtArgs>,
            result: $Utils.Optional<LibraryCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: PostPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>,
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: AccountPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Career: {
        payload: CareerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CareerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload>
          }
          findFirst: {
            args: Prisma.CareerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload>
          }
          findMany: {
            args: Prisma.CareerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload>[]
          }
          create: {
            args: Prisma.CareerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload>
          }
          createMany: {
            args: Prisma.CareerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CareerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload>
          }
          update: {
            args: Prisma.CareerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload>
          }
          deleteMany: {
            args: Prisma.CareerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CareerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CareerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CareerPayload>
          }
          aggregate: {
            args: Prisma.CareerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCareer>
          }
          groupBy: {
            args: Prisma.CareerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CareerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareerCountArgs<ExtArgs>,
            result: $Utils.Optional<CareerCountAggregateOutputType> | number
          }
        }
      }
      Billrecieve: {
        payload: BillrecievePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BillrecieveFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillrecieveFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload>
          }
          findFirst: {
            args: Prisma.BillrecieveFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillrecieveFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload>
          }
          findMany: {
            args: Prisma.BillrecieveFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload>[]
          }
          create: {
            args: Prisma.BillrecieveCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload>
          }
          createMany: {
            args: Prisma.BillrecieveCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BillrecieveDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload>
          }
          update: {
            args: Prisma.BillrecieveUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload>
          }
          deleteMany: {
            args: Prisma.BillrecieveDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BillrecieveUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BillrecieveUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillrecievePayload>
          }
          aggregate: {
            args: Prisma.BillrecieveAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBillrecieve>
          }
          groupBy: {
            args: Prisma.BillrecieveGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BillrecieveGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillrecieveCountArgs<ExtArgs>,
            result: $Utils.Optional<BillrecieveCountAggregateOutputType> | number
          }
        }
      }
      Billpayable: {
        payload: BillpayablePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BillpayableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillpayableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload>
          }
          findFirst: {
            args: Prisma.BillpayableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillpayableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload>
          }
          findMany: {
            args: Prisma.BillpayableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload>[]
          }
          create: {
            args: Prisma.BillpayableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload>
          }
          createMany: {
            args: Prisma.BillpayableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BillpayableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload>
          }
          update: {
            args: Prisma.BillpayableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload>
          }
          deleteMany: {
            args: Prisma.BillpayableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BillpayableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BillpayableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillpayablePayload>
          }
          aggregate: {
            args: Prisma.BillpayableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBillpayable>
          }
          groupBy: {
            args: Prisma.BillpayableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BillpayableGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillpayableCountArgs<ExtArgs>,
            result: $Utils.Optional<BillpayableCountAggregateOutputType> | number
          }
        }
      }
      UploadedDocument: {
        payload: UploadedDocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UploadedDocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadedDocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload>
          }
          findFirst: {
            args: Prisma.UploadedDocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadedDocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload>
          }
          findMany: {
            args: Prisma.UploadedDocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload>[]
          }
          create: {
            args: Prisma.UploadedDocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload>
          }
          createMany: {
            args: Prisma.UploadedDocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UploadedDocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload>
          }
          update: {
            args: Prisma.UploadedDocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload>
          }
          deleteMany: {
            args: Prisma.UploadedDocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UploadedDocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UploadedDocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UploadedDocumentPayload>
          }
          aggregate: {
            args: Prisma.UploadedDocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUploadedDocument>
          }
          groupBy: {
            args: Prisma.UploadedDocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UploadedDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UploadedDocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<UploadedDocumentCountAggregateOutputType> | number
          }
        }
      }
      LoanDocument: {
        payload: LoanDocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LoanDocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanDocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload>
          }
          findFirst: {
            args: Prisma.LoanDocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanDocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload>
          }
          findMany: {
            args: Prisma.LoanDocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload>[]
          }
          create: {
            args: Prisma.LoanDocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload>
          }
          createMany: {
            args: Prisma.LoanDocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LoanDocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload>
          }
          update: {
            args: Prisma.LoanDocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload>
          }
          deleteMany: {
            args: Prisma.LoanDocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LoanDocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LoanDocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanDocumentPayload>
          }
          aggregate: {
            args: Prisma.LoanDocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLoanDocument>
          }
          groupBy: {
            args: Prisma.LoanDocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LoanDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanDocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<LoanDocumentCountAggregateOutputType> | number
          }
        }
      }
      Loan: {
        payload: LoanPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LoanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload>
          }
          findFirst: {
            args: Prisma.LoanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload>
          }
          findMany: {
            args: Prisma.LoanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload>[]
          }
          create: {
            args: Prisma.LoanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload>
          }
          createMany: {
            args: Prisma.LoanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LoanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload>
          }
          update: {
            args: Prisma.LoanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload>
          }
          deleteMany: {
            args: Prisma.LoanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LoanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LoanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanPayload>
          }
          aggregate: {
            args: Prisma.LoanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLoan>
          }
          groupBy: {
            args: Prisma.LoanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LoanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanCountArgs<ExtArgs>,
            result: $Utils.Optional<LoanCountAggregateOutputType> | number
          }
        }
      }
      LoanApplication: {
        payload: LoanApplicationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LoanApplicationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanApplicationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload>
          }
          findFirst: {
            args: Prisma.LoanApplicationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanApplicationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload>
          }
          findMany: {
            args: Prisma.LoanApplicationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload>[]
          }
          create: {
            args: Prisma.LoanApplicationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload>
          }
          createMany: {
            args: Prisma.LoanApplicationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LoanApplicationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload>
          }
          update: {
            args: Prisma.LoanApplicationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload>
          }
          deleteMany: {
            args: Prisma.LoanApplicationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LoanApplicationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LoanApplicationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoanApplicationPayload>
          }
          aggregate: {
            args: Prisma.LoanApplicationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLoanApplication>
          }
          groupBy: {
            args: Prisma.LoanApplicationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LoanApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanApplicationCountArgs<ExtArgs>,
            result: $Utils.Optional<LoanApplicationCountAggregateOutputType> | number
          }
        }
      }
      BankDetails: {
        payload: BankDetailsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BankDetailsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankDetailsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload>
          }
          findFirst: {
            args: Prisma.BankDetailsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankDetailsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload>
          }
          findMany: {
            args: Prisma.BankDetailsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload>[]
          }
          create: {
            args: Prisma.BankDetailsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload>
          }
          createMany: {
            args: Prisma.BankDetailsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BankDetailsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload>
          }
          update: {
            args: Prisma.BankDetailsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload>
          }
          deleteMany: {
            args: Prisma.BankDetailsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BankDetailsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BankDetailsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankDetailsPayload>
          }
          aggregate: {
            args: Prisma.BankDetailsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBankDetails>
          }
          groupBy: {
            args: Prisma.BankDetailsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BankDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankDetailsCountArgs<ExtArgs>,
            result: $Utils.Optional<BankDetailsCountAggregateOutputType> | number
          }
        }
      }
      Insurance: {
        payload: InsurancePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InsuranceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsuranceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          findFirst: {
            args: Prisma.InsuranceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsuranceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          findMany: {
            args: Prisma.InsuranceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>[]
          }
          create: {
            args: Prisma.InsuranceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          createMany: {
            args: Prisma.InsuranceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InsuranceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          update: {
            args: Prisma.InsuranceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          deleteMany: {
            args: Prisma.InsuranceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InsuranceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InsuranceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InsurancePayload>
          }
          aggregate: {
            args: Prisma.InsuranceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInsurance>
          }
          groupBy: {
            args: Prisma.InsuranceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InsuranceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsuranceCountArgs<ExtArgs>,
            result: $Utils.Optional<InsuranceCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: ClientPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: AgentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>,
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Visitor: {
        payload: VisitorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.VisitorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload>
          }
          findFirst: {
            args: Prisma.VisitorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload>
          }
          findMany: {
            args: Prisma.VisitorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload>[]
          }
          create: {
            args: Prisma.VisitorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload>
          }
          createMany: {
            args: Prisma.VisitorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VisitorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload>
          }
          update: {
            args: Prisma.VisitorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload>
          }
          deleteMany: {
            args: Prisma.VisitorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VisitorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VisitorPayload>
          }
          aggregate: {
            args: Prisma.VisitorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVisitor>
          }
          groupBy: {
            args: Prisma.VisitorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorCountArgs<ExtArgs>,
            result: $Utils.Optional<VisitorCountAggregateOutputType> | number
          }
        }
      }
      RegisterStartup: {
        payload: RegisterStartupPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.RegisterStartupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegisterStartupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload>
          }
          findFirst: {
            args: Prisma.RegisterStartupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegisterStartupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload>
          }
          findMany: {
            args: Prisma.RegisterStartupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload>[]
          }
          create: {
            args: Prisma.RegisterStartupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload>
          }
          createMany: {
            args: Prisma.RegisterStartupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RegisterStartupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload>
          }
          update: {
            args: Prisma.RegisterStartupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload>
          }
          deleteMany: {
            args: Prisma.RegisterStartupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RegisterStartupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RegisterStartupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegisterStartupPayload>
          }
          aggregate: {
            args: Prisma.RegisterStartupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRegisterStartup>
          }
          groupBy: {
            args: Prisma.RegisterStartupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RegisterStartupGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegisterStartupCountArgs<ExtArgs>,
            result: $Utils.Optional<RegisterStartupCountAggregateOutputType> | number
          }
        }
      }
      ContactUs: {
        payload: ContactUsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ContactUsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactUsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload>
          }
          findFirst: {
            args: Prisma.ContactUsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactUsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload>
          }
          findMany: {
            args: Prisma.ContactUsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload>[]
          }
          create: {
            args: Prisma.ContactUsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload>
          }
          createMany: {
            args: Prisma.ContactUsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContactUsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload>
          }
          update: {
            args: Prisma.ContactUsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload>
          }
          deleteMany: {
            args: Prisma.ContactUsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactUsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContactUsPayload>
          }
          aggregate: {
            args: Prisma.ContactUsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContactUs>
          }
          groupBy: {
            args: Prisma.ContactUsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactUsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactUsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactUsCountAggregateOutputType> | number
          }
        }
      }
      About: {
        payload: AboutPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AboutFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AboutFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload>
          }
          findFirst: {
            args: Prisma.AboutFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AboutFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload>
          }
          findMany: {
            args: Prisma.AboutFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload>[]
          }
          create: {
            args: Prisma.AboutCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload>
          }
          createMany: {
            args: Prisma.AboutCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AboutDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload>
          }
          update: {
            args: Prisma.AboutUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload>
          }
          deleteMany: {
            args: Prisma.AboutDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AboutUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AboutUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AboutPayload>
          }
          aggregate: {
            args: Prisma.AboutAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAbout>
          }
          groupBy: {
            args: Prisma.AboutGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AboutGroupByOutputType>[]
          }
          count: {
            args: Prisma.AboutCountArgs<ExtArgs>,
            result: $Utils.Optional<AboutCountAggregateOutputType> | number
          }
        }
      }
      Gstr1_4A: {
        payload: Gstr1_4APayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.Gstr1_4AFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gstr1_4AFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload>
          }
          findFirst: {
            args: Prisma.Gstr1_4AFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gstr1_4AFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload>
          }
          findMany: {
            args: Prisma.Gstr1_4AFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload>[]
          }
          create: {
            args: Prisma.Gstr1_4ACreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload>
          }
          createMany: {
            args: Prisma.Gstr1_4ACreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Gstr1_4ADeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload>
          }
          update: {
            args: Prisma.Gstr1_4AUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload>
          }
          deleteMany: {
            args: Prisma.Gstr1_4ADeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Gstr1_4AUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Gstr1_4AUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_4APayload>
          }
          aggregate: {
            args: Prisma.Gstr1_4AAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGstr1_4A>
          }
          groupBy: {
            args: Prisma.Gstr1_4AGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gstr1_4AGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gstr1_4ACountArgs<ExtArgs>,
            result: $Utils.Optional<Gstr1_4ACountAggregateOutputType> | number
          }
        }
      }
      Gstr1_5A: {
        payload: Gstr1_5APayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.Gstr1_5AFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gstr1_5AFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload>
          }
          findFirst: {
            args: Prisma.Gstr1_5AFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gstr1_5AFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload>
          }
          findMany: {
            args: Prisma.Gstr1_5AFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload>[]
          }
          create: {
            args: Prisma.Gstr1_5ACreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload>
          }
          createMany: {
            args: Prisma.Gstr1_5ACreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Gstr1_5ADeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload>
          }
          update: {
            args: Prisma.Gstr1_5AUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload>
          }
          deleteMany: {
            args: Prisma.Gstr1_5ADeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Gstr1_5AUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Gstr1_5AUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5APayload>
          }
          aggregate: {
            args: Prisma.Gstr1_5AAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGstr1_5A>
          }
          groupBy: {
            args: Prisma.Gstr1_5AGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gstr1_5AGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gstr1_5ACountArgs<ExtArgs>,
            result: $Utils.Optional<Gstr1_5ACountAggregateOutputType> | number
          }
        }
      }
      Gstr1_5A_item: {
        payload: Gstr1_5A_itemPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.Gstr1_5A_itemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gstr1_5A_itemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload>
          }
          findFirst: {
            args: Prisma.Gstr1_5A_itemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gstr1_5A_itemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload>
          }
          findMany: {
            args: Prisma.Gstr1_5A_itemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload>[]
          }
          create: {
            args: Prisma.Gstr1_5A_itemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload>
          }
          createMany: {
            args: Prisma.Gstr1_5A_itemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Gstr1_5A_itemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload>
          }
          update: {
            args: Prisma.Gstr1_5A_itemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload>
          }
          deleteMany: {
            args: Prisma.Gstr1_5A_itemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Gstr1_5A_itemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Gstr1_5A_itemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Gstr1_5A_itemPayload>
          }
          aggregate: {
            args: Prisma.Gstr1_5A_itemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGstr1_5A_item>
          }
          groupBy: {
            args: Prisma.Gstr1_5A_itemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gstr1_5A_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gstr1_5A_itemCountArgs<ExtArgs>,
            result: $Utils.Optional<Gstr1_5A_itemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    otps: number
    invoices: number
    categories: number
    items: number
    parties: number
    payments: number
    orders: number
    posts: number
    accounts: number
    bankAccounts: number
    loans: number
    documents: number
    insurances: number
    registerStartup: number
    contactUs: number
    journalEntries: number
    legders: number
    transactions: number
    clientAccounts: number
    gstr1: number
    gstr1_5A: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    otps?: boolean | UserCountOutputTypeCountOtpsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    categories?: boolean | UserCountOutputTypeCountCategoriesArgs
    items?: boolean | UserCountOutputTypeCountItemsArgs
    parties?: boolean | UserCountOutputTypeCountPartiesArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    bankAccounts?: boolean | UserCountOutputTypeCountBankAccountsArgs
    loans?: boolean | UserCountOutputTypeCountLoansArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    insurances?: boolean | UserCountOutputTypeCountInsurancesArgs
    registerStartup?: boolean | UserCountOutputTypeCountRegisterStartupArgs
    contactUs?: boolean | UserCountOutputTypeCountContactUsArgs
    journalEntries?: boolean | UserCountOutputTypeCountJournalEntriesArgs
    legders?: boolean | UserCountOutputTypeCountLegdersArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    clientAccounts?: boolean | UserCountOutputTypeCountClientAccountsArgs
    gstr1?: boolean | UserCountOutputTypeCountGstr1Args
    gstr1_5A?: boolean | UserCountOutputTypeCountGstr1_5AArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPartiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PartyWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBankAccountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BankDetailsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UploadedDocumentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInsurancesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InsuranceWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRegisterStartupArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RegisterStartupWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactUsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContactUsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLegdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LedgerWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientAccountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGstr1Args<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Gstr1_4AWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGstr1_5AArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Gstr1_5AWhereInput
  }



  /**
   * Count Type LedgerCountOutputType
   */


  export type LedgerCountOutputType = {
    transactions: number
  }

  export type LedgerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    transactions?: boolean | LedgerCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes

  /**
   * LedgerCountOutputType without action
   */
  export type LedgerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerCountOutputType
     */
    select?: LedgerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LedgerCountOutputType without action
   */
  export type LedgerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }



  /**
   * Count Type JournalEntryCountOutputType
   */


  export type JournalEntryCountOutputType = {
    transactions: number
  }

  export type JournalEntryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    transactions?: boolean | JournalEntryCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes

  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntryCountOutputType
     */
    select?: JournalEntryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }



  /**
   * Count Type PartyCountOutputType
   */


  export type PartyCountOutputType = {
    invoices: number
    items: number
    ledgers: number
  }

  export type PartyCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoices?: boolean | PartyCountOutputTypeCountInvoicesArgs
    items?: boolean | PartyCountOutputTypeCountItemsArgs
    ledgers?: boolean | PartyCountOutputTypeCountLedgersArgs
  }

  // Custom InputTypes

  /**
   * PartyCountOutputType without action
   */
  export type PartyCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyCountOutputType
     */
    select?: PartyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PartyCountOutputType without action
   */
  export type PartyCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * PartyCountOutputType without action
   */
  export type PartyCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * PartyCountOutputType without action
   */
  export type PartyCountOutputTypeCountLedgersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LedgerWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    items: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    items?: boolean | CategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }



  /**
   * Count Type ItemCountOutputType
   */


  export type ItemCountOutputType = {
    invoiceItems: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | ItemCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }



  /**
   * Count Type InvoiceCountOutputType
   */


  export type InvoiceCountOutputType = {
    invoiceItems: number
    accounts: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | InvoiceCountOutputTypeCountInvoiceItemsArgs
    accounts?: boolean | InvoiceCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }



  /**
   * Count Type AccountCountOutputType
   */


  export type AccountCountOutputType = {
    invoices: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoices?: boolean | AccountCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }



  /**
   * Count Type UploadedDocumentCountOutputType
   */


  export type UploadedDocumentCountOutputType = {
    docs: number
  }

  export type UploadedDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    docs?: boolean | UploadedDocumentCountOutputTypeCountDocsArgs
  }

  // Custom InputTypes

  /**
   * UploadedDocumentCountOutputType without action
   */
  export type UploadedDocumentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocumentCountOutputType
     */
    select?: UploadedDocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UploadedDocumentCountOutputType without action
   */
  export type UploadedDocumentCountOutputTypeCountDocsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanDocumentWhereInput
  }



  /**
   * Count Type LoanDocumentCountOutputType
   */


  export type LoanDocumentCountOutputType = {
    documents: number
    loans: number
  }

  export type LoanDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | LoanDocumentCountOutputTypeCountDocumentsArgs
    loans?: boolean | LoanDocumentCountOutputTypeCountLoansArgs
  }

  // Custom InputTypes

  /**
   * LoanDocumentCountOutputType without action
   */
  export type LoanDocumentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocumentCountOutputType
     */
    select?: LoanDocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LoanDocumentCountOutputType without action
   */
  export type LoanDocumentCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UploadedDocumentWhereInput
  }


  /**
   * LoanDocumentCountOutputType without action
   */
  export type LoanDocumentCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanWhereInput
  }



  /**
   * Count Type LoanCountOutputType
   */


  export type LoanCountOutputType = {
    documents: number
    applications: number
  }

  export type LoanCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | LoanCountOutputTypeCountDocumentsArgs
    applications?: boolean | LoanCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes

  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanCountOutputType
     */
    select?: LoanCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanDocumentWhereInput
  }


  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }



  /**
   * Count Type LoanApplicationCountOutputType
   */


  export type LoanApplicationCountOutputType = {
    documents: number
  }

  export type LoanApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | LoanApplicationCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes

  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplicationCountOutputType
     */
    select?: LoanApplicationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UploadedDocumentWhereInput
  }



  /**
   * Count Type BankDetailsCountOutputType
   */


  export type BankDetailsCountOutputType = {
    loans: number
  }

  export type BankDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    loans?: boolean | BankDetailsCountOutputTypeCountLoansArgs
  }

  // Custom InputTypes

  /**
   * BankDetailsCountOutputType without action
   */
  export type BankDetailsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetailsCountOutputType
     */
    select?: BankDetailsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BankDetailsCountOutputType without action
   */
  export type BankDetailsCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }



  /**
   * Count Type AgentCountOutputType
   */


  export type AgentCountOutputType = {
    clients: number
    loans: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    clients?: boolean | AgentCountOutputTypeCountClientsArgs
    loans?: boolean | AgentCountOutputTypeCountLoansArgs
  }

  // Custom InputTypes

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }


  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }



  /**
   * Count Type Gstr1_5ACountOutputType
   */


  export type Gstr1_5ACountOutputType = {
    gstr1_5A_items: number
  }

  export type Gstr1_5ACountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    gstr1_5A_items?: boolean | Gstr1_5ACountOutputTypeCountGstr1_5A_itemsArgs
  }

  // Custom InputTypes

  /**
   * Gstr1_5ACountOutputType without action
   */
  export type Gstr1_5ACountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5ACountOutputType
     */
    select?: Gstr1_5ACountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Gstr1_5ACountOutputType without action
   */
  export type Gstr1_5ACountOutputTypeCountGstr1_5A_itemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Gstr1_5A_itemWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    adminId: number | null
    superadminId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    adminId: number | null
    superadminId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    fatherName: string | null
    phone: string | null
    gender: UserGender | null
    address: string | null
    pin: string | null
    aadhaar: string | null
    pan: string | null
    dob: Date | null
    avatar: string | null
    adminId: number | null
    superadminId: number | null
    verified: boolean | null
    userType: UserType | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    fatherName: string | null
    phone: string | null
    gender: UserGender | null
    address: string | null
    pin: string | null
    aadhaar: string | null
    pan: string | null
    dob: Date | null
    avatar: string | null
    adminId: number | null
    superadminId: number | null
    verified: boolean | null
    userType: UserType | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    email: number
    password: number
    firstName: number
    lastName: number
    fatherName: number
    phone: number
    gender: number
    address: number
    pin: number
    aadhaar: number
    pan: number
    dob: number
    avatar: number
    adminId: number
    superadminId: number
    verified: number
    userType: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    adminId?: true
    superadminId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    adminId?: true
    superadminId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    fatherName?: true
    phone?: true
    gender?: true
    address?: true
    pin?: true
    aadhaar?: true
    pan?: true
    dob?: true
    avatar?: true
    adminId?: true
    superadminId?: true
    verified?: true
    userType?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    fatherName?: true
    phone?: true
    gender?: true
    address?: true
    pin?: true
    aadhaar?: true
    pan?: true
    dob?: true
    avatar?: true
    adminId?: true
    superadminId?: true
    verified?: true
    userType?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    fatherName?: true
    phone?: true
    gender?: true
    address?: true
    pin?: true
    aadhaar?: true
    pan?: true
    dob?: true
    avatar?: true
    adminId?: true
    superadminId?: true
    verified?: true
    userType?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    email: string
    password: string
    firstName: string
    lastName: string | null
    fatherName: string | null
    phone: string | null
    gender: UserGender
    address: string | null
    pin: string | null
    aadhaar: string | null
    pan: string | null
    dob: Date | null
    avatar: string | null
    adminId: number | null
    superadminId: number | null
    verified: boolean
    userType: UserType
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    fatherName?: boolean
    phone?: boolean
    gender?: boolean
    address?: boolean
    pin?: boolean
    aadhaar?: boolean
    pan?: boolean
    dob?: boolean
    avatar?: boolean
    adminId?: boolean
    superadminId?: boolean
    verified?: boolean
    userType?: boolean
    otps?: boolean | User$otpsArgs<ExtArgs>
    businessProfile?: boolean | BusinessProfileArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    items?: boolean | User$itemsArgs<ExtArgs>
    parties?: boolean | User$partiesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    bankAccounts?: boolean | User$bankAccountsArgs<ExtArgs>
    loans?: boolean | User$loansArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    insurances?: boolean | User$insurancesArgs<ExtArgs>
    registerStartup?: boolean | User$registerStartupArgs<ExtArgs>
    contactUs?: boolean | User$contactUsArgs<ExtArgs>
    journalEntries?: boolean | User$journalEntriesArgs<ExtArgs>
    legders?: boolean | User$legdersArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    agentId?: boolean | AgentArgs<ExtArgs>
    clientAccounts?: boolean | User$clientAccountsArgs<ExtArgs>
    gstr1?: boolean | User$gstr1Args<ExtArgs>
    gstr1_5A?: boolean | User$gstr1_5AArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    fatherName?: boolean
    phone?: boolean
    gender?: boolean
    address?: boolean
    pin?: boolean
    aadhaar?: boolean
    pan?: boolean
    dob?: boolean
    avatar?: boolean
    adminId?: boolean
    superadminId?: boolean
    verified?: boolean
    userType?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    otps?: boolean | User$otpsArgs<ExtArgs>
    businessProfile?: boolean | BusinessProfileArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    items?: boolean | User$itemsArgs<ExtArgs>
    parties?: boolean | User$partiesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    bankAccounts?: boolean | User$bankAccountsArgs<ExtArgs>
    loans?: boolean | User$loansArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    insurances?: boolean | User$insurancesArgs<ExtArgs>
    registerStartup?: boolean | User$registerStartupArgs<ExtArgs>
    contactUs?: boolean | User$contactUsArgs<ExtArgs>
    journalEntries?: boolean | User$journalEntriesArgs<ExtArgs>
    legders?: boolean | User$legdersArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    agentId?: boolean | AgentArgs<ExtArgs>
    clientAccounts?: boolean | User$clientAccountsArgs<ExtArgs>
    gstr1?: boolean | User$gstr1Args<ExtArgs>
    gstr1_5A?: boolean | User$gstr1_5AArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    otps<T extends User$otpsArgs<ExtArgs> = {}>(args?: Subset<T, User$otpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findMany', never>| Null>;

    businessProfile<T extends BusinessProfileArgs<ExtArgs> = {}>(args?: Subset<T, BusinessProfileArgs<ExtArgs>>): Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    categories<T extends User$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    items<T extends User$itemsArgs<ExtArgs> = {}>(args?: Subset<T, User$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    parties<T extends User$partiesArgs<ExtArgs> = {}>(args?: Subset<T, User$partiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findMany', never>| Null>;

    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PostPayload<ExtArgs>, T, 'findMany', never>| Null>;

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>| Null>;

    bankAccounts<T extends User$bankAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$bankAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    loans<T extends User$loansArgs<ExtArgs> = {}>(args?: Subset<T, User$loansArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    insurances<T extends User$insurancesArgs<ExtArgs> = {}>(args?: Subset<T, User$insurancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findMany', never>| Null>;

    registerStartup<T extends User$registerStartupArgs<ExtArgs> = {}>(args?: Subset<T, User$registerStartupArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'findMany', never>| Null>;

    contactUs<T extends User$contactUsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactUsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    journalEntries<T extends User$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    legders<T extends User$legdersArgs<ExtArgs> = {}>(args?: Subset<T, User$legdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    agentId<T extends AgentArgs<ExtArgs> = {}>(args?: Subset<T, AgentArgs<ExtArgs>>): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    clientAccounts<T extends User$clientAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findMany', never>| Null>;

    gstr1<T extends User$gstr1Args<ExtArgs> = {}>(args?: Subset<T, User$gstr1Args<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'findMany', never>| Null>;

    gstr1_5A<T extends User$gstr1_5AArgs<ExtArgs> = {}>(args?: Subset<T, User$gstr1_5AArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.otps
   */
  export type User$otpsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    where?: OtpWhereInput
    orderBy?: Enumerable<OtpOrderByWithRelationAndSearchRelevanceInput>
    cursor?: OtpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OtpScalarFieldEnum>
  }


  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * User.categories
   */
  export type User$categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * User.items
   */
  export type User$itemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * User.parties
   */
  export type User$partiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    where?: PartyWhereInput
    orderBy?: Enumerable<PartyOrderByWithRelationAndSearchRelevanceInput>
    cursor?: PartyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PartyScalarFieldEnum>
  }


  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationAndSearchRelevanceInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * User.bankAccounts
   */
  export type User$bankAccountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    where?: BankDetailsWhereInput
    orderBy?: Enumerable<BankDetailsOrderByWithRelationAndSearchRelevanceInput>
    cursor?: BankDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BankDetailsScalarFieldEnum>
  }


  /**
   * User.loans
   */
  export type User$loansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: Enumerable<LoanApplicationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoanApplicationScalarFieldEnum>
  }


  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    where?: UploadedDocumentWhereInput
    orderBy?: Enumerable<UploadedDocumentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: UploadedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UploadedDocumentScalarFieldEnum>
  }


  /**
   * User.insurances
   */
  export type User$insurancesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    where?: InsuranceWhereInput
    orderBy?: Enumerable<InsuranceOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InsuranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InsuranceScalarFieldEnum>
  }


  /**
   * User.registerStartup
   */
  export type User$registerStartupArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    where?: RegisterStartupWhereInput
    orderBy?: Enumerable<RegisterStartupOrderByWithRelationAndSearchRelevanceInput>
    cursor?: RegisterStartupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RegisterStartupScalarFieldEnum>
  }


  /**
   * User.contactUs
   */
  export type User$contactUsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    where?: ContactUsWhereInput
    orderBy?: Enumerable<ContactUsOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ContactUsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ContactUsScalarFieldEnum>
  }


  /**
   * User.journalEntries
   */
  export type User$journalEntriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: Enumerable<JournalEntryOrderByWithRelationAndSearchRelevanceInput>
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<JournalEntryScalarFieldEnum>
  }


  /**
   * User.legders
   */
  export type User$legdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    where?: LedgerWhereInput
    orderBy?: Enumerable<LedgerOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LedgerScalarFieldEnum>
  }


  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationAndSearchRelevanceInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * User.clientAccounts
   */
  export type User$clientAccountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * User.gstr1
   */
  export type User$gstr1Args<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    where?: Gstr1_4AWhereInput
    orderBy?: Enumerable<Gstr1_4AOrderByWithRelationAndSearchRelevanceInput>
    cursor?: Gstr1_4AWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Gstr1_4AScalarFieldEnum>
  }


  /**
   * User.gstr1_5A
   */
  export type User$gstr1_5AArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    where?: Gstr1_5AWhereInput
    orderBy?: Enumerable<Gstr1_5AOrderByWithRelationAndSearchRelevanceInput>
    cursor?: Gstr1_5AWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Gstr1_5AScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Otp
   */


  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OtpSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OtpMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    otp: string | null
    userId: number | null
    used: boolean | null
  }

  export type OtpMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    otp: string | null
    userId: number | null
    used: boolean | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    createdAt: number
    otp: number
    userId: number
    used: number
    _all: number
  }


  export type OtpAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OtpSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OtpMinAggregateInputType = {
    id?: true
    createdAt?: true
    otp?: true
    userId?: true
    used?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    createdAt?: true
    otp?: true
    userId?: true
    used?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    createdAt?: true
    otp?: true
    userId?: true
    used?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: Enumerable<OtpOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: Enumerable<OtpOrderByWithAggregationInput>
    by: OtpScalarFieldEnum[]
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _avg?: OtpAvgAggregateInputType
    _sum?: OtpSumAggregateInputType
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }


  export type OtpGroupByOutputType = {
    id: number
    createdAt: Date
    otp: string
    userId: number
    used: boolean
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    otp?: boolean
    userId?: boolean
    used?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    createdAt?: boolean
    otp?: boolean
    userId?: boolean
    used?: boolean
  }

  export type OtpInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type OtpGetPayload<S extends boolean | null | undefined | OtpArgs> = $Types.GetResult<OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OtpFindManyArgs, 'select' | 'include'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OtpFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Otp'> extends True ? Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Otp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OtpFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Otp'> extends True ? Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Otp that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OtpFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
    **/
    create<T extends OtpCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OtpCreateArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Otps.
     *     @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     *     @example
     *     // Create many Otps
     *     const otp = await prisma.otp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OtpCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
    **/
    delete<T extends OtpDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OtpUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OtpDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OtpUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
    **/
    upsert<T extends OtpUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Otp base type for findUnique actions
   */
  export type OtpFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUnique
   */
  export interface OtpFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OtpFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp base type for findFirst actions
   */
  export type OtpFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: Enumerable<OtpOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: Enumerable<OtpScalarFieldEnum>
  }

  /**
   * Otp findFirst
   */
  export interface OtpFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OtpFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: Enumerable<OtpOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: Enumerable<OtpScalarFieldEnum>
  }


  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: Enumerable<OtpOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: Enumerable<OtpScalarFieldEnum>
  }


  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }


  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: Enumerable<OtpCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
  }


  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }


  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
  }


  /**
   * Otp without action
   */
  export type OtpArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
  }



  /**
   * Model BusinessProfile
   */


  export type AggregateBusinessProfile = {
    _count: BusinessProfileCountAggregateOutputType | null
    _avg: BusinessProfileAvgAggregateOutputType | null
    _sum: BusinessProfileSumAggregateOutputType | null
    _min: BusinessProfileMinAggregateOutputType | null
    _max: BusinessProfileMaxAggregateOutputType | null
  }

  export type BusinessProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BusinessProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BusinessProfileMinAggregateOutputType = {
    id: number | null
    businessName: string | null
    pan: string | null
    tan: string | null
    gstin: string | null
    address: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    bankBranch: string | null
    state: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isAddressVerified: boolean | null
    isBusinessNameVerified: boolean | null
    isGstinVerified: boolean | null
    isPanVerified: boolean | null
    isStateVerified: boolean | null
  }

  export type BusinessProfileMaxAggregateOutputType = {
    id: number | null
    businessName: string | null
    pan: string | null
    tan: string | null
    gstin: string | null
    address: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    bankBranch: string | null
    state: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isAddressVerified: boolean | null
    isBusinessNameVerified: boolean | null
    isGstinVerified: boolean | null
    isPanVerified: boolean | null
    isStateVerified: boolean | null
  }

  export type BusinessProfileCountAggregateOutputType = {
    id: number
    businessName: number
    pan: number
    tan: number
    gstin: number
    address: number
    bankName: number
    bankAccountNo: number
    bankIfsc: number
    bankBranch: number
    state: number
    userId: number
    createdAt: number
    updatedAt: number
    isAddressVerified: number
    isBusinessNameVerified: number
    isGstinVerified: number
    isPanVerified: number
    isStateVerified: number
    _all: number
  }


  export type BusinessProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BusinessProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BusinessProfileMinAggregateInputType = {
    id?: true
    businessName?: true
    pan?: true
    tan?: true
    gstin?: true
    address?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    bankBranch?: true
    state?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isAddressVerified?: true
    isBusinessNameVerified?: true
    isGstinVerified?: true
    isPanVerified?: true
    isStateVerified?: true
  }

  export type BusinessProfileMaxAggregateInputType = {
    id?: true
    businessName?: true
    pan?: true
    tan?: true
    gstin?: true
    address?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    bankBranch?: true
    state?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isAddressVerified?: true
    isBusinessNameVerified?: true
    isGstinVerified?: true
    isPanVerified?: true
    isStateVerified?: true
  }

  export type BusinessProfileCountAggregateInputType = {
    id?: true
    businessName?: true
    pan?: true
    tan?: true
    gstin?: true
    address?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    bankBranch?: true
    state?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isAddressVerified?: true
    isBusinessNameVerified?: true
    isGstinVerified?: true
    isPanVerified?: true
    isStateVerified?: true
    _all?: true
  }

  export type BusinessProfileAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessProfile to aggregate.
     */
    where?: BusinessProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessProfiles to fetch.
     */
    orderBy?: Enumerable<BusinessProfileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessProfiles
    **/
    _count?: true | BusinessProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessProfileMaxAggregateInputType
  }

  export type GetBusinessProfileAggregateType<T extends BusinessProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessProfile[P]>
      : GetScalarType<T[P], AggregateBusinessProfile[P]>
  }




  export type BusinessProfileGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusinessProfileWhereInput
    orderBy?: Enumerable<BusinessProfileOrderByWithAggregationInput>
    by: BusinessProfileScalarFieldEnum[]
    having?: BusinessProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessProfileCountAggregateInputType | true
    _avg?: BusinessProfileAvgAggregateInputType
    _sum?: BusinessProfileSumAggregateInputType
    _min?: BusinessProfileMinAggregateInputType
    _max?: BusinessProfileMaxAggregateInputType
  }


  export type BusinessProfileGroupByOutputType = {
    id: number
    businessName: string
    pan: string | null
    tan: string | null
    gstin: string | null
    address: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    bankBranch: string | null
    state: string | null
    userId: number
    createdAt: Date
    updatedAt: Date
    isAddressVerified: boolean | null
    isBusinessNameVerified: boolean | null
    isGstinVerified: boolean | null
    isPanVerified: boolean | null
    isStateVerified: boolean | null
    _count: BusinessProfileCountAggregateOutputType | null
    _avg: BusinessProfileAvgAggregateOutputType | null
    _sum: BusinessProfileSumAggregateOutputType | null
    _min: BusinessProfileMinAggregateOutputType | null
    _max: BusinessProfileMaxAggregateOutputType | null
  }

  type GetBusinessProfileGroupByPayload<T extends BusinessProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessProfileGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessProfileGroupByOutputType[P]>
        }
      >
    >


  export type BusinessProfileSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessName?: boolean
    pan?: boolean
    tan?: boolean
    gstin?: boolean
    address?: boolean
    bankName?: boolean
    bankAccountNo?: boolean
    bankIfsc?: boolean
    bankBranch?: boolean
    state?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAddressVerified?: boolean
    isBusinessNameVerified?: boolean
    isGstinVerified?: boolean
    isPanVerified?: boolean
    isStateVerified?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["businessProfile"]>

  export type BusinessProfileSelectScalar = {
    id?: boolean
    businessName?: boolean
    pan?: boolean
    tan?: boolean
    gstin?: boolean
    address?: boolean
    bankName?: boolean
    bankAccountNo?: boolean
    bankIfsc?: boolean
    bankBranch?: boolean
    state?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAddressVerified?: boolean
    isBusinessNameVerified?: boolean
    isGstinVerified?: boolean
    isPanVerified?: boolean
    isStateVerified?: boolean
  }

  export type BusinessProfileInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type BusinessProfileGetPayload<S extends boolean | null | undefined | BusinessProfileArgs> = $Types.GetResult<BusinessProfilePayload, S>

  type BusinessProfileCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BusinessProfileFindManyArgs, 'select' | 'include'> & {
      select?: BusinessProfileCountAggregateInputType | true
    }

  export interface BusinessProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessProfile'], meta: { name: 'BusinessProfile' } }
    /**
     * Find zero or one BusinessProfile that matches the filter.
     * @param {BusinessProfileFindUniqueArgs} args - Arguments to find a BusinessProfile
     * @example
     * // Get one BusinessProfile
     * const businessProfile = await prisma.businessProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessProfileFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessProfileFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessProfile'> extends True ? Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BusinessProfile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessProfileFindUniqueOrThrowArgs} args - Arguments to find a BusinessProfile
     * @example
     * // Get one BusinessProfile
     * const businessProfile = await prisma.businessProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessProfileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BusinessProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileFindFirstArgs} args - Arguments to find a BusinessProfile
     * @example
     * // Get one BusinessProfile
     * const businessProfile = await prisma.businessProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessProfileFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessProfileFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessProfile'> extends True ? Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BusinessProfile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileFindFirstOrThrowArgs} args - Arguments to find a BusinessProfile
     * @example
     * // Get one BusinessProfile
     * const businessProfile = await prisma.businessProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessProfileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BusinessProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessProfiles
     * const businessProfiles = await prisma.businessProfile.findMany()
     * 
     * // Get first 10 BusinessProfiles
     * const businessProfiles = await prisma.businessProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessProfileWithIdOnly = await prisma.businessProfile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessProfileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BusinessProfile.
     * @param {BusinessProfileCreateArgs} args - Arguments to create a BusinessProfile.
     * @example
     * // Create one BusinessProfile
     * const BusinessProfile = await prisma.businessProfile.create({
     *   data: {
     *     // ... data to create a BusinessProfile
     *   }
     * })
     * 
    **/
    create<T extends BusinessProfileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessProfileCreateArgs<ExtArgs>>
    ): Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BusinessProfiles.
     *     @param {BusinessProfileCreateManyArgs} args - Arguments to create many BusinessProfiles.
     *     @example
     *     // Create many BusinessProfiles
     *     const businessProfile = await prisma.businessProfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessProfileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessProfile.
     * @param {BusinessProfileDeleteArgs} args - Arguments to delete one BusinessProfile.
     * @example
     * // Delete one BusinessProfile
     * const BusinessProfile = await prisma.businessProfile.delete({
     *   where: {
     *     // ... filter to delete one BusinessProfile
     *   }
     * })
     * 
    **/
    delete<T extends BusinessProfileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessProfileDeleteArgs<ExtArgs>>
    ): Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BusinessProfile.
     * @param {BusinessProfileUpdateArgs} args - Arguments to update one BusinessProfile.
     * @example
     * // Update one BusinessProfile
     * const businessProfile = await prisma.businessProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessProfileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessProfileUpdateArgs<ExtArgs>>
    ): Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BusinessProfiles.
     * @param {BusinessProfileDeleteManyArgs} args - Arguments to filter BusinessProfiles to delete.
     * @example
     * // Delete a few BusinessProfiles
     * const { count } = await prisma.businessProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessProfileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessProfiles
     * const businessProfile = await prisma.businessProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessProfileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessProfile.
     * @param {BusinessProfileUpsertArgs} args - Arguments to update or create a BusinessProfile.
     * @example
     * // Update or create a BusinessProfile
     * const businessProfile = await prisma.businessProfile.upsert({
     *   create: {
     *     // ... data to create a BusinessProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessProfile we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessProfileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessProfileUpsertArgs<ExtArgs>>
    ): Prisma__BusinessProfileClient<$Types.GetResult<BusinessProfilePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BusinessProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileCountArgs} args - Arguments to filter BusinessProfiles to count.
     * @example
     * // Count the number of BusinessProfiles
     * const count = await prisma.businessProfile.count({
     *   where: {
     *     // ... the filter for the BusinessProfiles we want to count
     *   }
     * })
    **/
    count<T extends BusinessProfileCountArgs>(
      args?: Subset<T, BusinessProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessProfileAggregateArgs>(args: Subset<T, BusinessProfileAggregateArgs>): Prisma.PrismaPromise<GetBusinessProfileAggregateType<T>>

    /**
     * Group by BusinessProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessProfileGroupByArgs['orderBy'] }
        : { orderBy?: BusinessProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessProfileClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessProfile base type for findUnique actions
   */
  export type BusinessProfileFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfile to fetch.
     */
    where: BusinessProfileWhereUniqueInput
  }

  /**
   * BusinessProfile findUnique
   */
  export interface BusinessProfileFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessProfileFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessProfile findUniqueOrThrow
   */
  export type BusinessProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfile to fetch.
     */
    where: BusinessProfileWhereUniqueInput
  }


  /**
   * BusinessProfile base type for findFirst actions
   */
  export type BusinessProfileFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfile to fetch.
     */
    where?: BusinessProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessProfiles to fetch.
     */
    orderBy?: Enumerable<BusinessProfileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessProfiles.
     */
    cursor?: BusinessProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessProfiles.
     */
    distinct?: Enumerable<BusinessProfileScalarFieldEnum>
  }

  /**
   * BusinessProfile findFirst
   */
  export interface BusinessProfileFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessProfileFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessProfile findFirstOrThrow
   */
  export type BusinessProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfile to fetch.
     */
    where?: BusinessProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessProfiles to fetch.
     */
    orderBy?: Enumerable<BusinessProfileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessProfiles.
     */
    cursor?: BusinessProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessProfiles.
     */
    distinct?: Enumerable<BusinessProfileScalarFieldEnum>
  }


  /**
   * BusinessProfile findMany
   */
  export type BusinessProfileFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter, which BusinessProfiles to fetch.
     */
    where?: BusinessProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessProfiles to fetch.
     */
    orderBy?: Enumerable<BusinessProfileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessProfiles.
     */
    cursor?: BusinessProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessProfiles.
     */
    skip?: number
    distinct?: Enumerable<BusinessProfileScalarFieldEnum>
  }


  /**
   * BusinessProfile create
   */
  export type BusinessProfileCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessProfile.
     */
    data: XOR<BusinessProfileCreateInput, BusinessProfileUncheckedCreateInput>
  }


  /**
   * BusinessProfile createMany
   */
  export type BusinessProfileCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessProfiles.
     */
    data: Enumerable<BusinessProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessProfile update
   */
  export type BusinessProfileUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessProfile.
     */
    data: XOR<BusinessProfileUpdateInput, BusinessProfileUncheckedUpdateInput>
    /**
     * Choose, which BusinessProfile to update.
     */
    where: BusinessProfileWhereUniqueInput
  }


  /**
   * BusinessProfile updateMany
   */
  export type BusinessProfileUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessProfiles.
     */
    data: XOR<BusinessProfileUpdateManyMutationInput, BusinessProfileUncheckedUpdateManyInput>
    /**
     * Filter which BusinessProfiles to update
     */
    where?: BusinessProfileWhereInput
  }


  /**
   * BusinessProfile upsert
   */
  export type BusinessProfileUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessProfile to update in case it exists.
     */
    where: BusinessProfileWhereUniqueInput
    /**
     * In case the BusinessProfile found by the `where` argument doesn't exist, create a new BusinessProfile with this data.
     */
    create: XOR<BusinessProfileCreateInput, BusinessProfileUncheckedCreateInput>
    /**
     * In case the BusinessProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessProfileUpdateInput, BusinessProfileUncheckedUpdateInput>
  }


  /**
   * BusinessProfile delete
   */
  export type BusinessProfileDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
    /**
     * Filter which BusinessProfile to delete.
     */
    where: BusinessProfileWhereUniqueInput
  }


  /**
   * BusinessProfile deleteMany
   */
  export type BusinessProfileDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessProfiles to delete
     */
    where?: BusinessProfileWhereInput
  }


  /**
   * BusinessProfile without action
   */
  export type BusinessProfileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessProfile
     */
    select?: BusinessProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessProfileInclude<ExtArgs> | null
  }



  /**
   * Model Ledger
   */


  export type AggregateLedger = {
    _count: LedgerCountAggregateOutputType | null
    _avg: LedgerAvgAggregateOutputType | null
    _sum: LedgerSumAggregateOutputType | null
    _min: LedgerMinAggregateOutputType | null
    _max: LedgerMaxAggregateOutputType | null
  }

  export type LedgerAvgAggregateOutputType = {
    openingBalance: Decimal | null
    balance: Decimal | null
    userId: number | null
    year: number | null
    month: number | null
  }

  export type LedgerSumAggregateOutputType = {
    openingBalance: Decimal | null
    balance: Decimal | null
    userId: number | null
    year: number | null
    month: number | null
  }

  export type LedgerMinAggregateOutputType = {
    id: string | null
    ledgerName: string | null
    openingBalance: Decimal | null
    balance: Decimal | null
    userId: number | null
    partyId: string | null
    year: number | null
    month: number | null
    ledgerType: LedgerType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LedgerMaxAggregateOutputType = {
    id: string | null
    ledgerName: string | null
    openingBalance: Decimal | null
    balance: Decimal | null
    userId: number | null
    partyId: string | null
    year: number | null
    month: number | null
    ledgerType: LedgerType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LedgerCountAggregateOutputType = {
    id: number
    ledgerName: number
    openingBalance: number
    balance: number
    userId: number
    partyId: number
    year: number
    month: number
    ledgerType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LedgerAvgAggregateInputType = {
    openingBalance?: true
    balance?: true
    userId?: true
    year?: true
    month?: true
  }

  export type LedgerSumAggregateInputType = {
    openingBalance?: true
    balance?: true
    userId?: true
    year?: true
    month?: true
  }

  export type LedgerMinAggregateInputType = {
    id?: true
    ledgerName?: true
    openingBalance?: true
    balance?: true
    userId?: true
    partyId?: true
    year?: true
    month?: true
    ledgerType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LedgerMaxAggregateInputType = {
    id?: true
    ledgerName?: true
    openingBalance?: true
    balance?: true
    userId?: true
    partyId?: true
    year?: true
    month?: true
    ledgerType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LedgerCountAggregateInputType = {
    id?: true
    ledgerName?: true
    openingBalance?: true
    balance?: true
    userId?: true
    partyId?: true
    year?: true
    month?: true
    ledgerType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LedgerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ledger to aggregate.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: Enumerable<LedgerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ledgers
    **/
    _count?: true | LedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerMaxAggregateInputType
  }

  export type GetLedgerAggregateType<T extends LedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedger[P]>
      : GetScalarType<T[P], AggregateLedger[P]>
  }




  export type LedgerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LedgerWhereInput
    orderBy?: Enumerable<LedgerOrderByWithAggregationInput>
    by: LedgerScalarFieldEnum[]
    having?: LedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerCountAggregateInputType | true
    _avg?: LedgerAvgAggregateInputType
    _sum?: LedgerSumAggregateInputType
    _min?: LedgerMinAggregateInputType
    _max?: LedgerMaxAggregateInputType
  }


  export type LedgerGroupByOutputType = {
    id: string
    ledgerName: string
    openingBalance: Decimal
    balance: Decimal
    userId: number
    partyId: string | null
    year: number
    month: number
    ledgerType: LedgerType
    createdAt: Date
    updatedAt: Date
    _count: LedgerCountAggregateOutputType | null
    _avg: LedgerAvgAggregateOutputType | null
    _sum: LedgerSumAggregateOutputType | null
    _min: LedgerMinAggregateOutputType | null
    _max: LedgerMaxAggregateOutputType | null
  }

  type GetLedgerGroupByPayload<T extends LedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerGroupByOutputType[P]>
        }
      >
    >


  export type LedgerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ledgerName?: boolean
    openingBalance?: boolean
    balance?: boolean
    userId?: boolean
    partyId?: boolean
    year?: boolean
    month?: boolean
    ledgerType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    transactions?: boolean | Ledger$transactionsArgs<ExtArgs>
    party?: boolean | PartyArgs<ExtArgs>
    _count?: boolean | LedgerCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["ledger"]>

  export type LedgerSelectScalar = {
    id?: boolean
    ledgerName?: boolean
    openingBalance?: boolean
    balance?: boolean
    userId?: boolean
    partyId?: boolean
    year?: boolean
    month?: boolean
    ledgerType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LedgerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    transactions?: boolean | Ledger$transactionsArgs<ExtArgs>
    party?: boolean | PartyArgs<ExtArgs>
    _count?: boolean | LedgerCountOutputTypeArgs<ExtArgs>
  }


  type LedgerGetPayload<S extends boolean | null | undefined | LedgerArgs> = $Types.GetResult<LedgerPayload, S>

  type LedgerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LedgerFindManyArgs, 'select' | 'include'> & {
      select?: LedgerCountAggregateInputType | true
    }

  export interface LedgerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ledger'], meta: { name: 'Ledger' } }
    /**
     * Find zero or one Ledger that matches the filter.
     * @param {LedgerFindUniqueArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LedgerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LedgerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ledger'> extends True ? Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ledger that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LedgerFindUniqueOrThrowArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LedgerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LedgerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ledger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindFirstArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LedgerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LedgerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ledger'> extends True ? Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ledger that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindFirstOrThrowArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LedgerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LedgerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ledgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ledgers
     * const ledgers = await prisma.ledger.findMany()
     * 
     * // Get first 10 Ledgers
     * const ledgers = await prisma.ledger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerWithIdOnly = await prisma.ledger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LedgerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LedgerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ledger.
     * @param {LedgerCreateArgs} args - Arguments to create a Ledger.
     * @example
     * // Create one Ledger
     * const Ledger = await prisma.ledger.create({
     *   data: {
     *     // ... data to create a Ledger
     *   }
     * })
     * 
    **/
    create<T extends LedgerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LedgerCreateArgs<ExtArgs>>
    ): Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ledgers.
     *     @param {LedgerCreateManyArgs} args - Arguments to create many Ledgers.
     *     @example
     *     // Create many Ledgers
     *     const ledger = await prisma.ledger.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LedgerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LedgerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ledger.
     * @param {LedgerDeleteArgs} args - Arguments to delete one Ledger.
     * @example
     * // Delete one Ledger
     * const Ledger = await prisma.ledger.delete({
     *   where: {
     *     // ... filter to delete one Ledger
     *   }
     * })
     * 
    **/
    delete<T extends LedgerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LedgerDeleteArgs<ExtArgs>>
    ): Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ledger.
     * @param {LedgerUpdateArgs} args - Arguments to update one Ledger.
     * @example
     * // Update one Ledger
     * const ledger = await prisma.ledger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LedgerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LedgerUpdateArgs<ExtArgs>>
    ): Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ledgers.
     * @param {LedgerDeleteManyArgs} args - Arguments to filter Ledgers to delete.
     * @example
     * // Delete a few Ledgers
     * const { count } = await prisma.ledger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LedgerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LedgerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ledgers
     * const ledger = await prisma.ledger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LedgerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LedgerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ledger.
     * @param {LedgerUpsertArgs} args - Arguments to update or create a Ledger.
     * @example
     * // Update or create a Ledger
     * const ledger = await prisma.ledger.upsert({
     *   create: {
     *     // ... data to create a Ledger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ledger we want to update
     *   }
     * })
    **/
    upsert<T extends LedgerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LedgerUpsertArgs<ExtArgs>>
    ): Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerCountArgs} args - Arguments to filter Ledgers to count.
     * @example
     * // Count the number of Ledgers
     * const count = await prisma.ledger.count({
     *   where: {
     *     // ... the filter for the Ledgers we want to count
     *   }
     * })
    **/
    count<T extends LedgerCountArgs>(
      args?: Subset<T, LedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerAggregateArgs>(args: Subset<T, LedgerAggregateArgs>): Prisma.PrismaPromise<GetLedgerAggregateType<T>>

    /**
     * Group by Ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerGroupByArgs['orderBy'] }
        : { orderBy?: LedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Ledger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LedgerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    transactions<T extends Ledger$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Ledger$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    party<T extends PartyArgs<ExtArgs> = {}>(args?: Subset<T, PartyArgs<ExtArgs>>): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Ledger base type for findUnique actions
   */
  export type LedgerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger findUnique
   */
  export interface LedgerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LedgerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ledger findUniqueOrThrow
   */
  export type LedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where: LedgerWhereUniqueInput
  }


  /**
   * Ledger base type for findFirst actions
   */
  export type LedgerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: Enumerable<LedgerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ledgers.
     */
    distinct?: Enumerable<LedgerScalarFieldEnum>
  }

  /**
   * Ledger findFirst
   */
  export interface LedgerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LedgerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ledger findFirstOrThrow
   */
  export type LedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: Enumerable<LedgerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ledgers.
     */
    distinct?: Enumerable<LedgerScalarFieldEnum>
  }


  /**
   * Ledger findMany
   */
  export type LedgerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledgers to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: Enumerable<LedgerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    distinct?: Enumerable<LedgerScalarFieldEnum>
  }


  /**
   * Ledger create
   */
  export type LedgerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a Ledger.
     */
    data: XOR<LedgerCreateInput, LedgerUncheckedCreateInput>
  }


  /**
   * Ledger createMany
   */
  export type LedgerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ledgers.
     */
    data: Enumerable<LedgerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Ledger update
   */
  export type LedgerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a Ledger.
     */
    data: XOR<LedgerUpdateInput, LedgerUncheckedUpdateInput>
    /**
     * Choose, which Ledger to update.
     */
    where: LedgerWhereUniqueInput
  }


  /**
   * Ledger updateMany
   */
  export type LedgerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ledgers.
     */
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyInput>
    /**
     * Filter which Ledgers to update
     */
    where?: LedgerWhereInput
  }


  /**
   * Ledger upsert
   */
  export type LedgerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the Ledger to update in case it exists.
     */
    where: LedgerWhereUniqueInput
    /**
     * In case the Ledger found by the `where` argument doesn't exist, create a new Ledger with this data.
     */
    create: XOR<LedgerCreateInput, LedgerUncheckedCreateInput>
    /**
     * In case the Ledger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerUpdateInput, LedgerUncheckedUpdateInput>
  }


  /**
   * Ledger delete
   */
  export type LedgerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter which Ledger to delete.
     */
    where: LedgerWhereUniqueInput
  }


  /**
   * Ledger deleteMany
   */
  export type LedgerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ledgers to delete
     */
    where?: LedgerWhereInput
  }


  /**
   * Ledger.transactions
   */
  export type Ledger$transactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationAndSearchRelevanceInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Ledger without action
   */
  export type LedgerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
  }



  /**
   * Model JournalEntry
   */


  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryAvgAggregateOutputType = {
    userId: number | null
  }

  export type JournalEntrySumAggregateOutputType = {
    userId: number | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: string | null
    entryDate: Date | null
    description: string | null
    userId: number | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: string | null
    entryDate: Date | null
    description: string | null
    userId: number | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    entryDate: number
    description: number
    userId: number
    _all: number
  }


  export type JournalEntryAvgAggregateInputType = {
    userId?: true
  }

  export type JournalEntrySumAggregateInputType = {
    userId?: true
  }

  export type JournalEntryMinAggregateInputType = {
    id?: true
    entryDate?: true
    description?: true
    userId?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    entryDate?: true
    description?: true
    userId?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    entryDate?: true
    description?: true
    userId?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: Enumerable<JournalEntryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: Enumerable<JournalEntryOrderByWithAggregationInput>
    by: JournalEntryScalarFieldEnum[]
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _avg?: JournalEntryAvgAggregateInputType
    _sum?: JournalEntrySumAggregateInputType
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }


  export type JournalEntryGroupByOutputType = {
    id: string
    entryDate: Date
    description: string
    userId: number
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryDate?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserArgs<ExtArgs>
    transactions?: boolean | JournalEntry$transactionsArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    entryDate?: boolean
    description?: boolean
    userId?: boolean
  }

  export type JournalEntryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    transactions?: boolean | JournalEntry$transactionsArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeArgs<ExtArgs>
  }


  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryArgs> = $Types.GetResult<JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<JournalEntryFindManyArgs, 'select' | 'include'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JournalEntryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'JournalEntry'> extends True ? Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one JournalEntry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JournalEntryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'JournalEntry'> extends True ? Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JournalEntryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
    **/
    create<T extends JournalEntryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>
    ): Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many JournalEntries.
     *     @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     *     @example
     *     // Create many JournalEntries
     *     const journalEntry = await prisma.journalEntry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JournalEntryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
    **/
    delete<T extends JournalEntryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>
    ): Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JournalEntryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>
    ): Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JournalEntryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JournalEntryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
    **/
    upsert<T extends JournalEntryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>
    ): Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    transactions<T extends JournalEntry$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * JournalEntry base type for findUnique actions
   */
  export type JournalEntryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUnique
   */
  export interface JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends JournalEntryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }


  /**
   * JournalEntry base type for findFirst actions
   */
  export type JournalEntryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: Enumerable<JournalEntryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: Enumerable<JournalEntryScalarFieldEnum>
  }

  /**
   * JournalEntry findFirst
   */
  export interface JournalEntryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends JournalEntryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: Enumerable<JournalEntryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: Enumerable<JournalEntryScalarFieldEnum>
  }


  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: Enumerable<JournalEntryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: Enumerable<JournalEntryScalarFieldEnum>
  }


  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }


  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: Enumerable<JournalEntryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }


  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
  }


  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }


  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }


  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
  }


  /**
   * JournalEntry.transactions
   */
  export type JournalEntry$transactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationAndSearchRelevanceInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * JournalEntry without action
   */
  export type JournalEntryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }



  /**
   * Model Transaction
   */


  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    userId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    userId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    ledgerId: string | null
    journalEntryId: string | null
    amount: Decimal | null
    transactionType: TransactionType | null
    userId: number | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    ledgerId: string | null
    journalEntryId: string | null
    amount: Decimal | null
    transactionType: TransactionType | null
    userId: number | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    ledgerId: number
    journalEntryId: number
    amount: number
    transactionType: number
    userId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    userId?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    userId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    ledgerId?: true
    journalEntryId?: true
    amount?: true
    transactionType?: true
    userId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    ledgerId?: true
    journalEntryId?: true
    amount?: true
    transactionType?: true
    userId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    ledgerId?: true
    journalEntryId?: true
    amount?: true
    transactionType?: true
    userId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: Enumerable<TransactionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithAggregationInput>
    by: TransactionScalarFieldEnum[]
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }


  export type TransactionGroupByOutputType = {
    id: string
    ledgerId: string
    journalEntryId: string
    amount: Decimal
    transactionType: TransactionType
    userId: number
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ledgerId?: boolean
    journalEntryId?: boolean
    amount?: boolean
    transactionType?: boolean
    userId?: boolean
    ledger?: boolean | LedgerArgs<ExtArgs>
    journalEntry?: boolean | JournalEntryArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    ledgerId?: boolean
    journalEntryId?: boolean
    amount?: boolean
    transactionType?: boolean
    userId?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    ledger?: boolean | LedgerArgs<ExtArgs>
    journalEntry?: boolean | JournalEntryArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type TransactionGetPayload<S extends boolean | null | undefined | TransactionArgs> = $Types.GetResult<TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transaction'> extends True ? Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transaction'> extends True ? Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Transactions.
     *     @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transaction = await prisma.transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Types.GetResult<TransactionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ledger<T extends LedgerArgs<ExtArgs> = {}>(args?: Subset<T, LedgerArgs<ExtArgs>>): Prisma__LedgerClient<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    journalEntry<T extends JournalEntryArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntryArgs<ExtArgs>>): Prisma__JournalEntryClient<$Types.GetResult<JournalEntryPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Transaction base type for findUnique actions
   */
  export type TransactionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUnique
   */
  export interface TransactionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TransactionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction base type for findFirst actions
   */
  export type TransactionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: Enumerable<TransactionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }

  /**
   * Transaction findFirst
   */
  export interface TransactionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TransactionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: Enumerable<TransactionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: Enumerable<TransactionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: Enumerable<TransactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }


  /**
   * Transaction without action
   */
  export type TransactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
  }



  /**
   * Model Party
   */


  export type AggregateParty = {
    _count: PartyCountAggregateOutputType | null
    _avg: PartyAvgAggregateOutputType | null
    _sum: PartySumAggregateOutputType | null
    _min: PartyMinAggregateOutputType | null
    _max: PartyMaxAggregateOutputType | null
  }

  export type PartyAvgAggregateOutputType = {
    userId: number | null
  }

  export type PartySumAggregateOutputType = {
    userId: number | null
  }

  export type PartyMinAggregateOutputType = {
    id: string | null
    partyName: string | null
    type: PartyType | null
    gstin: string | null
    pan: string | null
    tan: string | null
    upi: string | null
    email: string | null
    phone: string | null
    address: string | null
    bankName: string | null
    bankAccountNumber: string | null
    bankIfsc: string | null
    bankBranch: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartyMaxAggregateOutputType = {
    id: string | null
    partyName: string | null
    type: PartyType | null
    gstin: string | null
    pan: string | null
    tan: string | null
    upi: string | null
    email: string | null
    phone: string | null
    address: string | null
    bankName: string | null
    bankAccountNumber: string | null
    bankIfsc: string | null
    bankBranch: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartyCountAggregateOutputType = {
    id: number
    partyName: number
    type: number
    gstin: number
    pan: number
    tan: number
    upi: number
    email: number
    phone: number
    address: number
    bankName: number
    bankAccountNumber: number
    bankIfsc: number
    bankBranch: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartyAvgAggregateInputType = {
    userId?: true
  }

  export type PartySumAggregateInputType = {
    userId?: true
  }

  export type PartyMinAggregateInputType = {
    id?: true
    partyName?: true
    type?: true
    gstin?: true
    pan?: true
    tan?: true
    upi?: true
    email?: true
    phone?: true
    address?: true
    bankName?: true
    bankAccountNumber?: true
    bankIfsc?: true
    bankBranch?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartyMaxAggregateInputType = {
    id?: true
    partyName?: true
    type?: true
    gstin?: true
    pan?: true
    tan?: true
    upi?: true
    email?: true
    phone?: true
    address?: true
    bankName?: true
    bankAccountNumber?: true
    bankIfsc?: true
    bankBranch?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartyCountAggregateInputType = {
    id?: true
    partyName?: true
    type?: true
    gstin?: true
    pan?: true
    tan?: true
    upi?: true
    email?: true
    phone?: true
    address?: true
    bankName?: true
    bankAccountNumber?: true
    bankIfsc?: true
    bankBranch?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Party to aggregate.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: Enumerable<PartyOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parties
    **/
    _count?: true | PartyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartyMaxAggregateInputType
  }

  export type GetPartyAggregateType<T extends PartyAggregateArgs> = {
        [P in keyof T & keyof AggregateParty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParty[P]>
      : GetScalarType<T[P], AggregateParty[P]>
  }




  export type PartyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PartyWhereInput
    orderBy?: Enumerable<PartyOrderByWithAggregationInput>
    by: PartyScalarFieldEnum[]
    having?: PartyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartyCountAggregateInputType | true
    _avg?: PartyAvgAggregateInputType
    _sum?: PartySumAggregateInputType
    _min?: PartyMinAggregateInputType
    _max?: PartyMaxAggregateInputType
  }


  export type PartyGroupByOutputType = {
    id: string
    partyName: string
    type: PartyType
    gstin: string | null
    pan: string | null
    tan: string | null
    upi: string | null
    email: string | null
    phone: string | null
    address: string | null
    bankName: string | null
    bankAccountNumber: string | null
    bankIfsc: string | null
    bankBranch: string | null
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: PartyCountAggregateOutputType | null
    _avg: PartyAvgAggregateOutputType | null
    _sum: PartySumAggregateOutputType | null
    _min: PartyMinAggregateOutputType | null
    _max: PartyMaxAggregateOutputType | null
  }

  type GetPartyGroupByPayload<T extends PartyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PartyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartyGroupByOutputType[P]>
            : GetScalarType<T[P], PartyGroupByOutputType[P]>
        }
      >
    >


  export type PartySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partyName?: boolean
    type?: boolean
    gstin?: boolean
    pan?: boolean
    tan?: boolean
    upi?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    bankName?: boolean
    bankAccountNumber?: boolean
    bankIfsc?: boolean
    bankBranch?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoices?: boolean | Party$invoicesArgs<ExtArgs>
    items?: boolean | Party$itemsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    ledgers?: boolean | Party$ledgersArgs<ExtArgs>
    _count?: boolean | PartyCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["party"]>

  export type PartySelectScalar = {
    id?: boolean
    partyName?: boolean
    type?: boolean
    gstin?: boolean
    pan?: boolean
    tan?: boolean
    upi?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    bankName?: boolean
    bankAccountNumber?: boolean
    bankIfsc?: boolean
    bankBranch?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoices?: boolean | Party$invoicesArgs<ExtArgs>
    items?: boolean | Party$itemsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    ledgers?: boolean | Party$ledgersArgs<ExtArgs>
    _count?: boolean | PartyCountOutputTypeArgs<ExtArgs>
  }


  type PartyGetPayload<S extends boolean | null | undefined | PartyArgs> = $Types.GetResult<PartyPayload, S>

  type PartyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PartyFindManyArgs, 'select' | 'include'> & {
      select?: PartyCountAggregateInputType | true
    }

  export interface PartyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Party'], meta: { name: 'Party' } }
    /**
     * Find zero or one Party that matches the filter.
     * @param {PartyFindUniqueArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PartyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Party'> extends True ? Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Party that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartyFindUniqueOrThrowArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Party that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindFirstArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PartyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Party'> extends True ? Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Party that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindFirstOrThrowArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Parties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parties
     * const parties = await prisma.party.findMany()
     * 
     * // Get first 10 Parties
     * const parties = await prisma.party.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partyWithIdOnly = await prisma.party.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Party.
     * @param {PartyCreateArgs} args - Arguments to create a Party.
     * @example
     * // Create one Party
     * const Party = await prisma.party.create({
     *   data: {
     *     // ... data to create a Party
     *   }
     * })
     * 
    **/
    create<T extends PartyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartyCreateArgs<ExtArgs>>
    ): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Parties.
     *     @param {PartyCreateManyArgs} args - Arguments to create many Parties.
     *     @example
     *     // Create many Parties
     *     const party = await prisma.party.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Party.
     * @param {PartyDeleteArgs} args - Arguments to delete one Party.
     * @example
     * // Delete one Party
     * const Party = await prisma.party.delete({
     *   where: {
     *     // ... filter to delete one Party
     *   }
     * })
     * 
    **/
    delete<T extends PartyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartyDeleteArgs<ExtArgs>>
    ): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Party.
     * @param {PartyUpdateArgs} args - Arguments to update one Party.
     * @example
     * // Update one Party
     * const party = await prisma.party.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartyUpdateArgs<ExtArgs>>
    ): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Parties.
     * @param {PartyDeleteManyArgs} args - Arguments to filter Parties to delete.
     * @example
     * // Delete a few Parties
     * const { count } = await prisma.party.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parties
     * const party = await prisma.party.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Party.
     * @param {PartyUpsertArgs} args - Arguments to update or create a Party.
     * @example
     * // Update or create a Party
     * const party = await prisma.party.upsert({
     *   create: {
     *     // ... data to create a Party
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Party we want to update
     *   }
     * })
    **/
    upsert<T extends PartyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartyUpsertArgs<ExtArgs>>
    ): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Parties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyCountArgs} args - Arguments to filter Parties to count.
     * @example
     * // Count the number of Parties
     * const count = await prisma.party.count({
     *   where: {
     *     // ... the filter for the Parties we want to count
     *   }
     * })
    **/
    count<T extends PartyCountArgs>(
      args?: Subset<T, PartyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Party.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartyAggregateArgs>(args: Subset<T, PartyAggregateArgs>): Prisma.PrismaPromise<GetPartyAggregateType<T>>

    /**
     * Group by Party.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartyGroupByArgs['orderBy'] }
        : { orderBy?: PartyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Party.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PartyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invoices<T extends Party$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Party$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    items<T extends Party$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Party$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    ledgers<T extends Party$ledgersArgs<ExtArgs> = {}>(args?: Subset<T, Party$ledgersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LedgerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Party base type for findUnique actions
   */
  export type PartyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party findUnique
   */
  export interface PartyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PartyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Party findUniqueOrThrow
   */
  export type PartyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where: PartyWhereUniqueInput
  }


  /**
   * Party base type for findFirst actions
   */
  export type PartyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: Enumerable<PartyOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parties.
     */
    distinct?: Enumerable<PartyScalarFieldEnum>
  }

  /**
   * Party findFirst
   */
  export interface PartyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PartyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Party findFirstOrThrow
   */
  export type PartyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: Enumerable<PartyOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parties.
     */
    distinct?: Enumerable<PartyScalarFieldEnum>
  }


  /**
   * Party findMany
   */
  export type PartyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Parties to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: Enumerable<PartyOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    distinct?: Enumerable<PartyScalarFieldEnum>
  }


  /**
   * Party create
   */
  export type PartyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The data needed to create a Party.
     */
    data: XOR<PartyCreateInput, PartyUncheckedCreateInput>
  }


  /**
   * Party createMany
   */
  export type PartyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parties.
     */
    data: Enumerable<PartyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Party update
   */
  export type PartyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The data needed to update a Party.
     */
    data: XOR<PartyUpdateInput, PartyUncheckedUpdateInput>
    /**
     * Choose, which Party to update.
     */
    where: PartyWhereUniqueInput
  }


  /**
   * Party updateMany
   */
  export type PartyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parties.
     */
    data: XOR<PartyUpdateManyMutationInput, PartyUncheckedUpdateManyInput>
    /**
     * Filter which Parties to update
     */
    where?: PartyWhereInput
  }


  /**
   * Party upsert
   */
  export type PartyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The filter to search for the Party to update in case it exists.
     */
    where: PartyWhereUniqueInput
    /**
     * In case the Party found by the `where` argument doesn't exist, create a new Party with this data.
     */
    create: XOR<PartyCreateInput, PartyUncheckedCreateInput>
    /**
     * In case the Party was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartyUpdateInput, PartyUncheckedUpdateInput>
  }


  /**
   * Party delete
   */
  export type PartyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter which Party to delete.
     */
    where: PartyWhereUniqueInput
  }


  /**
   * Party deleteMany
   */
  export type PartyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parties to delete
     */
    where?: PartyWhereInput
  }


  /**
   * Party.invoices
   */
  export type Party$invoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Party.items
   */
  export type Party$itemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Party.ledgers
   */
  export type Party$ledgersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LedgerInclude<ExtArgs> | null
    where?: LedgerWhereInput
    orderBy?: Enumerable<LedgerOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LedgerScalarFieldEnum>
  }


  /**
   * Party without action
   */
  export type PartyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartyInclude<ExtArgs> | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    userId: number | null
  }

  export type CategorySumAggregateOutputType = {
    userId: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    categoryName: string | null
    userId: number | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    categoryName: string | null
    userId: number | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    categoryName: number
    userId: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    userId?: true
  }

  export type CategorySumAggregateInputType = {
    userId?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    categoryName?: true
    userId?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    categoryName?: true
    userId?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    categoryName?: true
    userId?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: CategoryScalarFieldEnum[]
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: string
    categoryName: string
    userId: number
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryName?: boolean
    userId?: boolean
    user?: boolean | UserArgs<ExtArgs>
    items?: boolean | Category$itemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    categoryName?: boolean
    userId?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    items?: boolean | Category$itemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeArgs<ExtArgs>
  }


  type CategoryGetPayload<S extends boolean | null | undefined | CategoryArgs> = $Types.GetResult<CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    items<T extends Category$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Category$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Category base type for findUnique actions
   */
  export type CategoryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUnique
   */
  export interface CategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CategoryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category base type for findFirst actions
   */
  export type CategoryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * Category findFirst
   */
  export interface CategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CategoryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.items
   */
  export type Category$itemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Category without action
   */
  export type CategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
  }



  /**
   * Model Item
   */


  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    price: Decimal | null
    openingStock: Decimal | null
    closingStock: Decimal | null
    purchasePrice: Decimal | null
    gst: Decimal | null
    userId: number | null
  }

  export type ItemSumAggregateOutputType = {
    price: Decimal | null
    openingStock: Decimal | null
    closingStock: Decimal | null
    purchasePrice: Decimal | null
    gst: Decimal | null
    userId: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    itemName: string | null
    unit: ItemUnit | null
    price: Decimal | null
    openingStock: Decimal | null
    closingStock: Decimal | null
    purchasePrice: Decimal | null
    gst: Decimal | null
    taxExempted: boolean | null
    description: string | null
    hsnCode: string | null
    categoryId: string | null
    supplierId: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    itemName: string | null
    unit: ItemUnit | null
    price: Decimal | null
    openingStock: Decimal | null
    closingStock: Decimal | null
    purchasePrice: Decimal | null
    gst: Decimal | null
    taxExempted: boolean | null
    description: string | null
    hsnCode: string | null
    categoryId: string | null
    supplierId: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    itemName: number
    unit: number
    price: number
    openingStock: number
    closingStock: number
    purchasePrice: number
    gst: number
    taxExempted: number
    description: number
    hsnCode: number
    categoryId: number
    supplierId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    price?: true
    openingStock?: true
    closingStock?: true
    purchasePrice?: true
    gst?: true
    userId?: true
  }

  export type ItemSumAggregateInputType = {
    price?: true
    openingStock?: true
    closingStock?: true
    purchasePrice?: true
    gst?: true
    userId?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    itemName?: true
    unit?: true
    price?: true
    openingStock?: true
    closingStock?: true
    purchasePrice?: true
    gst?: true
    taxExempted?: true
    description?: true
    hsnCode?: true
    categoryId?: true
    supplierId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    itemName?: true
    unit?: true
    price?: true
    openingStock?: true
    closingStock?: true
    purchasePrice?: true
    gst?: true
    taxExempted?: true
    description?: true
    hsnCode?: true
    categoryId?: true
    supplierId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    itemName?: true
    unit?: true
    price?: true
    openingStock?: true
    closingStock?: true
    purchasePrice?: true
    gst?: true
    taxExempted?: true
    description?: true
    hsnCode?: true
    categoryId?: true
    supplierId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: Enumerable<ItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithAggregationInput>
    by: ItemScalarFieldEnum[]
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }


  export type ItemGroupByOutputType = {
    id: string
    itemName: string
    unit: ItemUnit
    price: Decimal
    openingStock: Decimal | null
    closingStock: Decimal | null
    purchasePrice: Decimal | null
    gst: Decimal | null
    taxExempted: boolean
    description: string | null
    hsnCode: string | null
    categoryId: string | null
    supplierId: string | null
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemName?: boolean
    unit?: boolean
    price?: boolean
    openingStock?: boolean
    closingStock?: boolean
    purchasePrice?: boolean
    gst?: boolean
    taxExempted?: boolean
    description?: boolean
    hsnCode?: boolean
    categoryId?: boolean
    supplierId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryArgs<ExtArgs>
    supplier?: boolean | PartyArgs<ExtArgs>
    invoiceItems?: boolean | Item$invoiceItemsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    itemName?: boolean
    unit?: boolean
    price?: boolean
    openingStock?: boolean
    closingStock?: boolean
    purchasePrice?: boolean
    gst?: boolean
    taxExempted?: boolean
    description?: boolean
    hsnCode?: boolean
    categoryId?: boolean
    supplierId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryArgs<ExtArgs>
    supplier?: boolean | PartyArgs<ExtArgs>
    invoiceItems?: boolean | Item$invoiceItemsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeArgs<ExtArgs>
  }


  type ItemGetPayload<S extends boolean | null | undefined | ItemArgs> = $Types.GetResult<ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Item'> extends True ? Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Item'> extends True ? Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCreateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>
    ): Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>
    ): Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends CategoryArgs<ExtArgs> = {}>(args?: Subset<T, CategoryArgs<ExtArgs>>): Prisma__CategoryClient<$Types.GetResult<CategoryPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    supplier<T extends PartyArgs<ExtArgs> = {}>(args?: Subset<T, PartyArgs<ExtArgs>>): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invoiceItems<T extends Item$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Item base type for findUnique actions
   */
  export type ItemFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUnique
   */
  export interface ItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ItemFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item base type for findFirst actions
   */
  export type ItemFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: Enumerable<ItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: Enumerable<ItemScalarFieldEnum>
  }

  /**
   * Item findFirst
   */
  export interface ItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ItemFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: Enumerable<ItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: Enumerable<ItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: Enumerable<ItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }


  /**
   * Item.invoiceItems
   */
  export type Item$invoiceItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: Enumerable<InvoiceItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvoiceItemScalarFieldEnum>
  }


  /**
   * Item without action
   */
  export type ItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
  }



  /**
   * Model Invoice
   */


  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: number | null
    totalGst: number | null
    cgst: number | null
    sgst: number | null
    igst: number | null
    utgst: number | null
    userId: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: number | null
    totalGst: number | null
    cgst: number | null
    sgst: number | null
    igst: number | null
    utgst: number | null
    userId: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    type: InvoiceType | null
    totalAmount: number | null
    totalGst: number | null
    stateOfSupply: string | null
    cgst: number | null
    sgst: number | null
    igst: number | null
    utgst: number | null
    details: string | null
    extraDetails: string | null
    modeOfPayment: ModeOfPayment | null
    credit: boolean | null
    userId: number | null
    partyId: string | null
    gstNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: InvoiceStatus | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    type: InvoiceType | null
    totalAmount: number | null
    totalGst: number | null
    stateOfSupply: string | null
    cgst: number | null
    sgst: number | null
    igst: number | null
    utgst: number | null
    details: string | null
    extraDetails: string | null
    modeOfPayment: ModeOfPayment | null
    credit: boolean | null
    userId: number | null
    partyId: string | null
    gstNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: InvoiceStatus | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    type: number
    totalAmount: number
    totalGst: number
    stateOfSupply: number
    cgst: number
    sgst: number
    igst: number
    utgst: number
    details: number
    extraDetails: number
    modeOfPayment: number
    credit: number
    userId: number
    partyId: number
    gstNumber: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
    totalGst?: true
    cgst?: true
    sgst?: true
    igst?: true
    utgst?: true
    userId?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
    totalGst?: true
    cgst?: true
    sgst?: true
    igst?: true
    utgst?: true
    userId?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    type?: true
    totalAmount?: true
    totalGst?: true
    stateOfSupply?: true
    cgst?: true
    sgst?: true
    igst?: true
    utgst?: true
    details?: true
    extraDetails?: true
    modeOfPayment?: true
    credit?: true
    userId?: true
    partyId?: true
    gstNumber?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    type?: true
    totalAmount?: true
    totalGst?: true
    stateOfSupply?: true
    cgst?: true
    sgst?: true
    igst?: true
    utgst?: true
    details?: true
    extraDetails?: true
    modeOfPayment?: true
    credit?: true
    userId?: true
    partyId?: true
    gstNumber?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    type?: true
    totalAmount?: true
    totalGst?: true
    stateOfSupply?: true
    cgst?: true
    sgst?: true
    igst?: true
    utgst?: true
    details?: true
    extraDetails?: true
    modeOfPayment?: true
    credit?: true
    userId?: true
    partyId?: true
    gstNumber?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithAggregationInput>
    by: InvoiceScalarFieldEnum[]
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }


  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string | null
    type: InvoiceType
    totalAmount: number
    totalGst: number | null
    stateOfSupply: string
    cgst: number | null
    sgst: number | null
    igst: number | null
    utgst: number | null
    details: string | null
    extraDetails: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    userId: number
    partyId: string
    gstNumber: string | null
    createdAt: Date
    updatedAt: Date
    status: InvoiceStatus
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    type?: boolean
    totalAmount?: boolean
    totalGst?: boolean
    stateOfSupply?: boolean
    cgst?: boolean
    sgst?: boolean
    igst?: boolean
    utgst?: boolean
    details?: boolean
    extraDetails?: boolean
    modeOfPayment?: boolean
    credit?: boolean
    userId?: boolean
    partyId?: boolean
    gstNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    user?: boolean | UserArgs<ExtArgs>
    party?: boolean | PartyArgs<ExtArgs>
    invoiceItems?: boolean | Invoice$invoiceItemsArgs<ExtArgs>
    accounts?: boolean | Invoice$accountsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    type?: boolean
    totalAmount?: boolean
    totalGst?: boolean
    stateOfSupply?: boolean
    cgst?: boolean
    sgst?: boolean
    igst?: boolean
    utgst?: boolean
    details?: boolean
    extraDetails?: boolean
    modeOfPayment?: boolean
    credit?: boolean
    userId?: boolean
    partyId?: boolean
    gstNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    party?: boolean | PartyArgs<ExtArgs>
    invoiceItems?: boolean | Invoice$invoiceItemsArgs<ExtArgs>
    accounts?: boolean | Invoice$accountsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeArgs<ExtArgs>
  }


  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceArgs> = $Types.GetResult<InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invoice'> extends True ? Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invoice'> extends True ? Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends InvoiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Invoices.
     *     @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    party<T extends PartyArgs<ExtArgs> = {}>(args?: Subset<T, PartyArgs<ExtArgs>>): Prisma__PartyClient<$Types.GetResult<PartyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invoiceItems<T extends Invoice$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    accounts<T extends Invoice$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Invoice base type for findUnique actions
   */
  export type InvoiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUnique
   */
  export interface InvoiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice base type for findFirst actions
   */
  export type InvoiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }

  /**
   * Invoice findFirst
   */
  export interface InvoiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }


  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: Enumerable<InvoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }


  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice.invoiceItems
   */
  export type Invoice$invoiceItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: Enumerable<InvoiceItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvoiceItemScalarFieldEnum>
  }


  /**
   * Invoice.accounts
   */
  export type Invoice$accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Invoice without action
   */
  export type InvoiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
  }



  /**
   * Model InvoiceItem
   */


  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    discount: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    discount: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    quantity: number | null
    discount: Decimal | null
    invoiceId: string | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    quantity: number | null
    discount: Decimal | null
    invoiceId: string | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    itemId: number
    quantity: number
    discount: number
    invoiceId: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    discount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    discount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    itemId?: true
    quantity?: true
    discount?: true
    invoiceId?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    itemId?: true
    quantity?: true
    discount?: true
    invoiceId?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    itemId?: true
    quantity?: true
    discount?: true
    invoiceId?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: Enumerable<InvoiceItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: Enumerable<InvoiceItemOrderByWithAggregationInput>
    by: InvoiceItemScalarFieldEnum[]
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }


  export type InvoiceItemGroupByOutputType = {
    id: string
    itemId: string
    quantity: number
    discount: Decimal
    invoiceId: string
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    quantity?: boolean
    discount?: boolean
    invoiceId?: boolean
    item?: boolean | ItemArgs<ExtArgs>
    invoice?: boolean | InvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    itemId?: boolean
    quantity?: boolean
    discount?: boolean
    invoiceId?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    item?: boolean | ItemArgs<ExtArgs>
    invoice?: boolean | InvoiceArgs<ExtArgs>
  }


  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemArgs> = $Types.GetResult<InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceItemFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InvoiceItem'> extends True ? Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceItemFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InvoiceItem'> extends True ? Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
    **/
    create<T extends InvoiceItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     *     @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     *     @example
     *     // Create many InvoiceItems
     *     const invoiceItem = await prisma.invoiceItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<$Types.GetResult<InvoiceItemPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    item<T extends ItemArgs<ExtArgs> = {}>(args?: Subset<T, ItemArgs<ExtArgs>>): Prisma__ItemClient<$Types.GetResult<ItemPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InvoiceItem base type for findUnique actions
   */
  export type InvoiceItemFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUnique
   */
  export interface InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceItemFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }


  /**
   * InvoiceItem base type for findFirst actions
   */
  export type InvoiceItemFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: Enumerable<InvoiceItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: Enumerable<InvoiceItemScalarFieldEnum>
  }

  /**
   * InvoiceItem findFirst
   */
  export interface InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceItemFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: Enumerable<InvoiceItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: Enumerable<InvoiceItemScalarFieldEnum>
  }


  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: Enumerable<InvoiceItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: Enumerable<InvoiceItemScalarFieldEnum>
  }


  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }


  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: Enumerable<InvoiceItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }


  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }


  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }


  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }


  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }


  /**
   * InvoiceItem without action
   */
  export type InvoiceItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }



  /**
   * Model Service
   */


  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: Decimal | null
    gst: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    price: Decimal | null
    gst: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    serviceName: string | null
    serviceType: string | null
    imgUrl: string | null
    description: string | null
    price: Decimal | null
    gst: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    serviceName: string | null
    serviceType: string | null
    imgUrl: string | null
    description: string | null
    price: Decimal | null
    gst: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    serviceName: number
    serviceType: number
    imgUrl: number
    description: number
    price: number
    gst: number
    documents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
    gst?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
    gst?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    serviceName?: true
    serviceType?: true
    imgUrl?: true
    description?: true
    price?: true
    gst?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    serviceName?: true
    serviceType?: true
    imgUrl?: true
    description?: true
    price?: true
    gst?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    serviceName?: true
    serviceType?: true
    imgUrl?: true
    description?: true
    price?: true
    gst?: true
    documents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithAggregationInput>
    by: ServiceScalarFieldEnum[]
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }


  export type ServiceGroupByOutputType = {
    id: string
    serviceName: string
    serviceType: string | null
    imgUrl: string | null
    description: string | null
    price: Decimal
    gst: Decimal
    documents: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceName?: boolean
    serviceType?: boolean
    imgUrl?: boolean
    description?: boolean
    price?: boolean
    gst?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    serviceName?: boolean
    serviceType?: boolean
    imgUrl?: boolean
    description?: boolean
    price?: boolean
    gst?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceArgs> = $Types.GetResult<ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Service base type for findUnique actions
   */
  export type ServiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUnique
   */
  export interface ServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service base type for findFirst actions
   */
  export type ServiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }

  /**
   * Service findFirst
   */
  export interface ServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: Enumerable<ServiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }


  /**
   * Service without action
   */
  export type ServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    gst: Decimal | null
    orderTotal: Decimal | null
    userId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    gst: Decimal | null
    orderTotal: Decimal | null
    userId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    status: OrderStatus | null
    price: Decimal | null
    gst: Decimal | null
    orderTotal: Decimal | null
    stateOfSupply: string | null
    userId: number | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    status: OrderStatus | null
    price: Decimal | null
    gst: Decimal | null
    orderTotal: Decimal | null
    stateOfSupply: string | null
    userId: number | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    services: number
    status: number
    price: number
    gst: number
    orderTotal: number
    stateOfSupply: number
    userId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    price?: true
    gst?: true
    orderTotal?: true
    userId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    price?: true
    gst?: true
    orderTotal?: true
    userId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    status?: true
    price?: true
    gst?: true
    orderTotal?: true
    stateOfSupply?: true
    userId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    status?: true
    price?: true
    gst?: true
    orderTotal?: true
    stateOfSupply?: true
    userId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    services?: true
    status?: true
    price?: true
    gst?: true
    orderTotal?: true
    stateOfSupply?: true
    userId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: OrderScalarFieldEnum[]
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    services: JsonValue
    status: OrderStatus
    price: Decimal
    gst: Decimal
    orderTotal: Decimal
    stateOfSupply: string
    userId: number
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    services?: boolean
    status?: boolean
    price?: boolean
    gst?: boolean
    orderTotal?: boolean
    stateOfSupply?: boolean
    userId?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    services?: boolean
    status?: boolean
    price?: boolean
    gst?: boolean
    orderTotal?: boolean
    stateOfSupply?: boolean
    userId?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type OrderGetPayload<S extends boolean | null | undefined | OrderArgs> = $Types.GetResult<OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUnique
   */
  export interface OrderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OrderFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order findFirst
   */
  export interface OrderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OrderFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }


  /**
   * Order without action
   */
  export type OrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    userId: number | null
    orderId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    userId: number | null
    orderId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    razorpay_order_id: string | null
    razorpay_payment_id: string | null
    status: PaymentStatus | null
    userId: number | null
    orderId: number | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    razorpay_order_id: string | null
    razorpay_payment_id: string | null
    status: PaymentStatus | null
    userId: number | null
    orderId: number | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    razorpay_order_id: number
    razorpay_payment_id: number
    status: number
    userId: number
    orderId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    userId?: true
    orderId?: true
  }

  export type PaymentSumAggregateInputType = {
    userId?: true
    orderId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    razorpay_order_id?: true
    razorpay_payment_id?: true
    status?: true
    userId?: true
    orderId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    razorpay_order_id?: true
    razorpay_payment_id?: true
    status?: true
    userId?: true
    orderId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    razorpay_order_id?: true
    razorpay_payment_id?: true
    status?: true
    userId?: true
    orderId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithAggregationInput>
    by: PaymentScalarFieldEnum[]
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    razorpay_order_id: string
    razorpay_payment_id: string
    status: PaymentStatus
    userId: number
    orderId: number
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpay_order_id?: boolean
    razorpay_payment_id?: boolean
    status?: boolean
    userId?: boolean
    orderId?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    razorpay_order_id?: boolean
    razorpay_payment_id?: boolean
    status?: boolean
    userId?: boolean
    orderId?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentArgs> = $Types.GetResult<PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payment'> extends True ? Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payment'> extends True ? Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Payment base type for findUnique actions
   */
  export type PaymentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUnique
   */
  export interface PaymentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment base type for findFirst actions
   */
  export type PaymentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * Payment findFirst
   */
  export interface PaymentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: Enumerable<PaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
  }



  /**
   * Model Library
   */


  export type AggregateLibrary = {
    _count: LibraryCountAggregateOutputType | null
    _avg: LibraryAvgAggregateOutputType | null
    _sum: LibrarySumAggregateOutputType | null
    _min: LibraryMinAggregateOutputType | null
    _max: LibraryMaxAggregateOutputType | null
  }

  export type LibraryAvgAggregateOutputType = {
    id: number | null
  }

  export type LibrarySumAggregateOutputType = {
    id: number | null
  }

  export type LibraryMinAggregateOutputType = {
    id: number | null
    pan: string | null
    section: string | null
    sub_section: string | null
    subject: string | null
    ao_order: string | null
    itat_no: string | null
    rsa_no: string | null
    bench: string | null
    appeal_no: string | null
    appellant: string | null
    respondent: string | null
    appeal_type: string | null
    appeal_filed_by: string | null
    order_result: string | null
    tribunal_order_date: string | null
    assessment_year: string | null
    judgment: string | null
    conclusion: string | null
    download: string | null
    upload: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryMaxAggregateOutputType = {
    id: number | null
    pan: string | null
    section: string | null
    sub_section: string | null
    subject: string | null
    ao_order: string | null
    itat_no: string | null
    rsa_no: string | null
    bench: string | null
    appeal_no: string | null
    appellant: string | null
    respondent: string | null
    appeal_type: string | null
    appeal_filed_by: string | null
    order_result: string | null
    tribunal_order_date: string | null
    assessment_year: string | null
    judgment: string | null
    conclusion: string | null
    download: string | null
    upload: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryCountAggregateOutputType = {
    id: number
    pan: number
    section: number
    sub_section: number
    subject: number
    ao_order: number
    itat_no: number
    rsa_no: number
    bench: number
    appeal_no: number
    appellant: number
    respondent: number
    appeal_type: number
    appeal_filed_by: number
    order_result: number
    tribunal_order_date: number
    assessment_year: number
    judgment: number
    conclusion: number
    download: number
    upload: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryAvgAggregateInputType = {
    id?: true
  }

  export type LibrarySumAggregateInputType = {
    id?: true
  }

  export type LibraryMinAggregateInputType = {
    id?: true
    pan?: true
    section?: true
    sub_section?: true
    subject?: true
    ao_order?: true
    itat_no?: true
    rsa_no?: true
    bench?: true
    appeal_no?: true
    appellant?: true
    respondent?: true
    appeal_type?: true
    appeal_filed_by?: true
    order_result?: true
    tribunal_order_date?: true
    assessment_year?: true
    judgment?: true
    conclusion?: true
    download?: true
    upload?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryMaxAggregateInputType = {
    id?: true
    pan?: true
    section?: true
    sub_section?: true
    subject?: true
    ao_order?: true
    itat_no?: true
    rsa_no?: true
    bench?: true
    appeal_no?: true
    appellant?: true
    respondent?: true
    appeal_type?: true
    appeal_filed_by?: true
    order_result?: true
    tribunal_order_date?: true
    assessment_year?: true
    judgment?: true
    conclusion?: true
    download?: true
    upload?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryCountAggregateInputType = {
    id?: true
    pan?: true
    section?: true
    sub_section?: true
    subject?: true
    ao_order?: true
    itat_no?: true
    rsa_no?: true
    bench?: true
    appeal_no?: true
    appellant?: true
    respondent?: true
    appeal_type?: true
    appeal_filed_by?: true
    order_result?: true
    tribunal_order_date?: true
    assessment_year?: true
    judgment?: true
    conclusion?: true
    download?: true
    upload?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Library to aggregate.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: Enumerable<LibraryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Libraries
    **/
    _count?: true | LibraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibrarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryMaxAggregateInputType
  }

  export type GetLibraryAggregateType<T extends LibraryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibrary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibrary[P]>
      : GetScalarType<T[P], AggregateLibrary[P]>
  }




  export type LibraryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LibraryWhereInput
    orderBy?: Enumerable<LibraryOrderByWithAggregationInput>
    by: LibraryScalarFieldEnum[]
    having?: LibraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryCountAggregateInputType | true
    _avg?: LibraryAvgAggregateInputType
    _sum?: LibrarySumAggregateInputType
    _min?: LibraryMinAggregateInputType
    _max?: LibraryMaxAggregateInputType
  }


  export type LibraryGroupByOutputType = {
    id: number
    pan: string
    section: string
    sub_section: string | null
    subject: string
    ao_order: string
    itat_no: string
    rsa_no: string | null
    bench: string
    appeal_no: string | null
    appellant: string | null
    respondent: string
    appeal_type: string
    appeal_filed_by: string
    order_result: string
    tribunal_order_date: string
    assessment_year: string
    judgment: string
    conclusion: string
    download: string
    upload: string | null
    createdAt: Date
    updatedAt: Date
    _count: LibraryCountAggregateOutputType | null
    _avg: LibraryAvgAggregateOutputType | null
    _sum: LibrarySumAggregateOutputType | null
    _min: LibraryMinAggregateOutputType | null
    _max: LibraryMaxAggregateOutputType | null
  }

  type GetLibraryGroupByPayload<T extends LibraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryGroupByOutputType[P]>
        }
      >
    >


  export type LibrarySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pan?: boolean
    section?: boolean
    sub_section?: boolean
    subject?: boolean
    ao_order?: boolean
    itat_no?: boolean
    rsa_no?: boolean
    bench?: boolean
    appeal_no?: boolean
    appellant?: boolean
    respondent?: boolean
    appeal_type?: boolean
    appeal_filed_by?: boolean
    order_result?: boolean
    tribunal_order_date?: boolean
    assessment_year?: boolean
    judgment?: boolean
    conclusion?: boolean
    download?: boolean
    upload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["library"]>

  export type LibrarySelectScalar = {
    id?: boolean
    pan?: boolean
    section?: boolean
    sub_section?: boolean
    subject?: boolean
    ao_order?: boolean
    itat_no?: boolean
    rsa_no?: boolean
    bench?: boolean
    appeal_no?: boolean
    appellant?: boolean
    respondent?: boolean
    appeal_type?: boolean
    appeal_filed_by?: boolean
    order_result?: boolean
    tribunal_order_date?: boolean
    assessment_year?: boolean
    judgment?: boolean
    conclusion?: boolean
    download?: boolean
    upload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type LibraryGetPayload<S extends boolean | null | undefined | LibraryArgs> = $Types.GetResult<LibraryPayload, S>

  type LibraryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LibraryFindManyArgs, 'select' | 'include'> & {
      select?: LibraryCountAggregateInputType | true
    }

  export interface LibraryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Library'], meta: { name: 'Library' } }
    /**
     * Find zero or one Library that matches the filter.
     * @param {LibraryFindUniqueArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Library'> extends True ? Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Library that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryFindUniqueOrThrowArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Library that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindFirstArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Library'> extends True ? Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Library that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindFirstOrThrowArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Libraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Libraries
     * const libraries = await prisma.library.findMany()
     * 
     * // Get first 10 Libraries
     * const libraries = await prisma.library.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryWithIdOnly = await prisma.library.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Library.
     * @param {LibraryCreateArgs} args - Arguments to create a Library.
     * @example
     * // Create one Library
     * const Library = await prisma.library.create({
     *   data: {
     *     // ... data to create a Library
     *   }
     * })
     * 
    **/
    create<T extends LibraryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryCreateArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Libraries.
     *     @param {LibraryCreateManyArgs} args - Arguments to create many Libraries.
     *     @example
     *     // Create many Libraries
     *     const library = await prisma.library.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Library.
     * @param {LibraryDeleteArgs} args - Arguments to delete one Library.
     * @example
     * // Delete one Library
     * const Library = await prisma.library.delete({
     *   where: {
     *     // ... filter to delete one Library
     *   }
     * })
     * 
    **/
    delete<T extends LibraryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryDeleteArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Library.
     * @param {LibraryUpdateArgs} args - Arguments to update one Library.
     * @example
     * // Update one Library
     * const library = await prisma.library.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryUpdateArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Libraries.
     * @param {LibraryDeleteManyArgs} args - Arguments to filter Libraries to delete.
     * @example
     * // Delete a few Libraries
     * const { count } = await prisma.library.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Libraries
     * const library = await prisma.library.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Library.
     * @param {LibraryUpsertArgs} args - Arguments to update or create a Library.
     * @example
     * // Update or create a Library
     * const library = await prisma.library.upsert({
     *   create: {
     *     // ... data to create a Library
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Library we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryUpsertArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCountArgs} args - Arguments to filter Libraries to count.
     * @example
     * // Count the number of Libraries
     * const count = await prisma.library.count({
     *   where: {
     *     // ... the filter for the Libraries we want to count
     *   }
     * })
    **/
    count<T extends LibraryCountArgs>(
      args?: Subset<T, LibraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryAggregateArgs>(args: Subset<T, LibraryAggregateArgs>): Prisma.PrismaPromise<GetLibraryAggregateType<T>>

    /**
     * Group by Library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Library.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Library base type for findUnique actions
   */
  export type LibraryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where: LibraryWhereUniqueInput
  }

  /**
   * Library findUnique
   */
  export interface LibraryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LibraryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Library findUniqueOrThrow
   */
  export type LibraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library base type for findFirst actions
   */
  export type LibraryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: Enumerable<LibraryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Libraries.
     */
    distinct?: Enumerable<LibraryScalarFieldEnum>
  }

  /**
   * Library findFirst
   */
  export interface LibraryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LibraryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Library findFirstOrThrow
   */
  export type LibraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: Enumerable<LibraryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Libraries.
     */
    distinct?: Enumerable<LibraryScalarFieldEnum>
  }


  /**
   * Library findMany
   */
  export type LibraryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Filter, which Libraries to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: Enumerable<LibraryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    distinct?: Enumerable<LibraryScalarFieldEnum>
  }


  /**
   * Library create
   */
  export type LibraryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * The data needed to create a Library.
     */
    data: XOR<LibraryCreateInput, LibraryUncheckedCreateInput>
  }


  /**
   * Library createMany
   */
  export type LibraryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Libraries.
     */
    data: Enumerable<LibraryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Library update
   */
  export type LibraryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * The data needed to update a Library.
     */
    data: XOR<LibraryUpdateInput, LibraryUncheckedUpdateInput>
    /**
     * Choose, which Library to update.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library updateMany
   */
  export type LibraryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Libraries.
     */
    data: XOR<LibraryUpdateManyMutationInput, LibraryUncheckedUpdateManyInput>
    /**
     * Filter which Libraries to update
     */
    where?: LibraryWhereInput
  }


  /**
   * Library upsert
   */
  export type LibraryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * The filter to search for the Library to update in case it exists.
     */
    where: LibraryWhereUniqueInput
    /**
     * In case the Library found by the `where` argument doesn't exist, create a new Library with this data.
     */
    create: XOR<LibraryCreateInput, LibraryUncheckedCreateInput>
    /**
     * In case the Library was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryUpdateInput, LibraryUncheckedUpdateInput>
  }


  /**
   * Library delete
   */
  export type LibraryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Filter which Library to delete.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library deleteMany
   */
  export type LibraryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Libraries to delete
     */
    where?: LibraryWhereInput
  }


  /**
   * Library without action
   */
  export type LibraryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    userId: number | null
  }

  export type PostSumAggregateOutputType = {
    userId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    userId: number | null
    title: string | null
    contentheading: string | null
    contentdiscription: string | null
    category: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    title: string | null
    contentheading: string | null
    contentdiscription: string | null
    category: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    contentheading: number
    contentdiscription: number
    category: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    userId?: true
  }

  export type PostSumAggregateInputType = {
    userId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    contentheading?: true
    contentdiscription?: true
    category?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    contentheading?: true
    contentdiscription?: true
    category?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    contentheading?: true
    contentdiscription?: true
    category?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: PostScalarFieldEnum[]
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: string
    userId: number
    title: string
    contentheading: string
    contentdiscription: string
    category: string
    imageUrl: string
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    contentheading?: boolean
    contentdiscription?: boolean
    category?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    contentheading?: boolean
    contentdiscription?: boolean
    category?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type PostGetPayload<S extends boolean | null | undefined | PostArgs> = $Types.GetResult<PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PostPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PostCreateArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PostDeleteArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpsertArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Post base type for findUnique actions
   */
  export type PostFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUnique
   */
  export interface PostFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PostFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post base type for findFirst actions
   */
  export type PostFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }

  /**
   * Post findFirst
   */
  export interface PostFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PostFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post without action
   */
  export type PostArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
  }



  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    totalDebit: Decimal | null
    totalCredit: Decimal | null
    debitBalance: Decimal | null
    creditBalance: Decimal | null
    userId: number | null
  }

  export type AccountSumAggregateOutputType = {
    totalDebit: Decimal | null
    totalCredit: Decimal | null
    debitBalance: Decimal | null
    creditBalance: Decimal | null
    userId: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountName: string | null
    totalDebit: Decimal | null
    totalCredit: Decimal | null
    debitBalance: Decimal | null
    creditBalance: Decimal | null
    date: Date | null
    userId: number | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountName: string | null
    totalDebit: Decimal | null
    totalCredit: Decimal | null
    debitBalance: Decimal | null
    creditBalance: Decimal | null
    date: Date | null
    userId: number | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountName: number
    totalDebit: number
    totalCredit: number
    debitBalance: number
    creditBalance: number
    date: number
    userId: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    totalDebit?: true
    totalCredit?: true
    debitBalance?: true
    creditBalance?: true
    userId?: true
  }

  export type AccountSumAggregateInputType = {
    totalDebit?: true
    totalCredit?: true
    debitBalance?: true
    creditBalance?: true
    userId?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    accountName?: true
    totalDebit?: true
    totalCredit?: true
    debitBalance?: true
    creditBalance?: true
    date?: true
    userId?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountName?: true
    totalDebit?: true
    totalCredit?: true
    debitBalance?: true
    creditBalance?: true
    date?: true
    userId?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountName?: true
    totalDebit?: true
    totalCredit?: true
    debitBalance?: true
    creditBalance?: true
    date?: true
    userId?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: AccountScalarFieldEnum[]
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    accountName: string
    totalDebit: Decimal
    totalCredit: Decimal
    debitBalance: Decimal
    creditBalance: Decimal
    date: Date
    userId: number
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountName?: boolean
    totalDebit?: boolean
    totalCredit?: boolean
    debitBalance?: boolean
    creditBalance?: boolean
    date?: boolean
    userId?: boolean
    user?: boolean | UserArgs<ExtArgs>
    invoices?: boolean | Account$invoicesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountName?: boolean
    totalDebit?: boolean
    totalCredit?: boolean
    debitBalance?: boolean
    creditBalance?: boolean
    date?: boolean
    userId?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    invoices?: boolean | Account$invoicesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeArgs<ExtArgs>
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountArgs> = $Types.GetResult<AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invoices<T extends Account$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Account$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUnique
   */
  export interface AccountFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account findFirst
   */
  export interface AccountFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account.invoices
   */
  export type Account$invoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Account without action
   */
  export type AccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model Career
   */


  export type AggregateCareer = {
    _count: CareerCountAggregateOutputType | null
    _avg: CareerAvgAggregateOutputType | null
    _sum: CareerSumAggregateOutputType | null
    _min: CareerMinAggregateOutputType | null
    _max: CareerMaxAggregateOutputType | null
  }

  export type CareerAvgAggregateOutputType = {
    id: number | null
  }

  export type CareerSumAggregateOutputType = {
    id: number | null
  }

  export type CareerMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    pin: string | null
    email: string | null
    mobile: string | null
    skills: string | null
    gender: UserGender | null
    cv: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    pin: string | null
    email: string | null
    mobile: string | null
    skills: string | null
    gender: UserGender | null
    cv: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareerCountAggregateOutputType = {
    id: number
    name: number
    address: number
    pin: number
    email: number
    mobile: number
    skills: number
    gender: number
    cv: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CareerAvgAggregateInputType = {
    id?: true
  }

  export type CareerSumAggregateInputType = {
    id?: true
  }

  export type CareerMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    pin?: true
    email?: true
    mobile?: true
    skills?: true
    gender?: true
    cv?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareerMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    pin?: true
    email?: true
    mobile?: true
    skills?: true
    gender?: true
    cv?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareerCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    pin?: true
    email?: true
    mobile?: true
    skills?: true
    gender?: true
    cv?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CareerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Career to aggregate.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: Enumerable<CareerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Careers
    **/
    _count?: true | CareerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerMaxAggregateInputType
  }

  export type GetCareerAggregateType<T extends CareerAggregateArgs> = {
        [P in keyof T & keyof AggregateCareer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareer[P]>
      : GetScalarType<T[P], AggregateCareer[P]>
  }




  export type CareerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CareerWhereInput
    orderBy?: Enumerable<CareerOrderByWithAggregationInput>
    by: CareerScalarFieldEnum[]
    having?: CareerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerCountAggregateInputType | true
    _avg?: CareerAvgAggregateInputType
    _sum?: CareerSumAggregateInputType
    _min?: CareerMinAggregateInputType
    _max?: CareerMaxAggregateInputType
  }


  export type CareerGroupByOutputType = {
    id: number
    name: string
    address: string
    pin: string
    email: string
    mobile: string
    skills: string
    gender: UserGender
    cv: string
    createdAt: Date
    updatedAt: Date
    _count: CareerCountAggregateOutputType | null
    _avg: CareerAvgAggregateOutputType | null
    _sum: CareerSumAggregateOutputType | null
    _min: CareerMinAggregateOutputType | null
    _max: CareerMaxAggregateOutputType | null
  }

  type GetCareerGroupByPayload<T extends CareerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CareerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerGroupByOutputType[P]>
            : GetScalarType<T[P], CareerGroupByOutputType[P]>
        }
      >
    >


  export type CareerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    pin?: boolean
    email?: boolean
    mobile?: boolean
    skills?: boolean
    gender?: boolean
    cv?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["career"]>

  export type CareerSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    pin?: boolean
    email?: boolean
    mobile?: boolean
    skills?: boolean
    gender?: boolean
    cv?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type CareerGetPayload<S extends boolean | null | undefined | CareerArgs> = $Types.GetResult<CareerPayload, S>

  type CareerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CareerFindManyArgs, 'select' | 'include'> & {
      select?: CareerCountAggregateInputType | true
    }

  export interface CareerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Career'], meta: { name: 'Career' } }
    /**
     * Find zero or one Career that matches the filter.
     * @param {CareerFindUniqueArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CareerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CareerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Career'> extends True ? Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Career that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CareerFindUniqueOrThrowArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CareerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Career that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindFirstArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CareerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CareerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Career'> extends True ? Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Career that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindFirstOrThrowArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CareerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Careers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Careers
     * const careers = await prisma.career.findMany()
     * 
     * // Get first 10 Careers
     * const careers = await prisma.career.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerWithIdOnly = await prisma.career.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CareerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CareerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Career.
     * @param {CareerCreateArgs} args - Arguments to create a Career.
     * @example
     * // Create one Career
     * const Career = await prisma.career.create({
     *   data: {
     *     // ... data to create a Career
     *   }
     * })
     * 
    **/
    create<T extends CareerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CareerCreateArgs<ExtArgs>>
    ): Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Careers.
     *     @param {CareerCreateManyArgs} args - Arguments to create many Careers.
     *     @example
     *     // Create many Careers
     *     const career = await prisma.career.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CareerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Career.
     * @param {CareerDeleteArgs} args - Arguments to delete one Career.
     * @example
     * // Delete one Career
     * const Career = await prisma.career.delete({
     *   where: {
     *     // ... filter to delete one Career
     *   }
     * })
     * 
    **/
    delete<T extends CareerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CareerDeleteArgs<ExtArgs>>
    ): Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Career.
     * @param {CareerUpdateArgs} args - Arguments to update one Career.
     * @example
     * // Update one Career
     * const career = await prisma.career.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CareerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CareerUpdateArgs<ExtArgs>>
    ): Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Careers.
     * @param {CareerDeleteManyArgs} args - Arguments to filter Careers to delete.
     * @example
     * // Delete a few Careers
     * const { count } = await prisma.career.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CareerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Careers
     * const career = await prisma.career.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CareerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CareerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Career.
     * @param {CareerUpsertArgs} args - Arguments to update or create a Career.
     * @example
     * // Update or create a Career
     * const career = await prisma.career.upsert({
     *   create: {
     *     // ... data to create a Career
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Career we want to update
     *   }
     * })
    **/
    upsert<T extends CareerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CareerUpsertArgs<ExtArgs>>
    ): Prisma__CareerClient<$Types.GetResult<CareerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerCountArgs} args - Arguments to filter Careers to count.
     * @example
     * // Count the number of Careers
     * const count = await prisma.career.count({
     *   where: {
     *     // ... the filter for the Careers we want to count
     *   }
     * })
    **/
    count<T extends CareerCountArgs>(
      args?: Subset<T, CareerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Career.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerAggregateArgs>(args: Subset<T, CareerAggregateArgs>): Prisma.PrismaPromise<GetCareerAggregateType<T>>

    /**
     * Group by Career.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerGroupByArgs['orderBy'] }
        : { orderBy?: CareerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Career.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CareerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Career base type for findUnique actions
   */
  export type CareerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career findUnique
   */
  export interface CareerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CareerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Career findUniqueOrThrow
   */
  export type CareerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where: CareerWhereUniqueInput
  }


  /**
   * Career base type for findFirst actions
   */
  export type CareerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: Enumerable<CareerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     */
    distinct?: Enumerable<CareerScalarFieldEnum>
  }

  /**
   * Career findFirst
   */
  export interface CareerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CareerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Career findFirstOrThrow
   */
  export type CareerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: Enumerable<CareerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     */
    distinct?: Enumerable<CareerScalarFieldEnum>
  }


  /**
   * Career findMany
   */
  export type CareerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Filter, which Careers to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: Enumerable<CareerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    distinct?: Enumerable<CareerScalarFieldEnum>
  }


  /**
   * Career create
   */
  export type CareerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * The data needed to create a Career.
     */
    data: XOR<CareerCreateInput, CareerUncheckedCreateInput>
  }


  /**
   * Career createMany
   */
  export type CareerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Careers.
     */
    data: Enumerable<CareerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Career update
   */
  export type CareerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * The data needed to update a Career.
     */
    data: XOR<CareerUpdateInput, CareerUncheckedUpdateInput>
    /**
     * Choose, which Career to update.
     */
    where: CareerWhereUniqueInput
  }


  /**
   * Career updateMany
   */
  export type CareerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Careers.
     */
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyInput>
    /**
     * Filter which Careers to update
     */
    where?: CareerWhereInput
  }


  /**
   * Career upsert
   */
  export type CareerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * The filter to search for the Career to update in case it exists.
     */
    where: CareerWhereUniqueInput
    /**
     * In case the Career found by the `where` argument doesn't exist, create a new Career with this data.
     */
    create: XOR<CareerCreateInput, CareerUncheckedCreateInput>
    /**
     * In case the Career was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerUpdateInput, CareerUncheckedUpdateInput>
  }


  /**
   * Career delete
   */
  export type CareerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Filter which Career to delete.
     */
    where: CareerWhereUniqueInput
  }


  /**
   * Career deleteMany
   */
  export type CareerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Careers to delete
     */
    where?: CareerWhereInput
  }


  /**
   * Career without action
   */
  export type CareerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
  }



  /**
   * Model Billrecieve
   */


  export type AggregateBillrecieve = {
    _count: BillrecieveCountAggregateOutputType | null
    _avg: BillrecieveAvgAggregateOutputType | null
    _sum: BillrecieveSumAggregateOutputType | null
    _min: BillrecieveMinAggregateOutputType | null
    _max: BillrecieveMaxAggregateOutputType | null
  }

  export type BillrecieveAvgAggregateOutputType = {
    id: number | null
  }

  export type BillrecieveSumAggregateOutputType = {
    id: number | null
  }

  export type BillrecieveMinAggregateOutputType = {
    id: number | null
    billNumber: string | null
    amount: string | null
    tax: string | null
    customerName: string | null
    customerAddress: string | null
    contact: string | null
    itemQuantity: string | null
    itemPrice: string | null
    itemDescription: string | null
    paymentStatus: paymentStatus | null
    paymentMethod: paymentMethod | null
    dueDate: string | null
    comment: string | null
  }

  export type BillrecieveMaxAggregateOutputType = {
    id: number | null
    billNumber: string | null
    amount: string | null
    tax: string | null
    customerName: string | null
    customerAddress: string | null
    contact: string | null
    itemQuantity: string | null
    itemPrice: string | null
    itemDescription: string | null
    paymentStatus: paymentStatus | null
    paymentMethod: paymentMethod | null
    dueDate: string | null
    comment: string | null
  }

  export type BillrecieveCountAggregateOutputType = {
    id: number
    billNumber: number
    amount: number
    tax: number
    customerName: number
    customerAddress: number
    contact: number
    itemQuantity: number
    itemPrice: number
    itemDescription: number
    paymentStatus: number
    paymentMethod: number
    dueDate: number
    comment: number
    _all: number
  }


  export type BillrecieveAvgAggregateInputType = {
    id?: true
  }

  export type BillrecieveSumAggregateInputType = {
    id?: true
  }

  export type BillrecieveMinAggregateInputType = {
    id?: true
    billNumber?: true
    amount?: true
    tax?: true
    customerName?: true
    customerAddress?: true
    contact?: true
    itemQuantity?: true
    itemPrice?: true
    itemDescription?: true
    paymentStatus?: true
    paymentMethod?: true
    dueDate?: true
    comment?: true
  }

  export type BillrecieveMaxAggregateInputType = {
    id?: true
    billNumber?: true
    amount?: true
    tax?: true
    customerName?: true
    customerAddress?: true
    contact?: true
    itemQuantity?: true
    itemPrice?: true
    itemDescription?: true
    paymentStatus?: true
    paymentMethod?: true
    dueDate?: true
    comment?: true
  }

  export type BillrecieveCountAggregateInputType = {
    id?: true
    billNumber?: true
    amount?: true
    tax?: true
    customerName?: true
    customerAddress?: true
    contact?: true
    itemQuantity?: true
    itemPrice?: true
    itemDescription?: true
    paymentStatus?: true
    paymentMethod?: true
    dueDate?: true
    comment?: true
    _all?: true
  }

  export type BillrecieveAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billrecieve to aggregate.
     */
    where?: BillrecieveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billrecieves to fetch.
     */
    orderBy?: Enumerable<BillrecieveOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillrecieveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billrecieves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billrecieves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Billrecieves
    **/
    _count?: true | BillrecieveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillrecieveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillrecieveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillrecieveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillrecieveMaxAggregateInputType
  }

  export type GetBillrecieveAggregateType<T extends BillrecieveAggregateArgs> = {
        [P in keyof T & keyof AggregateBillrecieve]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillrecieve[P]>
      : GetScalarType<T[P], AggregateBillrecieve[P]>
  }




  export type BillrecieveGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BillrecieveWhereInput
    orderBy?: Enumerable<BillrecieveOrderByWithAggregationInput>
    by: BillrecieveScalarFieldEnum[]
    having?: BillrecieveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillrecieveCountAggregateInputType | true
    _avg?: BillrecieveAvgAggregateInputType
    _sum?: BillrecieveSumAggregateInputType
    _min?: BillrecieveMinAggregateInputType
    _max?: BillrecieveMaxAggregateInputType
  }


  export type BillrecieveGroupByOutputType = {
    id: number
    billNumber: string
    amount: string
    tax: string
    customerName: string
    customerAddress: string
    contact: string
    itemQuantity: string
    itemPrice: string
    itemDescription: string
    paymentStatus: paymentStatus
    paymentMethod: paymentMethod
    dueDate: string
    comment: string | null
    _count: BillrecieveCountAggregateOutputType | null
    _avg: BillrecieveAvgAggregateOutputType | null
    _sum: BillrecieveSumAggregateOutputType | null
    _min: BillrecieveMinAggregateOutputType | null
    _max: BillrecieveMaxAggregateOutputType | null
  }

  type GetBillrecieveGroupByPayload<T extends BillrecieveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BillrecieveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillrecieveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillrecieveGroupByOutputType[P]>
            : GetScalarType<T[P], BillrecieveGroupByOutputType[P]>
        }
      >
    >


  export type BillrecieveSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    amount?: boolean
    tax?: boolean
    customerName?: boolean
    customerAddress?: boolean
    contact?: boolean
    itemQuantity?: boolean
    itemPrice?: boolean
    itemDescription?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    dueDate?: boolean
    comment?: boolean
  }, ExtArgs["result"]["billrecieve"]>

  export type BillrecieveSelectScalar = {
    id?: boolean
    billNumber?: boolean
    amount?: boolean
    tax?: boolean
    customerName?: boolean
    customerAddress?: boolean
    contact?: boolean
    itemQuantity?: boolean
    itemPrice?: boolean
    itemDescription?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    dueDate?: boolean
    comment?: boolean
  }


  type BillrecieveGetPayload<S extends boolean | null | undefined | BillrecieveArgs> = $Types.GetResult<BillrecievePayload, S>

  type BillrecieveCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BillrecieveFindManyArgs, 'select' | 'include'> & {
      select?: BillrecieveCountAggregateInputType | true
    }

  export interface BillrecieveDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Billrecieve'], meta: { name: 'Billrecieve' } }
    /**
     * Find zero or one Billrecieve that matches the filter.
     * @param {BillrecieveFindUniqueArgs} args - Arguments to find a Billrecieve
     * @example
     * // Get one Billrecieve
     * const billrecieve = await prisma.billrecieve.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BillrecieveFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BillrecieveFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Billrecieve'> extends True ? Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Billrecieve that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BillrecieveFindUniqueOrThrowArgs} args - Arguments to find a Billrecieve
     * @example
     * // Get one Billrecieve
     * const billrecieve = await prisma.billrecieve.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BillrecieveFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillrecieveFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Billrecieve that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillrecieveFindFirstArgs} args - Arguments to find a Billrecieve
     * @example
     * // Get one Billrecieve
     * const billrecieve = await prisma.billrecieve.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BillrecieveFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BillrecieveFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Billrecieve'> extends True ? Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Billrecieve that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillrecieveFindFirstOrThrowArgs} args - Arguments to find a Billrecieve
     * @example
     * // Get one Billrecieve
     * const billrecieve = await prisma.billrecieve.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BillrecieveFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillrecieveFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Billrecieves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillrecieveFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billrecieves
     * const billrecieves = await prisma.billrecieve.findMany()
     * 
     * // Get first 10 Billrecieves
     * const billrecieves = await prisma.billrecieve.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billrecieveWithIdOnly = await prisma.billrecieve.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BillrecieveFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillrecieveFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Billrecieve.
     * @param {BillrecieveCreateArgs} args - Arguments to create a Billrecieve.
     * @example
     * // Create one Billrecieve
     * const Billrecieve = await prisma.billrecieve.create({
     *   data: {
     *     // ... data to create a Billrecieve
     *   }
     * })
     * 
    **/
    create<T extends BillrecieveCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BillrecieveCreateArgs<ExtArgs>>
    ): Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Billrecieves.
     *     @param {BillrecieveCreateManyArgs} args - Arguments to create many Billrecieves.
     *     @example
     *     // Create many Billrecieves
     *     const billrecieve = await prisma.billrecieve.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BillrecieveCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillrecieveCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Billrecieve.
     * @param {BillrecieveDeleteArgs} args - Arguments to delete one Billrecieve.
     * @example
     * // Delete one Billrecieve
     * const Billrecieve = await prisma.billrecieve.delete({
     *   where: {
     *     // ... filter to delete one Billrecieve
     *   }
     * })
     * 
    **/
    delete<T extends BillrecieveDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BillrecieveDeleteArgs<ExtArgs>>
    ): Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Billrecieve.
     * @param {BillrecieveUpdateArgs} args - Arguments to update one Billrecieve.
     * @example
     * // Update one Billrecieve
     * const billrecieve = await prisma.billrecieve.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BillrecieveUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BillrecieveUpdateArgs<ExtArgs>>
    ): Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Billrecieves.
     * @param {BillrecieveDeleteManyArgs} args - Arguments to filter Billrecieves to delete.
     * @example
     * // Delete a few Billrecieves
     * const { count } = await prisma.billrecieve.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BillrecieveDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillrecieveDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billrecieves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillrecieveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billrecieves
     * const billrecieve = await prisma.billrecieve.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BillrecieveUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BillrecieveUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Billrecieve.
     * @param {BillrecieveUpsertArgs} args - Arguments to update or create a Billrecieve.
     * @example
     * // Update or create a Billrecieve
     * const billrecieve = await prisma.billrecieve.upsert({
     *   create: {
     *     // ... data to create a Billrecieve
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billrecieve we want to update
     *   }
     * })
    **/
    upsert<T extends BillrecieveUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BillrecieveUpsertArgs<ExtArgs>>
    ): Prisma__BillrecieveClient<$Types.GetResult<BillrecievePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Billrecieves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillrecieveCountArgs} args - Arguments to filter Billrecieves to count.
     * @example
     * // Count the number of Billrecieves
     * const count = await prisma.billrecieve.count({
     *   where: {
     *     // ... the filter for the Billrecieves we want to count
     *   }
     * })
    **/
    count<T extends BillrecieveCountArgs>(
      args?: Subset<T, BillrecieveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillrecieveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billrecieve.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillrecieveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillrecieveAggregateArgs>(args: Subset<T, BillrecieveAggregateArgs>): Prisma.PrismaPromise<GetBillrecieveAggregateType<T>>

    /**
     * Group by Billrecieve.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillrecieveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillrecieveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillrecieveGroupByArgs['orderBy'] }
        : { orderBy?: BillrecieveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillrecieveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillrecieveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Billrecieve.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BillrecieveClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Billrecieve base type for findUnique actions
   */
  export type BillrecieveFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * Filter, which Billrecieve to fetch.
     */
    where: BillrecieveWhereUniqueInput
  }

  /**
   * Billrecieve findUnique
   */
  export interface BillrecieveFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BillrecieveFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Billrecieve findUniqueOrThrow
   */
  export type BillrecieveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * Filter, which Billrecieve to fetch.
     */
    where: BillrecieveWhereUniqueInput
  }


  /**
   * Billrecieve base type for findFirst actions
   */
  export type BillrecieveFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * Filter, which Billrecieve to fetch.
     */
    where?: BillrecieveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billrecieves to fetch.
     */
    orderBy?: Enumerable<BillrecieveOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billrecieves.
     */
    cursor?: BillrecieveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billrecieves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billrecieves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billrecieves.
     */
    distinct?: Enumerable<BillrecieveScalarFieldEnum>
  }

  /**
   * Billrecieve findFirst
   */
  export interface BillrecieveFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BillrecieveFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Billrecieve findFirstOrThrow
   */
  export type BillrecieveFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * Filter, which Billrecieve to fetch.
     */
    where?: BillrecieveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billrecieves to fetch.
     */
    orderBy?: Enumerable<BillrecieveOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billrecieves.
     */
    cursor?: BillrecieveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billrecieves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billrecieves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billrecieves.
     */
    distinct?: Enumerable<BillrecieveScalarFieldEnum>
  }


  /**
   * Billrecieve findMany
   */
  export type BillrecieveFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * Filter, which Billrecieves to fetch.
     */
    where?: BillrecieveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billrecieves to fetch.
     */
    orderBy?: Enumerable<BillrecieveOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Billrecieves.
     */
    cursor?: BillrecieveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billrecieves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billrecieves.
     */
    skip?: number
    distinct?: Enumerable<BillrecieveScalarFieldEnum>
  }


  /**
   * Billrecieve create
   */
  export type BillrecieveCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * The data needed to create a Billrecieve.
     */
    data: XOR<BillrecieveCreateInput, BillrecieveUncheckedCreateInput>
  }


  /**
   * Billrecieve createMany
   */
  export type BillrecieveCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Billrecieves.
     */
    data: Enumerable<BillrecieveCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Billrecieve update
   */
  export type BillrecieveUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * The data needed to update a Billrecieve.
     */
    data: XOR<BillrecieveUpdateInput, BillrecieveUncheckedUpdateInput>
    /**
     * Choose, which Billrecieve to update.
     */
    where: BillrecieveWhereUniqueInput
  }


  /**
   * Billrecieve updateMany
   */
  export type BillrecieveUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Billrecieves.
     */
    data: XOR<BillrecieveUpdateManyMutationInput, BillrecieveUncheckedUpdateManyInput>
    /**
     * Filter which Billrecieves to update
     */
    where?: BillrecieveWhereInput
  }


  /**
   * Billrecieve upsert
   */
  export type BillrecieveUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * The filter to search for the Billrecieve to update in case it exists.
     */
    where: BillrecieveWhereUniqueInput
    /**
     * In case the Billrecieve found by the `where` argument doesn't exist, create a new Billrecieve with this data.
     */
    create: XOR<BillrecieveCreateInput, BillrecieveUncheckedCreateInput>
    /**
     * In case the Billrecieve was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillrecieveUpdateInput, BillrecieveUncheckedUpdateInput>
  }


  /**
   * Billrecieve delete
   */
  export type BillrecieveDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
    /**
     * Filter which Billrecieve to delete.
     */
    where: BillrecieveWhereUniqueInput
  }


  /**
   * Billrecieve deleteMany
   */
  export type BillrecieveDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billrecieves to delete
     */
    where?: BillrecieveWhereInput
  }


  /**
   * Billrecieve without action
   */
  export type BillrecieveArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billrecieve
     */
    select?: BillrecieveSelect<ExtArgs> | null
  }



  /**
   * Model Billpayable
   */


  export type AggregateBillpayable = {
    _count: BillpayableCountAggregateOutputType | null
    _avg: BillpayableAvgAggregateOutputType | null
    _sum: BillpayableSumAggregateOutputType | null
    _min: BillpayableMinAggregateOutputType | null
    _max: BillpayableMaxAggregateOutputType | null
  }

  export type BillpayableAvgAggregateOutputType = {
    id: number | null
  }

  export type BillpayableSumAggregateOutputType = {
    id: number | null
  }

  export type BillpayableMinAggregateOutputType = {
    id: number | null
    supplierName: string | null
    supplierAddress: string | null
    contact: string | null
    billDate: string | null
    dueDate: string | null
    billAmount: string | null
    billNumber: string | null
    billDiscription: string | null
    paymentMethod: paymentMethod | null
    transactionId: string | null
    paymentDate: string | null
    paymentAmount: string | null
    tax: string | null
    comment: string | null
    invoiceNumber: string | null
  }

  export type BillpayableMaxAggregateOutputType = {
    id: number | null
    supplierName: string | null
    supplierAddress: string | null
    contact: string | null
    billDate: string | null
    dueDate: string | null
    billAmount: string | null
    billNumber: string | null
    billDiscription: string | null
    paymentMethod: paymentMethod | null
    transactionId: string | null
    paymentDate: string | null
    paymentAmount: string | null
    tax: string | null
    comment: string | null
    invoiceNumber: string | null
  }

  export type BillpayableCountAggregateOutputType = {
    id: number
    supplierName: number
    supplierAddress: number
    contact: number
    billDate: number
    dueDate: number
    billAmount: number
    billNumber: number
    billDiscription: number
    paymentMethod: number
    transactionId: number
    paymentDate: number
    paymentAmount: number
    tax: number
    comment: number
    invoiceNumber: number
    _all: number
  }


  export type BillpayableAvgAggregateInputType = {
    id?: true
  }

  export type BillpayableSumAggregateInputType = {
    id?: true
  }

  export type BillpayableMinAggregateInputType = {
    id?: true
    supplierName?: true
    supplierAddress?: true
    contact?: true
    billDate?: true
    dueDate?: true
    billAmount?: true
    billNumber?: true
    billDiscription?: true
    paymentMethod?: true
    transactionId?: true
    paymentDate?: true
    paymentAmount?: true
    tax?: true
    comment?: true
    invoiceNumber?: true
  }

  export type BillpayableMaxAggregateInputType = {
    id?: true
    supplierName?: true
    supplierAddress?: true
    contact?: true
    billDate?: true
    dueDate?: true
    billAmount?: true
    billNumber?: true
    billDiscription?: true
    paymentMethod?: true
    transactionId?: true
    paymentDate?: true
    paymentAmount?: true
    tax?: true
    comment?: true
    invoiceNumber?: true
  }

  export type BillpayableCountAggregateInputType = {
    id?: true
    supplierName?: true
    supplierAddress?: true
    contact?: true
    billDate?: true
    dueDate?: true
    billAmount?: true
    billNumber?: true
    billDiscription?: true
    paymentMethod?: true
    transactionId?: true
    paymentDate?: true
    paymentAmount?: true
    tax?: true
    comment?: true
    invoiceNumber?: true
    _all?: true
  }

  export type BillpayableAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billpayable to aggregate.
     */
    where?: BillpayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billpayables to fetch.
     */
    orderBy?: Enumerable<BillpayableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillpayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billpayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billpayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Billpayables
    **/
    _count?: true | BillpayableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillpayableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillpayableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillpayableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillpayableMaxAggregateInputType
  }

  export type GetBillpayableAggregateType<T extends BillpayableAggregateArgs> = {
        [P in keyof T & keyof AggregateBillpayable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillpayable[P]>
      : GetScalarType<T[P], AggregateBillpayable[P]>
  }




  export type BillpayableGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BillpayableWhereInput
    orderBy?: Enumerable<BillpayableOrderByWithAggregationInput>
    by: BillpayableScalarFieldEnum[]
    having?: BillpayableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillpayableCountAggregateInputType | true
    _avg?: BillpayableAvgAggregateInputType
    _sum?: BillpayableSumAggregateInputType
    _min?: BillpayableMinAggregateInputType
    _max?: BillpayableMaxAggregateInputType
  }


  export type BillpayableGroupByOutputType = {
    id: number
    supplierName: string
    supplierAddress: string
    contact: string
    billDate: string
    dueDate: string
    billAmount: string
    billNumber: string
    billDiscription: string
    paymentMethod: paymentMethod
    transactionId: string | null
    paymentDate: string
    paymentAmount: string
    tax: string
    comment: string | null
    invoiceNumber: string | null
    _count: BillpayableCountAggregateOutputType | null
    _avg: BillpayableAvgAggregateOutputType | null
    _sum: BillpayableSumAggregateOutputType | null
    _min: BillpayableMinAggregateOutputType | null
    _max: BillpayableMaxAggregateOutputType | null
  }

  type GetBillpayableGroupByPayload<T extends BillpayableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BillpayableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillpayableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillpayableGroupByOutputType[P]>
            : GetScalarType<T[P], BillpayableGroupByOutputType[P]>
        }
      >
    >


  export type BillpayableSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierName?: boolean
    supplierAddress?: boolean
    contact?: boolean
    billDate?: boolean
    dueDate?: boolean
    billAmount?: boolean
    billNumber?: boolean
    billDiscription?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    paymentDate?: boolean
    paymentAmount?: boolean
    tax?: boolean
    comment?: boolean
    invoiceNumber?: boolean
  }, ExtArgs["result"]["billpayable"]>

  export type BillpayableSelectScalar = {
    id?: boolean
    supplierName?: boolean
    supplierAddress?: boolean
    contact?: boolean
    billDate?: boolean
    dueDate?: boolean
    billAmount?: boolean
    billNumber?: boolean
    billDiscription?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    paymentDate?: boolean
    paymentAmount?: boolean
    tax?: boolean
    comment?: boolean
    invoiceNumber?: boolean
  }


  type BillpayableGetPayload<S extends boolean | null | undefined | BillpayableArgs> = $Types.GetResult<BillpayablePayload, S>

  type BillpayableCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BillpayableFindManyArgs, 'select' | 'include'> & {
      select?: BillpayableCountAggregateInputType | true
    }

  export interface BillpayableDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Billpayable'], meta: { name: 'Billpayable' } }
    /**
     * Find zero or one Billpayable that matches the filter.
     * @param {BillpayableFindUniqueArgs} args - Arguments to find a Billpayable
     * @example
     * // Get one Billpayable
     * const billpayable = await prisma.billpayable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BillpayableFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BillpayableFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Billpayable'> extends True ? Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Billpayable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BillpayableFindUniqueOrThrowArgs} args - Arguments to find a Billpayable
     * @example
     * // Get one Billpayable
     * const billpayable = await prisma.billpayable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BillpayableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillpayableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Billpayable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillpayableFindFirstArgs} args - Arguments to find a Billpayable
     * @example
     * // Get one Billpayable
     * const billpayable = await prisma.billpayable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BillpayableFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BillpayableFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Billpayable'> extends True ? Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Billpayable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillpayableFindFirstOrThrowArgs} args - Arguments to find a Billpayable
     * @example
     * // Get one Billpayable
     * const billpayable = await prisma.billpayable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BillpayableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillpayableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Billpayables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillpayableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billpayables
     * const billpayables = await prisma.billpayable.findMany()
     * 
     * // Get first 10 Billpayables
     * const billpayables = await prisma.billpayable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billpayableWithIdOnly = await prisma.billpayable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BillpayableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillpayableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Billpayable.
     * @param {BillpayableCreateArgs} args - Arguments to create a Billpayable.
     * @example
     * // Create one Billpayable
     * const Billpayable = await prisma.billpayable.create({
     *   data: {
     *     // ... data to create a Billpayable
     *   }
     * })
     * 
    **/
    create<T extends BillpayableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BillpayableCreateArgs<ExtArgs>>
    ): Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Billpayables.
     *     @param {BillpayableCreateManyArgs} args - Arguments to create many Billpayables.
     *     @example
     *     // Create many Billpayables
     *     const billpayable = await prisma.billpayable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BillpayableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillpayableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Billpayable.
     * @param {BillpayableDeleteArgs} args - Arguments to delete one Billpayable.
     * @example
     * // Delete one Billpayable
     * const Billpayable = await prisma.billpayable.delete({
     *   where: {
     *     // ... filter to delete one Billpayable
     *   }
     * })
     * 
    **/
    delete<T extends BillpayableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BillpayableDeleteArgs<ExtArgs>>
    ): Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Billpayable.
     * @param {BillpayableUpdateArgs} args - Arguments to update one Billpayable.
     * @example
     * // Update one Billpayable
     * const billpayable = await prisma.billpayable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BillpayableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BillpayableUpdateArgs<ExtArgs>>
    ): Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Billpayables.
     * @param {BillpayableDeleteManyArgs} args - Arguments to filter Billpayables to delete.
     * @example
     * // Delete a few Billpayables
     * const { count } = await prisma.billpayable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BillpayableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillpayableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billpayables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillpayableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billpayables
     * const billpayable = await prisma.billpayable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BillpayableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BillpayableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Billpayable.
     * @param {BillpayableUpsertArgs} args - Arguments to update or create a Billpayable.
     * @example
     * // Update or create a Billpayable
     * const billpayable = await prisma.billpayable.upsert({
     *   create: {
     *     // ... data to create a Billpayable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billpayable we want to update
     *   }
     * })
    **/
    upsert<T extends BillpayableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BillpayableUpsertArgs<ExtArgs>>
    ): Prisma__BillpayableClient<$Types.GetResult<BillpayablePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Billpayables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillpayableCountArgs} args - Arguments to filter Billpayables to count.
     * @example
     * // Count the number of Billpayables
     * const count = await prisma.billpayable.count({
     *   where: {
     *     // ... the filter for the Billpayables we want to count
     *   }
     * })
    **/
    count<T extends BillpayableCountArgs>(
      args?: Subset<T, BillpayableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillpayableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billpayable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillpayableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillpayableAggregateArgs>(args: Subset<T, BillpayableAggregateArgs>): Prisma.PrismaPromise<GetBillpayableAggregateType<T>>

    /**
     * Group by Billpayable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillpayableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillpayableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillpayableGroupByArgs['orderBy'] }
        : { orderBy?: BillpayableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillpayableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillpayableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Billpayable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BillpayableClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Billpayable base type for findUnique actions
   */
  export type BillpayableFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * Filter, which Billpayable to fetch.
     */
    where: BillpayableWhereUniqueInput
  }

  /**
   * Billpayable findUnique
   */
  export interface BillpayableFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BillpayableFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Billpayable findUniqueOrThrow
   */
  export type BillpayableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * Filter, which Billpayable to fetch.
     */
    where: BillpayableWhereUniqueInput
  }


  /**
   * Billpayable base type for findFirst actions
   */
  export type BillpayableFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * Filter, which Billpayable to fetch.
     */
    where?: BillpayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billpayables to fetch.
     */
    orderBy?: Enumerable<BillpayableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billpayables.
     */
    cursor?: BillpayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billpayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billpayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billpayables.
     */
    distinct?: Enumerable<BillpayableScalarFieldEnum>
  }

  /**
   * Billpayable findFirst
   */
  export interface BillpayableFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BillpayableFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Billpayable findFirstOrThrow
   */
  export type BillpayableFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * Filter, which Billpayable to fetch.
     */
    where?: BillpayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billpayables to fetch.
     */
    orderBy?: Enumerable<BillpayableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billpayables.
     */
    cursor?: BillpayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billpayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billpayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billpayables.
     */
    distinct?: Enumerable<BillpayableScalarFieldEnum>
  }


  /**
   * Billpayable findMany
   */
  export type BillpayableFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * Filter, which Billpayables to fetch.
     */
    where?: BillpayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billpayables to fetch.
     */
    orderBy?: Enumerable<BillpayableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Billpayables.
     */
    cursor?: BillpayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billpayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billpayables.
     */
    skip?: number
    distinct?: Enumerable<BillpayableScalarFieldEnum>
  }


  /**
   * Billpayable create
   */
  export type BillpayableCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * The data needed to create a Billpayable.
     */
    data: XOR<BillpayableCreateInput, BillpayableUncheckedCreateInput>
  }


  /**
   * Billpayable createMany
   */
  export type BillpayableCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Billpayables.
     */
    data: Enumerable<BillpayableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Billpayable update
   */
  export type BillpayableUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * The data needed to update a Billpayable.
     */
    data: XOR<BillpayableUpdateInput, BillpayableUncheckedUpdateInput>
    /**
     * Choose, which Billpayable to update.
     */
    where: BillpayableWhereUniqueInput
  }


  /**
   * Billpayable updateMany
   */
  export type BillpayableUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Billpayables.
     */
    data: XOR<BillpayableUpdateManyMutationInput, BillpayableUncheckedUpdateManyInput>
    /**
     * Filter which Billpayables to update
     */
    where?: BillpayableWhereInput
  }


  /**
   * Billpayable upsert
   */
  export type BillpayableUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * The filter to search for the Billpayable to update in case it exists.
     */
    where: BillpayableWhereUniqueInput
    /**
     * In case the Billpayable found by the `where` argument doesn't exist, create a new Billpayable with this data.
     */
    create: XOR<BillpayableCreateInput, BillpayableUncheckedCreateInput>
    /**
     * In case the Billpayable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillpayableUpdateInput, BillpayableUncheckedUpdateInput>
  }


  /**
   * Billpayable delete
   */
  export type BillpayableDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
    /**
     * Filter which Billpayable to delete.
     */
    where: BillpayableWhereUniqueInput
  }


  /**
   * Billpayable deleteMany
   */
  export type BillpayableDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billpayables to delete
     */
    where?: BillpayableWhereInput
  }


  /**
   * Billpayable without action
   */
  export type BillpayableArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billpayable
     */
    select?: BillpayableSelect<ExtArgs> | null
  }



  /**
   * Model UploadedDocument
   */


  export type AggregateUploadedDocument = {
    _count: UploadedDocumentCountAggregateOutputType | null
    _avg: UploadedDocumentAvgAggregateOutputType | null
    _sum: UploadedDocumentSumAggregateOutputType | null
    _min: UploadedDocumentMinAggregateOutputType | null
    _max: UploadedDocumentMaxAggregateOutputType | null
  }

  export type UploadedDocumentAvgAggregateOutputType = {
    userId: number | null
  }

  export type UploadedDocumentSumAggregateOutputType = {
    userId: number | null
  }

  export type UploadedDocumentMinAggregateOutputType = {
    id: string | null
    userId: number | null
    fileName: string | null
    applicationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UploadedDocumentMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    fileName: string | null
    applicationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UploadedDocumentCountAggregateOutputType = {
    id: number
    userId: number
    fileName: number
    applicationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UploadedDocumentAvgAggregateInputType = {
    userId?: true
  }

  export type UploadedDocumentSumAggregateInputType = {
    userId?: true
  }

  export type UploadedDocumentMinAggregateInputType = {
    id?: true
    userId?: true
    fileName?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UploadedDocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    fileName?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UploadedDocumentCountAggregateInputType = {
    id?: true
    userId?: true
    fileName?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UploadedDocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedDocument to aggregate.
     */
    where?: UploadedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedDocuments to fetch.
     */
    orderBy?: Enumerable<UploadedDocumentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UploadedDocuments
    **/
    _count?: true | UploadedDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UploadedDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UploadedDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadedDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadedDocumentMaxAggregateInputType
  }

  export type GetUploadedDocumentAggregateType<T extends UploadedDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateUploadedDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUploadedDocument[P]>
      : GetScalarType<T[P], AggregateUploadedDocument[P]>
  }




  export type UploadedDocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UploadedDocumentWhereInput
    orderBy?: Enumerable<UploadedDocumentOrderByWithAggregationInput>
    by: UploadedDocumentScalarFieldEnum[]
    having?: UploadedDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadedDocumentCountAggregateInputType | true
    _avg?: UploadedDocumentAvgAggregateInputType
    _sum?: UploadedDocumentSumAggregateInputType
    _min?: UploadedDocumentMinAggregateInputType
    _max?: UploadedDocumentMaxAggregateInputType
  }


  export type UploadedDocumentGroupByOutputType = {
    id: string
    userId: number
    fileName: string
    applicationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UploadedDocumentCountAggregateOutputType | null
    _avg: UploadedDocumentAvgAggregateOutputType | null
    _sum: UploadedDocumentSumAggregateOutputType | null
    _min: UploadedDocumentMinAggregateOutputType | null
    _max: UploadedDocumentMaxAggregateOutputType | null
  }

  type GetUploadedDocumentGroupByPayload<T extends UploadedDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UploadedDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadedDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadedDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], UploadedDocumentGroupByOutputType[P]>
        }
      >
    >


  export type UploadedDocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fileName?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    docs?: boolean | UploadedDocument$docsArgs<ExtArgs>
    application?: boolean | LoanApplicationArgs<ExtArgs>
    _count?: boolean | UploadedDocumentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedDocument"]>

  export type UploadedDocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    fileName?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UploadedDocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    docs?: boolean | UploadedDocument$docsArgs<ExtArgs>
    application?: boolean | LoanApplicationArgs<ExtArgs>
    _count?: boolean | UploadedDocumentCountOutputTypeArgs<ExtArgs>
  }


  type UploadedDocumentGetPayload<S extends boolean | null | undefined | UploadedDocumentArgs> = $Types.GetResult<UploadedDocumentPayload, S>

  type UploadedDocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UploadedDocumentFindManyArgs, 'select' | 'include'> & {
      select?: UploadedDocumentCountAggregateInputType | true
    }

  export interface UploadedDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UploadedDocument'], meta: { name: 'UploadedDocument' } }
    /**
     * Find zero or one UploadedDocument that matches the filter.
     * @param {UploadedDocumentFindUniqueArgs} args - Arguments to find a UploadedDocument
     * @example
     * // Get one UploadedDocument
     * const uploadedDocument = await prisma.uploadedDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UploadedDocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UploadedDocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UploadedDocument'> extends True ? Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UploadedDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UploadedDocumentFindUniqueOrThrowArgs} args - Arguments to find a UploadedDocument
     * @example
     * // Get one UploadedDocument
     * const uploadedDocument = await prisma.uploadedDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UploadedDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UploadedDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UploadedDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedDocumentFindFirstArgs} args - Arguments to find a UploadedDocument
     * @example
     * // Get one UploadedDocument
     * const uploadedDocument = await prisma.uploadedDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UploadedDocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UploadedDocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UploadedDocument'> extends True ? Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UploadedDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedDocumentFindFirstOrThrowArgs} args - Arguments to find a UploadedDocument
     * @example
     * // Get one UploadedDocument
     * const uploadedDocument = await prisma.uploadedDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UploadedDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UploadedDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UploadedDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UploadedDocuments
     * const uploadedDocuments = await prisma.uploadedDocument.findMany()
     * 
     * // Get first 10 UploadedDocuments
     * const uploadedDocuments = await prisma.uploadedDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadedDocumentWithIdOnly = await prisma.uploadedDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UploadedDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UploadedDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UploadedDocument.
     * @param {UploadedDocumentCreateArgs} args - Arguments to create a UploadedDocument.
     * @example
     * // Create one UploadedDocument
     * const UploadedDocument = await prisma.uploadedDocument.create({
     *   data: {
     *     // ... data to create a UploadedDocument
     *   }
     * })
     * 
    **/
    create<T extends UploadedDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UploadedDocumentCreateArgs<ExtArgs>>
    ): Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UploadedDocuments.
     *     @param {UploadedDocumentCreateManyArgs} args - Arguments to create many UploadedDocuments.
     *     @example
     *     // Create many UploadedDocuments
     *     const uploadedDocument = await prisma.uploadedDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UploadedDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UploadedDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UploadedDocument.
     * @param {UploadedDocumentDeleteArgs} args - Arguments to delete one UploadedDocument.
     * @example
     * // Delete one UploadedDocument
     * const UploadedDocument = await prisma.uploadedDocument.delete({
     *   where: {
     *     // ... filter to delete one UploadedDocument
     *   }
     * })
     * 
    **/
    delete<T extends UploadedDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UploadedDocumentDeleteArgs<ExtArgs>>
    ): Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UploadedDocument.
     * @param {UploadedDocumentUpdateArgs} args - Arguments to update one UploadedDocument.
     * @example
     * // Update one UploadedDocument
     * const uploadedDocument = await prisma.uploadedDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UploadedDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UploadedDocumentUpdateArgs<ExtArgs>>
    ): Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UploadedDocuments.
     * @param {UploadedDocumentDeleteManyArgs} args - Arguments to filter UploadedDocuments to delete.
     * @example
     * // Delete a few UploadedDocuments
     * const { count } = await prisma.uploadedDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UploadedDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UploadedDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UploadedDocuments
     * const uploadedDocument = await prisma.uploadedDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UploadedDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UploadedDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UploadedDocument.
     * @param {UploadedDocumentUpsertArgs} args - Arguments to update or create a UploadedDocument.
     * @example
     * // Update or create a UploadedDocument
     * const uploadedDocument = await prisma.uploadedDocument.upsert({
     *   create: {
     *     // ... data to create a UploadedDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UploadedDocument we want to update
     *   }
     * })
    **/
    upsert<T extends UploadedDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UploadedDocumentUpsertArgs<ExtArgs>>
    ): Prisma__UploadedDocumentClient<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UploadedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedDocumentCountArgs} args - Arguments to filter UploadedDocuments to count.
     * @example
     * // Count the number of UploadedDocuments
     * const count = await prisma.uploadedDocument.count({
     *   where: {
     *     // ... the filter for the UploadedDocuments we want to count
     *   }
     * })
    **/
    count<T extends UploadedDocumentCountArgs>(
      args?: Subset<T, UploadedDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadedDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UploadedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadedDocumentAggregateArgs>(args: Subset<T, UploadedDocumentAggregateArgs>): Prisma.PrismaPromise<GetUploadedDocumentAggregateType<T>>

    /**
     * Group by UploadedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadedDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadedDocumentGroupByArgs['orderBy'] }
        : { orderBy?: UploadedDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadedDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadedDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UploadedDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UploadedDocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    docs<T extends UploadedDocument$docsArgs<ExtArgs> = {}>(args?: Subset<T, UploadedDocument$docsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    application<T extends LoanApplicationArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UploadedDocument base type for findUnique actions
   */
  export type UploadedDocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UploadedDocument to fetch.
     */
    where: UploadedDocumentWhereUniqueInput
  }

  /**
   * UploadedDocument findUnique
   */
  export interface UploadedDocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UploadedDocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UploadedDocument findUniqueOrThrow
   */
  export type UploadedDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UploadedDocument to fetch.
     */
    where: UploadedDocumentWhereUniqueInput
  }


  /**
   * UploadedDocument base type for findFirst actions
   */
  export type UploadedDocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UploadedDocument to fetch.
     */
    where?: UploadedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedDocuments to fetch.
     */
    orderBy?: Enumerable<UploadedDocumentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedDocuments.
     */
    cursor?: UploadedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedDocuments.
     */
    distinct?: Enumerable<UploadedDocumentScalarFieldEnum>
  }

  /**
   * UploadedDocument findFirst
   */
  export interface UploadedDocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UploadedDocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UploadedDocument findFirstOrThrow
   */
  export type UploadedDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UploadedDocument to fetch.
     */
    where?: UploadedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedDocuments to fetch.
     */
    orderBy?: Enumerable<UploadedDocumentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedDocuments.
     */
    cursor?: UploadedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedDocuments.
     */
    distinct?: Enumerable<UploadedDocumentScalarFieldEnum>
  }


  /**
   * UploadedDocument findMany
   */
  export type UploadedDocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UploadedDocuments to fetch.
     */
    where?: UploadedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedDocuments to fetch.
     */
    orderBy?: Enumerable<UploadedDocumentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UploadedDocuments.
     */
    cursor?: UploadedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedDocuments.
     */
    skip?: number
    distinct?: Enumerable<UploadedDocumentScalarFieldEnum>
  }


  /**
   * UploadedDocument create
   */
  export type UploadedDocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a UploadedDocument.
     */
    data: XOR<UploadedDocumentCreateInput, UploadedDocumentUncheckedCreateInput>
  }


  /**
   * UploadedDocument createMany
   */
  export type UploadedDocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UploadedDocuments.
     */
    data: Enumerable<UploadedDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UploadedDocument update
   */
  export type UploadedDocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a UploadedDocument.
     */
    data: XOR<UploadedDocumentUpdateInput, UploadedDocumentUncheckedUpdateInput>
    /**
     * Choose, which UploadedDocument to update.
     */
    where: UploadedDocumentWhereUniqueInput
  }


  /**
   * UploadedDocument updateMany
   */
  export type UploadedDocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UploadedDocuments.
     */
    data: XOR<UploadedDocumentUpdateManyMutationInput, UploadedDocumentUncheckedUpdateManyInput>
    /**
     * Filter which UploadedDocuments to update
     */
    where?: UploadedDocumentWhereInput
  }


  /**
   * UploadedDocument upsert
   */
  export type UploadedDocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the UploadedDocument to update in case it exists.
     */
    where: UploadedDocumentWhereUniqueInput
    /**
     * In case the UploadedDocument found by the `where` argument doesn't exist, create a new UploadedDocument with this data.
     */
    create: XOR<UploadedDocumentCreateInput, UploadedDocumentUncheckedCreateInput>
    /**
     * In case the UploadedDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadedDocumentUpdateInput, UploadedDocumentUncheckedUpdateInput>
  }


  /**
   * UploadedDocument delete
   */
  export type UploadedDocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    /**
     * Filter which UploadedDocument to delete.
     */
    where: UploadedDocumentWhereUniqueInput
  }


  /**
   * UploadedDocument deleteMany
   */
  export type UploadedDocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedDocuments to delete
     */
    where?: UploadedDocumentWhereInput
  }


  /**
   * UploadedDocument.docs
   */
  export type UploadedDocument$docsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    where?: LoanDocumentWhereInput
    orderBy?: Enumerable<LoanDocumentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LoanDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoanDocumentScalarFieldEnum>
  }


  /**
   * UploadedDocument without action
   */
  export type UploadedDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
  }



  /**
   * Model LoanDocument
   */


  export type AggregateLoanDocument = {
    _count: LoanDocumentCountAggregateOutputType | null
    _min: LoanDocumentMinAggregateOutputType | null
    _max: LoanDocumentMaxAggregateOutputType | null
  }

  export type LoanDocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    mandatory: boolean | null
    type: DocumentType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanDocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    mandatory: boolean | null
    type: DocumentType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanDocumentCountAggregateOutputType = {
    id: number
    name: number
    shortName: number
    mandatory: number
    type: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanDocumentMinAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    mandatory?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanDocumentMaxAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    mandatory?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanDocumentCountAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    mandatory?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanDocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanDocument to aggregate.
     */
    where?: LoanDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanDocuments to fetch.
     */
    orderBy?: Enumerable<LoanDocumentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanDocuments
    **/
    _count?: true | LoanDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanDocumentMaxAggregateInputType
  }

  export type GetLoanDocumentAggregateType<T extends LoanDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanDocument[P]>
      : GetScalarType<T[P], AggregateLoanDocument[P]>
  }




  export type LoanDocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanDocumentWhereInput
    orderBy?: Enumerable<LoanDocumentOrderByWithAggregationInput>
    by: LoanDocumentScalarFieldEnum[]
    having?: LoanDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanDocumentCountAggregateInputType | true
    _min?: LoanDocumentMinAggregateInputType
    _max?: LoanDocumentMaxAggregateInputType
  }


  export type LoanDocumentGroupByOutputType = {
    id: string
    name: string
    shortName: string
    mandatory: boolean
    type: DocumentType
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoanDocumentCountAggregateOutputType | null
    _min: LoanDocumentMinAggregateOutputType | null
    _max: LoanDocumentMaxAggregateOutputType | null
  }

  type GetLoanDocumentGroupByPayload<T extends LoanDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LoanDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], LoanDocumentGroupByOutputType[P]>
        }
      >
    >


  export type LoanDocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    mandatory?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documents?: boolean | LoanDocument$documentsArgs<ExtArgs>
    loans?: boolean | LoanDocument$loansArgs<ExtArgs>
    _count?: boolean | LoanDocumentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["loanDocument"]>

  export type LoanDocumentSelectScalar = {
    id?: boolean
    name?: boolean
    shortName?: boolean
    mandatory?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanDocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | LoanDocument$documentsArgs<ExtArgs>
    loans?: boolean | LoanDocument$loansArgs<ExtArgs>
    _count?: boolean | LoanDocumentCountOutputTypeArgs<ExtArgs>
  }


  type LoanDocumentGetPayload<S extends boolean | null | undefined | LoanDocumentArgs> = $Types.GetResult<LoanDocumentPayload, S>

  type LoanDocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LoanDocumentFindManyArgs, 'select' | 'include'> & {
      select?: LoanDocumentCountAggregateInputType | true
    }

  export interface LoanDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanDocument'], meta: { name: 'LoanDocument' } }
    /**
     * Find zero or one LoanDocument that matches the filter.
     * @param {LoanDocumentFindUniqueArgs} args - Arguments to find a LoanDocument
     * @example
     * // Get one LoanDocument
     * const loanDocument = await prisma.loanDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoanDocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoanDocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LoanDocument'> extends True ? Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one LoanDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LoanDocumentFindUniqueOrThrowArgs} args - Arguments to find a LoanDocument
     * @example
     * // Get one LoanDocument
     * const loanDocument = await prisma.loanDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoanDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first LoanDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDocumentFindFirstArgs} args - Arguments to find a LoanDocument
     * @example
     * // Get one LoanDocument
     * const loanDocument = await prisma.loanDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoanDocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoanDocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LoanDocument'> extends True ? Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first LoanDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDocumentFindFirstOrThrowArgs} args - Arguments to find a LoanDocument
     * @example
     * // Get one LoanDocument
     * const loanDocument = await prisma.loanDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoanDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more LoanDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanDocuments
     * const loanDocuments = await prisma.loanDocument.findMany()
     * 
     * // Get first 10 LoanDocuments
     * const loanDocuments = await prisma.loanDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanDocumentWithIdOnly = await prisma.loanDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoanDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a LoanDocument.
     * @param {LoanDocumentCreateArgs} args - Arguments to create a LoanDocument.
     * @example
     * // Create one LoanDocument
     * const LoanDocument = await prisma.loanDocument.create({
     *   data: {
     *     // ... data to create a LoanDocument
     *   }
     * })
     * 
    **/
    create<T extends LoanDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LoanDocumentCreateArgs<ExtArgs>>
    ): Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many LoanDocuments.
     *     @param {LoanDocumentCreateManyArgs} args - Arguments to create many LoanDocuments.
     *     @example
     *     // Create many LoanDocuments
     *     const loanDocument = await prisma.loanDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoanDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LoanDocument.
     * @param {LoanDocumentDeleteArgs} args - Arguments to delete one LoanDocument.
     * @example
     * // Delete one LoanDocument
     * const LoanDocument = await prisma.loanDocument.delete({
     *   where: {
     *     // ... filter to delete one LoanDocument
     *   }
     * })
     * 
    **/
    delete<T extends LoanDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LoanDocumentDeleteArgs<ExtArgs>>
    ): Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one LoanDocument.
     * @param {LoanDocumentUpdateArgs} args - Arguments to update one LoanDocument.
     * @example
     * // Update one LoanDocument
     * const loanDocument = await prisma.loanDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoanDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LoanDocumentUpdateArgs<ExtArgs>>
    ): Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more LoanDocuments.
     * @param {LoanDocumentDeleteManyArgs} args - Arguments to filter LoanDocuments to delete.
     * @example
     * // Delete a few LoanDocuments
     * const { count } = await prisma.loanDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoanDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanDocuments
     * const loanDocument = await prisma.loanDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoanDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LoanDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoanDocument.
     * @param {LoanDocumentUpsertArgs} args - Arguments to update or create a LoanDocument.
     * @example
     * // Update or create a LoanDocument
     * const loanDocument = await prisma.loanDocument.upsert({
     *   create: {
     *     // ... data to create a LoanDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanDocument we want to update
     *   }
     * })
    **/
    upsert<T extends LoanDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LoanDocumentUpsertArgs<ExtArgs>>
    ): Prisma__LoanDocumentClient<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of LoanDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDocumentCountArgs} args - Arguments to filter LoanDocuments to count.
     * @example
     * // Count the number of LoanDocuments
     * const count = await prisma.loanDocument.count({
     *   where: {
     *     // ... the filter for the LoanDocuments we want to count
     *   }
     * })
    **/
    count<T extends LoanDocumentCountArgs>(
      args?: Subset<T, LoanDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanDocumentAggregateArgs>(args: Subset<T, LoanDocumentAggregateArgs>): Prisma.PrismaPromise<GetLoanDocumentAggregateType<T>>

    /**
     * Group by LoanDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanDocumentGroupByArgs['orderBy'] }
        : { orderBy?: LoanDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoanDocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    documents<T extends LoanDocument$documentsArgs<ExtArgs> = {}>(args?: Subset<T, LoanDocument$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    loans<T extends LoanDocument$loansArgs<ExtArgs> = {}>(args?: Subset<T, LoanDocument$loansArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LoanDocument base type for findUnique actions
   */
  export type LoanDocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LoanDocument to fetch.
     */
    where: LoanDocumentWhereUniqueInput
  }

  /**
   * LoanDocument findUnique
   */
  export interface LoanDocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoanDocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoanDocument findUniqueOrThrow
   */
  export type LoanDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LoanDocument to fetch.
     */
    where: LoanDocumentWhereUniqueInput
  }


  /**
   * LoanDocument base type for findFirst actions
   */
  export type LoanDocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LoanDocument to fetch.
     */
    where?: LoanDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanDocuments to fetch.
     */
    orderBy?: Enumerable<LoanDocumentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanDocuments.
     */
    cursor?: LoanDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanDocuments.
     */
    distinct?: Enumerable<LoanDocumentScalarFieldEnum>
  }

  /**
   * LoanDocument findFirst
   */
  export interface LoanDocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoanDocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoanDocument findFirstOrThrow
   */
  export type LoanDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LoanDocument to fetch.
     */
    where?: LoanDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanDocuments to fetch.
     */
    orderBy?: Enumerable<LoanDocumentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanDocuments.
     */
    cursor?: LoanDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanDocuments.
     */
    distinct?: Enumerable<LoanDocumentScalarFieldEnum>
  }


  /**
   * LoanDocument findMany
   */
  export type LoanDocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LoanDocuments to fetch.
     */
    where?: LoanDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanDocuments to fetch.
     */
    orderBy?: Enumerable<LoanDocumentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanDocuments.
     */
    cursor?: LoanDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanDocuments.
     */
    skip?: number
    distinct?: Enumerable<LoanDocumentScalarFieldEnum>
  }


  /**
   * LoanDocument create
   */
  export type LoanDocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanDocument.
     */
    data: XOR<LoanDocumentCreateInput, LoanDocumentUncheckedCreateInput>
  }


  /**
   * LoanDocument createMany
   */
  export type LoanDocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanDocuments.
     */
    data: Enumerable<LoanDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LoanDocument update
   */
  export type LoanDocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanDocument.
     */
    data: XOR<LoanDocumentUpdateInput, LoanDocumentUncheckedUpdateInput>
    /**
     * Choose, which LoanDocument to update.
     */
    where: LoanDocumentWhereUniqueInput
  }


  /**
   * LoanDocument updateMany
   */
  export type LoanDocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanDocuments.
     */
    data: XOR<LoanDocumentUpdateManyMutationInput, LoanDocumentUncheckedUpdateManyInput>
    /**
     * Filter which LoanDocuments to update
     */
    where?: LoanDocumentWhereInput
  }


  /**
   * LoanDocument upsert
   */
  export type LoanDocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanDocument to update in case it exists.
     */
    where: LoanDocumentWhereUniqueInput
    /**
     * In case the LoanDocument found by the `where` argument doesn't exist, create a new LoanDocument with this data.
     */
    create: XOR<LoanDocumentCreateInput, LoanDocumentUncheckedCreateInput>
    /**
     * In case the LoanDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanDocumentUpdateInput, LoanDocumentUncheckedUpdateInput>
  }


  /**
   * LoanDocument delete
   */
  export type LoanDocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    /**
     * Filter which LoanDocument to delete.
     */
    where: LoanDocumentWhereUniqueInput
  }


  /**
   * LoanDocument deleteMany
   */
  export type LoanDocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanDocuments to delete
     */
    where?: LoanDocumentWhereInput
  }


  /**
   * LoanDocument.documents
   */
  export type LoanDocument$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    where?: UploadedDocumentWhereInput
    orderBy?: Enumerable<UploadedDocumentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: UploadedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UploadedDocumentScalarFieldEnum>
  }


  /**
   * LoanDocument.loans
   */
  export type LoanDocument$loansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    where?: LoanWhereInput
    orderBy?: Enumerable<LoanOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LoanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoanScalarFieldEnum>
  }


  /**
   * LoanDocument without action
   */
  export type LoanDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
  }



  /**
   * Model Loan
   */


  export type AggregateLoan = {
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  export type LoanAvgAggregateOutputType = {
    maxAmount: Decimal | null
    minAmount: Decimal | null
    interest: Decimal | null
  }

  export type LoanSumAggregateOutputType = {
    maxAmount: Decimal | null
    minAmount: Decimal | null
    interest: Decimal | null
  }

  export type LoanMinAggregateOutputType = {
    id: string | null
    type: LoanType | null
    name: string | null
    shortName: string | null
    description: string | null
    maxAmount: Decimal | null
    minAmount: Decimal | null
    interest: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanMaxAggregateOutputType = {
    id: string | null
    type: LoanType | null
    name: string | null
    shortName: string | null
    description: string | null
    maxAmount: Decimal | null
    minAmount: Decimal | null
    interest: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanCountAggregateOutputType = {
    id: number
    type: number
    name: number
    shortName: number
    description: number
    maxAmount: number
    minAmount: number
    interest: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanAvgAggregateInputType = {
    maxAmount?: true
    minAmount?: true
    interest?: true
  }

  export type LoanSumAggregateInputType = {
    maxAmount?: true
    minAmount?: true
    interest?: true
  }

  export type LoanMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    shortName?: true
    description?: true
    maxAmount?: true
    minAmount?: true
    interest?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    shortName?: true
    description?: true
    maxAmount?: true
    minAmount?: true
    interest?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    shortName?: true
    description?: true
    maxAmount?: true
    minAmount?: true
    interest?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loan to aggregate.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: Enumerable<LoanOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loans
    **/
    _count?: true | LoanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanMaxAggregateInputType
  }

  export type GetLoanAggregateType<T extends LoanAggregateArgs> = {
        [P in keyof T & keyof AggregateLoan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoan[P]>
      : GetScalarType<T[P], AggregateLoan[P]>
  }




  export type LoanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanWhereInput
    orderBy?: Enumerable<LoanOrderByWithAggregationInput>
    by: LoanScalarFieldEnum[]
    having?: LoanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanCountAggregateInputType | true
    _avg?: LoanAvgAggregateInputType
    _sum?: LoanSumAggregateInputType
    _min?: LoanMinAggregateInputType
    _max?: LoanMaxAggregateInputType
  }


  export type LoanGroupByOutputType = {
    id: string
    type: LoanType
    name: string
    shortName: string | null
    description: string | null
    maxAmount: Decimal | null
    minAmount: Decimal | null
    interest: Decimal
    createdAt: Date
    updatedAt: Date
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  type GetLoanGroupByPayload<T extends LoanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LoanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanGroupByOutputType[P]>
            : GetScalarType<T[P], LoanGroupByOutputType[P]>
        }
      >
    >


  export type LoanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    shortName?: boolean
    description?: boolean
    maxAmount?: boolean
    minAmount?: boolean
    interest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documents?: boolean | Loan$documentsArgs<ExtArgs>
    applications?: boolean | Loan$applicationsArgs<ExtArgs>
    _count?: boolean | LoanCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["loan"]>

  export type LoanSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    shortName?: boolean
    description?: boolean
    maxAmount?: boolean
    minAmount?: boolean
    interest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | Loan$documentsArgs<ExtArgs>
    applications?: boolean | Loan$applicationsArgs<ExtArgs>
    _count?: boolean | LoanCountOutputTypeArgs<ExtArgs>
  }


  type LoanGetPayload<S extends boolean | null | undefined | LoanArgs> = $Types.GetResult<LoanPayload, S>

  type LoanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LoanFindManyArgs, 'select' | 'include'> & {
      select?: LoanCountAggregateInputType | true
    }

  export interface LoanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loan'], meta: { name: 'Loan' } }
    /**
     * Find zero or one Loan that matches the filter.
     * @param {LoanFindUniqueArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoanFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoanFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Loan'> extends True ? Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Loan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LoanFindUniqueOrThrowArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Loan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoanFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoanFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Loan'> extends True ? Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Loan that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstOrThrowArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loans
     * const loans = await prisma.loan.findMany()
     * 
     * // Get first 10 Loans
     * const loans = await prisma.loan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanWithIdOnly = await prisma.loan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Loan.
     * @param {LoanCreateArgs} args - Arguments to create a Loan.
     * @example
     * // Create one Loan
     * const Loan = await prisma.loan.create({
     *   data: {
     *     // ... data to create a Loan
     *   }
     * })
     * 
    **/
    create<T extends LoanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LoanCreateArgs<ExtArgs>>
    ): Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Loans.
     *     @param {LoanCreateManyArgs} args - Arguments to create many Loans.
     *     @example
     *     // Create many Loans
     *     const loan = await prisma.loan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Loan.
     * @param {LoanDeleteArgs} args - Arguments to delete one Loan.
     * @example
     * // Delete one Loan
     * const Loan = await prisma.loan.delete({
     *   where: {
     *     // ... filter to delete one Loan
     *   }
     * })
     * 
    **/
    delete<T extends LoanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LoanDeleteArgs<ExtArgs>>
    ): Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Loan.
     * @param {LoanUpdateArgs} args - Arguments to update one Loan.
     * @example
     * // Update one Loan
     * const loan = await prisma.loan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LoanUpdateArgs<ExtArgs>>
    ): Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Loans.
     * @param {LoanDeleteManyArgs} args - Arguments to filter Loans to delete.
     * @example
     * // Delete a few Loans
     * const { count } = await prisma.loan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loans
     * const loan = await prisma.loan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LoanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loan.
     * @param {LoanUpsertArgs} args - Arguments to update or create a Loan.
     * @example
     * // Update or create a Loan
     * const loan = await prisma.loan.upsert({
     *   create: {
     *     // ... data to create a Loan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loan we want to update
     *   }
     * })
    **/
    upsert<T extends LoanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LoanUpsertArgs<ExtArgs>>
    ): Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanCountArgs} args - Arguments to filter Loans to count.
     * @example
     * // Count the number of Loans
     * const count = await prisma.loan.count({
     *   where: {
     *     // ... the filter for the Loans we want to count
     *   }
     * })
    **/
    count<T extends LoanCountArgs>(
      args?: Subset<T, LoanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanAggregateArgs>(args: Subset<T, LoanAggregateArgs>): Prisma.PrismaPromise<GetLoanAggregateType<T>>

    /**
     * Group by Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanGroupByArgs['orderBy'] }
        : { orderBy?: LoanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Loan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    documents<T extends Loan$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Loan$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoanDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    applications<T extends Loan$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Loan$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Loan base type for findUnique actions
   */
  export type LoanFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan findUnique
   */
  export interface LoanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoanFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Loan findUniqueOrThrow
   */
  export type LoanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where: LoanWhereUniqueInput
  }


  /**
   * Loan base type for findFirst actions
   */
  export type LoanFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: Enumerable<LoanOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: Enumerable<LoanScalarFieldEnum>
  }

  /**
   * Loan findFirst
   */
  export interface LoanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoanFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Loan findFirstOrThrow
   */
  export type LoanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: Enumerable<LoanOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: Enumerable<LoanScalarFieldEnum>
  }


  /**
   * Loan findMany
   */
  export type LoanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: Enumerable<LoanOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    distinct?: Enumerable<LoanScalarFieldEnum>
  }


  /**
   * Loan create
   */
  export type LoanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The data needed to create a Loan.
     */
    data: XOR<LoanCreateInput, LoanUncheckedCreateInput>
  }


  /**
   * Loan createMany
   */
  export type LoanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loans.
     */
    data: Enumerable<LoanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Loan update
   */
  export type LoanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The data needed to update a Loan.
     */
    data: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
    /**
     * Choose, which Loan to update.
     */
    where: LoanWhereUniqueInput
  }


  /**
   * Loan updateMany
   */
  export type LoanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loans.
     */
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyInput>
    /**
     * Filter which Loans to update
     */
    where?: LoanWhereInput
  }


  /**
   * Loan upsert
   */
  export type LoanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The filter to search for the Loan to update in case it exists.
     */
    where: LoanWhereUniqueInput
    /**
     * In case the Loan found by the `where` argument doesn't exist, create a new Loan with this data.
     */
    create: XOR<LoanCreateInput, LoanUncheckedCreateInput>
    /**
     * In case the Loan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
  }


  /**
   * Loan delete
   */
  export type LoanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter which Loan to delete.
     */
    where: LoanWhereUniqueInput
  }


  /**
   * Loan deleteMany
   */
  export type LoanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loans to delete
     */
    where?: LoanWhereInput
  }


  /**
   * Loan.documents
   */
  export type Loan$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDocument
     */
    select?: LoanDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanDocumentInclude<ExtArgs> | null
    where?: LoanDocumentWhereInput
    orderBy?: Enumerable<LoanDocumentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LoanDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoanDocumentScalarFieldEnum>
  }


  /**
   * Loan.applications
   */
  export type Loan$applicationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: Enumerable<LoanApplicationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoanApplicationScalarFieldEnum>
  }


  /**
   * Loan without action
   */
  export type LoanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanInclude<ExtArgs> | null
  }



  /**
   * Model LoanApplication
   */


  export type AggregateLoanApplication = {
    _count: LoanApplicationCountAggregateOutputType | null
    _avg: LoanApplicationAvgAggregateOutputType | null
    _sum: LoanApplicationSumAggregateOutputType | null
    _min: LoanApplicationMinAggregateOutputType | null
    _max: LoanApplicationMaxAggregateOutputType | null
  }

  export type LoanApplicationAvgAggregateOutputType = {
    loanAmount: Decimal | null
    applicantAge: number | null
    userId: number | null
  }

  export type LoanApplicationSumAggregateOutputType = {
    loanAmount: Decimal | null
    applicantAge: number | null
    userId: number | null
  }

  export type LoanApplicationMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    loanAmount: Decimal | null
    loanStatus: LoanStatus | null
    applicantName: string | null
    applicantAge: number | null
    loanType: LoanType | null
    applicantGender: UserGender | null
    nationality: Nationality | null
    description: string | null
    salaried: boolean | null
    bankAccountId: string | null
    phone: string | null
    email: string | null
    address: string | null
    permanentAddress: string | null
    userId: number | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanApplicationMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    loanAmount: Decimal | null
    loanStatus: LoanStatus | null
    applicantName: string | null
    applicantAge: number | null
    loanType: LoanType | null
    applicantGender: UserGender | null
    nationality: Nationality | null
    description: string | null
    salaried: boolean | null
    bankAccountId: string | null
    phone: string | null
    email: string | null
    address: string | null
    permanentAddress: string | null
    userId: number | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanApplicationCountAggregateOutputType = {
    id: number
    loanId: number
    loanAmount: number
    loanStatus: number
    applicantName: number
    applicantAge: number
    loanType: number
    applicantGender: number
    nationality: number
    description: number
    salaried: number
    bankAccountId: number
    phone: number
    email: number
    address: number
    permanentAddress: number
    userId: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanApplicationAvgAggregateInputType = {
    loanAmount?: true
    applicantAge?: true
    userId?: true
  }

  export type LoanApplicationSumAggregateInputType = {
    loanAmount?: true
    applicantAge?: true
    userId?: true
  }

  export type LoanApplicationMinAggregateInputType = {
    id?: true
    loanId?: true
    loanAmount?: true
    loanStatus?: true
    applicantName?: true
    applicantAge?: true
    loanType?: true
    applicantGender?: true
    nationality?: true
    description?: true
    salaried?: true
    bankAccountId?: true
    phone?: true
    email?: true
    address?: true
    permanentAddress?: true
    userId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanApplicationMaxAggregateInputType = {
    id?: true
    loanId?: true
    loanAmount?: true
    loanStatus?: true
    applicantName?: true
    applicantAge?: true
    loanType?: true
    applicantGender?: true
    nationality?: true
    description?: true
    salaried?: true
    bankAccountId?: true
    phone?: true
    email?: true
    address?: true
    permanentAddress?: true
    userId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanApplicationCountAggregateInputType = {
    id?: true
    loanId?: true
    loanAmount?: true
    loanStatus?: true
    applicantName?: true
    applicantAge?: true
    loanType?: true
    applicantGender?: true
    nationality?: true
    description?: true
    salaried?: true
    bankAccountId?: true
    phone?: true
    email?: true
    address?: true
    permanentAddress?: true
    userId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanApplicationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanApplication to aggregate.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: Enumerable<LoanApplicationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanApplications
    **/
    _count?: true | LoanApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanApplicationMaxAggregateInputType
  }

  export type GetLoanApplicationAggregateType<T extends LoanApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanApplication[P]>
      : GetScalarType<T[P], AggregateLoanApplication[P]>
  }




  export type LoanApplicationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
    orderBy?: Enumerable<LoanApplicationOrderByWithAggregationInput>
    by: LoanApplicationScalarFieldEnum[]
    having?: LoanApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanApplicationCountAggregateInputType | true
    _avg?: LoanApplicationAvgAggregateInputType
    _sum?: LoanApplicationSumAggregateInputType
    _min?: LoanApplicationMinAggregateInputType
    _max?: LoanApplicationMaxAggregateInputType
  }


  export type LoanApplicationGroupByOutputType = {
    id: string
    loanId: string
    loanAmount: Decimal
    loanStatus: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone: string | null
    email: string | null
    address: string | null
    permanentAddress: string
    userId: number
    agentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoanApplicationCountAggregateOutputType | null
    _avg: LoanApplicationAvgAggregateOutputType | null
    _sum: LoanApplicationSumAggregateOutputType | null
    _min: LoanApplicationMinAggregateOutputType | null
    _max: LoanApplicationMaxAggregateOutputType | null
  }

  type GetLoanApplicationGroupByPayload<T extends LoanApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LoanApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], LoanApplicationGroupByOutputType[P]>
        }
      >
    >


  export type LoanApplicationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    loanAmount?: boolean
    loanStatus?: boolean
    applicantName?: boolean
    applicantAge?: boolean
    loanType?: boolean
    applicantGender?: boolean
    nationality?: boolean
    description?: boolean
    salaried?: boolean
    bankAccountId?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    permanentAddress?: boolean
    userId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanArgs<ExtArgs>
    documents?: boolean | LoanApplication$documentsArgs<ExtArgs>
    bankDetails?: boolean | BankDetailsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    agent?: boolean | AgentArgs<ExtArgs>
    _count?: boolean | LoanApplicationCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["loanApplication"]>

  export type LoanApplicationSelectScalar = {
    id?: boolean
    loanId?: boolean
    loanAmount?: boolean
    loanStatus?: boolean
    applicantName?: boolean
    applicantAge?: boolean
    loanType?: boolean
    applicantGender?: boolean
    nationality?: boolean
    description?: boolean
    salaried?: boolean
    bankAccountId?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    permanentAddress?: boolean
    userId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanApplicationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanArgs<ExtArgs>
    documents?: boolean | LoanApplication$documentsArgs<ExtArgs>
    bankDetails?: boolean | BankDetailsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    agent?: boolean | AgentArgs<ExtArgs>
    _count?: boolean | LoanApplicationCountOutputTypeArgs<ExtArgs>
  }


  type LoanApplicationGetPayload<S extends boolean | null | undefined | LoanApplicationArgs> = $Types.GetResult<LoanApplicationPayload, S>

  type LoanApplicationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LoanApplicationFindManyArgs, 'select' | 'include'> & {
      select?: LoanApplicationCountAggregateInputType | true
    }

  export interface LoanApplicationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanApplication'], meta: { name: 'LoanApplication' } }
    /**
     * Find zero or one LoanApplication that matches the filter.
     * @param {LoanApplicationFindUniqueArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoanApplicationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoanApplicationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LoanApplication'> extends True ? Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one LoanApplication that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LoanApplicationFindUniqueOrThrowArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoanApplicationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanApplicationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first LoanApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindFirstArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoanApplicationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoanApplicationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LoanApplication'> extends True ? Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first LoanApplication that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindFirstOrThrowArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoanApplicationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanApplicationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more LoanApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanApplications
     * const loanApplications = await prisma.loanApplication.findMany()
     * 
     * // Get first 10 LoanApplications
     * const loanApplications = await prisma.loanApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanApplicationWithIdOnly = await prisma.loanApplication.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoanApplicationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanApplicationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a LoanApplication.
     * @param {LoanApplicationCreateArgs} args - Arguments to create a LoanApplication.
     * @example
     * // Create one LoanApplication
     * const LoanApplication = await prisma.loanApplication.create({
     *   data: {
     *     // ... data to create a LoanApplication
     *   }
     * })
     * 
    **/
    create<T extends LoanApplicationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LoanApplicationCreateArgs<ExtArgs>>
    ): Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many LoanApplications.
     *     @param {LoanApplicationCreateManyArgs} args - Arguments to create many LoanApplications.
     *     @example
     *     // Create many LoanApplications
     *     const loanApplication = await prisma.loanApplication.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoanApplicationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanApplicationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LoanApplication.
     * @param {LoanApplicationDeleteArgs} args - Arguments to delete one LoanApplication.
     * @example
     * // Delete one LoanApplication
     * const LoanApplication = await prisma.loanApplication.delete({
     *   where: {
     *     // ... filter to delete one LoanApplication
     *   }
     * })
     * 
    **/
    delete<T extends LoanApplicationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LoanApplicationDeleteArgs<ExtArgs>>
    ): Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one LoanApplication.
     * @param {LoanApplicationUpdateArgs} args - Arguments to update one LoanApplication.
     * @example
     * // Update one LoanApplication
     * const loanApplication = await prisma.loanApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoanApplicationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LoanApplicationUpdateArgs<ExtArgs>>
    ): Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more LoanApplications.
     * @param {LoanApplicationDeleteManyArgs} args - Arguments to filter LoanApplications to delete.
     * @example
     * // Delete a few LoanApplications
     * const { count } = await prisma.loanApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoanApplicationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoanApplicationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanApplications
     * const loanApplication = await prisma.loanApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoanApplicationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LoanApplicationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoanApplication.
     * @param {LoanApplicationUpsertArgs} args - Arguments to update or create a LoanApplication.
     * @example
     * // Update or create a LoanApplication
     * const loanApplication = await prisma.loanApplication.upsert({
     *   create: {
     *     // ... data to create a LoanApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanApplication we want to update
     *   }
     * })
    **/
    upsert<T extends LoanApplicationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LoanApplicationUpsertArgs<ExtArgs>>
    ): Prisma__LoanApplicationClient<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of LoanApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationCountArgs} args - Arguments to filter LoanApplications to count.
     * @example
     * // Count the number of LoanApplications
     * const count = await prisma.loanApplication.count({
     *   where: {
     *     // ... the filter for the LoanApplications we want to count
     *   }
     * })
    **/
    count<T extends LoanApplicationCountArgs>(
      args?: Subset<T, LoanApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanApplicationAggregateArgs>(args: Subset<T, LoanApplicationAggregateArgs>): Prisma.PrismaPromise<GetLoanApplicationAggregateType<T>>

    /**
     * Group by LoanApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanApplicationGroupByArgs['orderBy'] }
        : { orderBy?: LoanApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoanApplicationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    loan<T extends LoanArgs<ExtArgs> = {}>(args?: Subset<T, LoanArgs<ExtArgs>>): Prisma__LoanClient<$Types.GetResult<LoanPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documents<T extends LoanApplication$documentsArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UploadedDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    bankDetails<T extends BankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, BankDetailsArgs<ExtArgs>>): Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    agent<T extends AgentArgs<ExtArgs> = {}>(args?: Subset<T, AgentArgs<ExtArgs>>): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LoanApplication base type for findUnique actions
   */
  export type LoanApplicationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication findUnique
   */
  export interface LoanApplicationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoanApplicationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoanApplication findUniqueOrThrow
   */
  export type LoanApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where: LoanApplicationWhereUniqueInput
  }


  /**
   * LoanApplication base type for findFirst actions
   */
  export type LoanApplicationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: Enumerable<LoanApplicationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanApplications.
     */
    distinct?: Enumerable<LoanApplicationScalarFieldEnum>
  }

  /**
   * LoanApplication findFirst
   */
  export interface LoanApplicationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoanApplicationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoanApplication findFirstOrThrow
   */
  export type LoanApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: Enumerable<LoanApplicationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanApplications.
     */
    distinct?: Enumerable<LoanApplicationScalarFieldEnum>
  }


  /**
   * LoanApplication findMany
   */
  export type LoanApplicationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplications to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: Enumerable<LoanApplicationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    distinct?: Enumerable<LoanApplicationScalarFieldEnum>
  }


  /**
   * LoanApplication create
   */
  export type LoanApplicationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanApplication.
     */
    data: XOR<LoanApplicationCreateInput, LoanApplicationUncheckedCreateInput>
  }


  /**
   * LoanApplication createMany
   */
  export type LoanApplicationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanApplications.
     */
    data: Enumerable<LoanApplicationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LoanApplication update
   */
  export type LoanApplicationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanApplication.
     */
    data: XOR<LoanApplicationUpdateInput, LoanApplicationUncheckedUpdateInput>
    /**
     * Choose, which LoanApplication to update.
     */
    where: LoanApplicationWhereUniqueInput
  }


  /**
   * LoanApplication updateMany
   */
  export type LoanApplicationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanApplications.
     */
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyInput>
    /**
     * Filter which LoanApplications to update
     */
    where?: LoanApplicationWhereInput
  }


  /**
   * LoanApplication upsert
   */
  export type LoanApplicationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanApplication to update in case it exists.
     */
    where: LoanApplicationWhereUniqueInput
    /**
     * In case the LoanApplication found by the `where` argument doesn't exist, create a new LoanApplication with this data.
     */
    create: XOR<LoanApplicationCreateInput, LoanApplicationUncheckedCreateInput>
    /**
     * In case the LoanApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanApplicationUpdateInput, LoanApplicationUncheckedUpdateInput>
  }


  /**
   * LoanApplication delete
   */
  export type LoanApplicationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter which LoanApplication to delete.
     */
    where: LoanApplicationWhereUniqueInput
  }


  /**
   * LoanApplication deleteMany
   */
  export type LoanApplicationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanApplications to delete
     */
    where?: LoanApplicationWhereInput
  }


  /**
   * LoanApplication.documents
   */
  export type LoanApplication$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedDocument
     */
    select?: UploadedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UploadedDocumentInclude<ExtArgs> | null
    where?: UploadedDocumentWhereInput
    orderBy?: Enumerable<UploadedDocumentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: UploadedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UploadedDocumentScalarFieldEnum>
  }


  /**
   * LoanApplication without action
   */
  export type LoanApplicationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
  }



  /**
   * Model BankDetails
   */


  export type AggregateBankDetails = {
    _count: BankDetailsCountAggregateOutputType | null
    _avg: BankDetailsAvgAggregateOutputType | null
    _sum: BankDetailsSumAggregateOutputType | null
    _min: BankDetailsMinAggregateOutputType | null
    _max: BankDetailsMaxAggregateOutputType | null
  }

  export type BankDetailsAvgAggregateOutputType = {
    userId: number | null
  }

  export type BankDetailsSumAggregateOutputType = {
    userId: number | null
  }

  export type BankDetailsMinAggregateOutputType = {
    id: string | null
    accountHolderName: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    bankBranch: string | null
    bankAccountType: BankAccountType | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailsMaxAggregateOutputType = {
    id: string | null
    accountHolderName: string | null
    bankName: string | null
    bankAccountNo: string | null
    bankIfsc: string | null
    bankBranch: string | null
    bankAccountType: BankAccountType | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailsCountAggregateOutputType = {
    id: number
    accountHolderName: number
    bankName: number
    bankAccountNo: number
    bankIfsc: number
    bankBranch: number
    bankAccountType: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankDetailsAvgAggregateInputType = {
    userId?: true
  }

  export type BankDetailsSumAggregateInputType = {
    userId?: true
  }

  export type BankDetailsMinAggregateInputType = {
    id?: true
    accountHolderName?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    bankBranch?: true
    bankAccountType?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailsMaxAggregateInputType = {
    id?: true
    accountHolderName?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    bankBranch?: true
    bankAccountType?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailsCountAggregateInputType = {
    id?: true
    accountHolderName?: true
    bankName?: true
    bankAccountNo?: true
    bankIfsc?: true
    bankBranch?: true
    bankAccountType?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankDetailsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to aggregate.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: Enumerable<BankDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankDetails
    **/
    _count?: true | BankDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankDetailsMaxAggregateInputType
  }

  export type GetBankDetailsAggregateType<T extends BankDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateBankDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankDetails[P]>
      : GetScalarType<T[P], AggregateBankDetails[P]>
  }




  export type BankDetailsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BankDetailsWhereInput
    orderBy?: Enumerable<BankDetailsOrderByWithAggregationInput>
    by: BankDetailsScalarFieldEnum[]
    having?: BankDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankDetailsCountAggregateInputType | true
    _avg?: BankDetailsAvgAggregateInputType
    _sum?: BankDetailsSumAggregateInputType
    _min?: BankDetailsMinAggregateInputType
    _max?: BankDetailsMaxAggregateInputType
  }


  export type BankDetailsGroupByOutputType = {
    id: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: BankDetailsCountAggregateOutputType | null
    _avg: BankDetailsAvgAggregateOutputType | null
    _sum: BankDetailsSumAggregateOutputType | null
    _min: BankDetailsMinAggregateOutputType | null
    _max: BankDetailsMaxAggregateOutputType | null
  }

  type GetBankDetailsGroupByPayload<T extends BankDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BankDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], BankDetailsGroupByOutputType[P]>
        }
      >
    >


  export type BankDetailsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountHolderName?: boolean
    bankName?: boolean
    bankAccountNo?: boolean
    bankIfsc?: boolean
    bankBranch?: boolean
    bankAccountType?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loans?: boolean | BankDetails$loansArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    _count?: boolean | BankDetailsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetails"]>

  export type BankDetailsSelectScalar = {
    id?: boolean
    accountHolderName?: boolean
    bankName?: boolean
    bankAccountNo?: boolean
    bankIfsc?: boolean
    bankBranch?: boolean
    bankAccountType?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankDetailsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    loans?: boolean | BankDetails$loansArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    _count?: boolean | BankDetailsCountOutputTypeArgs<ExtArgs>
  }


  type BankDetailsGetPayload<S extends boolean | null | undefined | BankDetailsArgs> = $Types.GetResult<BankDetailsPayload, S>

  type BankDetailsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BankDetailsFindManyArgs, 'select' | 'include'> & {
      select?: BankDetailsCountAggregateInputType | true
    }

  export interface BankDetailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankDetails'], meta: { name: 'BankDetails' } }
    /**
     * Find zero or one BankDetails that matches the filter.
     * @param {BankDetailsFindUniqueArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankDetailsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BankDetailsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BankDetails'> extends True ? Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BankDetails that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BankDetailsFindUniqueOrThrowArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankDetailsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDetailsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindFirstArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankDetailsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BankDetailsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BankDetails'> extends True ? Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BankDetails that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindFirstOrThrowArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankDetailsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDetailsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankDetails
     * const bankDetails = await prisma.bankDetails.findMany()
     * 
     * // Get first 10 BankDetails
     * const bankDetails = await prisma.bankDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankDetailsWithIdOnly = await prisma.bankDetails.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BankDetailsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDetailsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BankDetails.
     * @param {BankDetailsCreateArgs} args - Arguments to create a BankDetails.
     * @example
     * // Create one BankDetails
     * const BankDetails = await prisma.bankDetails.create({
     *   data: {
     *     // ... data to create a BankDetails
     *   }
     * })
     * 
    **/
    create<T extends BankDetailsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BankDetailsCreateArgs<ExtArgs>>
    ): Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BankDetails.
     *     @param {BankDetailsCreateManyArgs} args - Arguments to create many BankDetails.
     *     @example
     *     // Create many BankDetails
     *     const bankDetails = await prisma.bankDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BankDetailsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDetailsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BankDetails.
     * @param {BankDetailsDeleteArgs} args - Arguments to delete one BankDetails.
     * @example
     * // Delete one BankDetails
     * const BankDetails = await prisma.bankDetails.delete({
     *   where: {
     *     // ... filter to delete one BankDetails
     *   }
     * })
     * 
    **/
    delete<T extends BankDetailsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BankDetailsDeleteArgs<ExtArgs>>
    ): Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BankDetails.
     * @param {BankDetailsUpdateArgs} args - Arguments to update one BankDetails.
     * @example
     * // Update one BankDetails
     * const bankDetails = await prisma.bankDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankDetailsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BankDetailsUpdateArgs<ExtArgs>>
    ): Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BankDetails.
     * @param {BankDetailsDeleteManyArgs} args - Arguments to filter BankDetails to delete.
     * @example
     * // Delete a few BankDetails
     * const { count } = await prisma.bankDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankDetailsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDetailsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankDetails
     * const bankDetails = await prisma.bankDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankDetailsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BankDetailsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankDetails.
     * @param {BankDetailsUpsertArgs} args - Arguments to update or create a BankDetails.
     * @example
     * // Update or create a BankDetails
     * const bankDetails = await prisma.bankDetails.upsert({
     *   create: {
     *     // ... data to create a BankDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankDetails we want to update
     *   }
     * })
    **/
    upsert<T extends BankDetailsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BankDetailsUpsertArgs<ExtArgs>>
    ): Prisma__BankDetailsClient<$Types.GetResult<BankDetailsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsCountArgs} args - Arguments to filter BankDetails to count.
     * @example
     * // Count the number of BankDetails
     * const count = await prisma.bankDetails.count({
     *   where: {
     *     // ... the filter for the BankDetails we want to count
     *   }
     * })
    **/
    count<T extends BankDetailsCountArgs>(
      args?: Subset<T, BankDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankDetailsAggregateArgs>(args: Subset<T, BankDetailsAggregateArgs>): Prisma.PrismaPromise<GetBankDetailsAggregateType<T>>

    /**
     * Group by BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankDetailsGroupByArgs['orderBy'] }
        : { orderBy?: BankDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BankDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BankDetailsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    loans<T extends BankDetails$loansArgs<ExtArgs> = {}>(args?: Subset<T, BankDetails$loansArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BankDetails base type for findUnique actions
   */
  export type BankDetailsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails findUnique
   */
  export interface BankDetailsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BankDetailsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BankDetails findUniqueOrThrow
   */
  export type BankDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where: BankDetailsWhereUniqueInput
  }


  /**
   * BankDetails base type for findFirst actions
   */
  export type BankDetailsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: Enumerable<BankDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: Enumerable<BankDetailsScalarFieldEnum>
  }

  /**
   * BankDetails findFirst
   */
  export interface BankDetailsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BankDetailsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BankDetails findFirstOrThrow
   */
  export type BankDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: Enumerable<BankDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: Enumerable<BankDetailsScalarFieldEnum>
  }


  /**
   * BankDetails findMany
   */
  export type BankDetailsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: Enumerable<BankDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    distinct?: Enumerable<BankDetailsScalarFieldEnum>
  }


  /**
   * BankDetails create
   */
  export type BankDetailsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a BankDetails.
     */
    data: XOR<BankDetailsCreateInput, BankDetailsUncheckedCreateInput>
  }


  /**
   * BankDetails createMany
   */
  export type BankDetailsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankDetails.
     */
    data: Enumerable<BankDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BankDetails update
   */
  export type BankDetailsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a BankDetails.
     */
    data: XOR<BankDetailsUpdateInput, BankDetailsUncheckedUpdateInput>
    /**
     * Choose, which BankDetails to update.
     */
    where: BankDetailsWhereUniqueInput
  }


  /**
   * BankDetails updateMany
   */
  export type BankDetailsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailsUpdateManyMutationInput, BankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailsWhereInput
  }


  /**
   * BankDetails upsert
   */
  export type BankDetailsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the BankDetails to update in case it exists.
     */
    where: BankDetailsWhereUniqueInput
    /**
     * In case the BankDetails found by the `where` argument doesn't exist, create a new BankDetails with this data.
     */
    create: XOR<BankDetailsCreateInput, BankDetailsUncheckedCreateInput>
    /**
     * In case the BankDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankDetailsUpdateInput, BankDetailsUncheckedUpdateInput>
  }


  /**
   * BankDetails delete
   */
  export type BankDetailsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter which BankDetails to delete.
     */
    where: BankDetailsWhereUniqueInput
  }


  /**
   * BankDetails deleteMany
   */
  export type BankDetailsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to delete
     */
    where?: BankDetailsWhereInput
  }


  /**
   * BankDetails.loans
   */
  export type BankDetails$loansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: Enumerable<LoanApplicationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoanApplicationScalarFieldEnum>
  }


  /**
   * BankDetails without action
   */
  export type BankDetailsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankDetailsInclude<ExtArgs> | null
  }



  /**
   * Model Insurance
   */


  export type AggregateInsurance = {
    _count: InsuranceCountAggregateOutputType | null
    _avg: InsuranceAvgAggregateOutputType | null
    _sum: InsuranceSumAggregateOutputType | null
    _min: InsuranceMinAggregateOutputType | null
    _max: InsuranceMaxAggregateOutputType | null
  }

  export type InsuranceAvgAggregateOutputType = {
    userId: number | null
  }

  export type InsuranceSumAggregateOutputType = {
    userId: number | null
  }

  export type InsuranceMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    mobile: string | null
    email: string | null
    address: string | null
    dob: Date | null
    maritalStatus: string | null
    gender: UserGender | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsuranceMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    mobile: string | null
    email: string | null
    address: string | null
    dob: Date | null
    maritalStatus: string | null
    gender: UserGender | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsuranceCountAggregateOutputType = {
    id: number
    type: number
    name: number
    mobile: number
    email: number
    address: number
    dob: number
    maritalStatus: number
    gender: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsuranceAvgAggregateInputType = {
    userId?: true
  }

  export type InsuranceSumAggregateInputType = {
    userId?: true
  }

  export type InsuranceMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    mobile?: true
    email?: true
    address?: true
    dob?: true
    maritalStatus?: true
    gender?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsuranceMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    mobile?: true
    email?: true
    address?: true
    dob?: true
    maritalStatus?: true
    gender?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsuranceCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    mobile?: true
    email?: true
    address?: true
    dob?: true
    maritalStatus?: true
    gender?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsuranceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insurance to aggregate.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: Enumerable<InsuranceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insurances
    **/
    _count?: true | InsuranceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsuranceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsuranceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsuranceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsuranceMaxAggregateInputType
  }

  export type GetInsuranceAggregateType<T extends InsuranceAggregateArgs> = {
        [P in keyof T & keyof AggregateInsurance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsurance[P]>
      : GetScalarType<T[P], AggregateInsurance[P]>
  }




  export type InsuranceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InsuranceWhereInput
    orderBy?: Enumerable<InsuranceOrderByWithAggregationInput>
    by: InsuranceScalarFieldEnum[]
    having?: InsuranceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsuranceCountAggregateInputType | true
    _avg?: InsuranceAvgAggregateInputType
    _sum?: InsuranceSumAggregateInputType
    _min?: InsuranceMinAggregateInputType
    _max?: InsuranceMaxAggregateInputType
  }


  export type InsuranceGroupByOutputType = {
    id: string
    type: string
    name: string
    mobile: string
    email: string
    address: string
    dob: Date
    maritalStatus: string
    gender: UserGender
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: InsuranceCountAggregateOutputType | null
    _avg: InsuranceAvgAggregateOutputType | null
    _sum: InsuranceSumAggregateOutputType | null
    _min: InsuranceMinAggregateOutputType | null
    _max: InsuranceMaxAggregateOutputType | null
  }

  type GetInsuranceGroupByPayload<T extends InsuranceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InsuranceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsuranceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsuranceGroupByOutputType[P]>
            : GetScalarType<T[P], InsuranceGroupByOutputType[P]>
        }
      >
    >


  export type InsuranceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    mobile?: boolean
    email?: boolean
    address?: boolean
    dob?: boolean
    maritalStatus?: boolean
    gender?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["insurance"]>

  export type InsuranceSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    mobile?: boolean
    email?: boolean
    address?: boolean
    dob?: boolean
    maritalStatus?: boolean
    gender?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsuranceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type InsuranceGetPayload<S extends boolean | null | undefined | InsuranceArgs> = $Types.GetResult<InsurancePayload, S>

  type InsuranceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InsuranceFindManyArgs, 'select' | 'include'> & {
      select?: InsuranceCountAggregateInputType | true
    }

  export interface InsuranceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insurance'], meta: { name: 'Insurance' } }
    /**
     * Find zero or one Insurance that matches the filter.
     * @param {InsuranceFindUniqueArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InsuranceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InsuranceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Insurance'> extends True ? Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Insurance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InsuranceFindUniqueOrThrowArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InsuranceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Insurance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindFirstArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InsuranceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InsuranceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Insurance'> extends True ? Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Insurance that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindFirstOrThrowArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InsuranceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Insurances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insurances
     * const insurances = await prisma.insurance.findMany()
     * 
     * // Get first 10 Insurances
     * const insurances = await prisma.insurance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insuranceWithIdOnly = await prisma.insurance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InsuranceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Insurance.
     * @param {InsuranceCreateArgs} args - Arguments to create a Insurance.
     * @example
     * // Create one Insurance
     * const Insurance = await prisma.insurance.create({
     *   data: {
     *     // ... data to create a Insurance
     *   }
     * })
     * 
    **/
    create<T extends InsuranceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceCreateArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Insurances.
     *     @param {InsuranceCreateManyArgs} args - Arguments to create many Insurances.
     *     @example
     *     // Create many Insurances
     *     const insurance = await prisma.insurance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InsuranceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Insurance.
     * @param {InsuranceDeleteArgs} args - Arguments to delete one Insurance.
     * @example
     * // Delete one Insurance
     * const Insurance = await prisma.insurance.delete({
     *   where: {
     *     // ... filter to delete one Insurance
     *   }
     * })
     * 
    **/
    delete<T extends InsuranceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceDeleteArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Insurance.
     * @param {InsuranceUpdateArgs} args - Arguments to update one Insurance.
     * @example
     * // Update one Insurance
     * const insurance = await prisma.insurance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InsuranceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceUpdateArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Insurances.
     * @param {InsuranceDeleteManyArgs} args - Arguments to filter Insurances to delete.
     * @example
     * // Delete a few Insurances
     * const { count } = await prisma.insurance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InsuranceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InsuranceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insurances
     * const insurance = await prisma.insurance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InsuranceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insurance.
     * @param {InsuranceUpsertArgs} args - Arguments to update or create a Insurance.
     * @example
     * // Update or create a Insurance
     * const insurance = await prisma.insurance.upsert({
     *   create: {
     *     // ... data to create a Insurance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insurance we want to update
     *   }
     * })
    **/
    upsert<T extends InsuranceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InsuranceUpsertArgs<ExtArgs>>
    ): Prisma__InsuranceClient<$Types.GetResult<InsurancePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Insurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCountArgs} args - Arguments to filter Insurances to count.
     * @example
     * // Count the number of Insurances
     * const count = await prisma.insurance.count({
     *   where: {
     *     // ... the filter for the Insurances we want to count
     *   }
     * })
    **/
    count<T extends InsuranceCountArgs>(
      args?: Subset<T, InsuranceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsuranceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsuranceAggregateArgs>(args: Subset<T, InsuranceAggregateArgs>): Prisma.PrismaPromise<GetInsuranceAggregateType<T>>

    /**
     * Group by Insurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsuranceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsuranceGroupByArgs['orderBy'] }
        : { orderBy?: InsuranceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsuranceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsuranceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Insurance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InsuranceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Insurance base type for findUnique actions
   */
  export type InsuranceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where: InsuranceWhereUniqueInput
  }

  /**
   * Insurance findUnique
   */
  export interface InsuranceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InsuranceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Insurance findUniqueOrThrow
   */
  export type InsuranceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where: InsuranceWhereUniqueInput
  }


  /**
   * Insurance base type for findFirst actions
   */
  export type InsuranceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: Enumerable<InsuranceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insurances.
     */
    distinct?: Enumerable<InsuranceScalarFieldEnum>
  }

  /**
   * Insurance findFirst
   */
  export interface InsuranceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InsuranceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Insurance findFirstOrThrow
   */
  export type InsuranceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: Enumerable<InsuranceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insurances.
     */
    distinct?: Enumerable<InsuranceScalarFieldEnum>
  }


  /**
   * Insurance findMany
   */
  export type InsuranceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurances to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: Enumerable<InsuranceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    distinct?: Enumerable<InsuranceScalarFieldEnum>
  }


  /**
   * Insurance create
   */
  export type InsuranceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The data needed to create a Insurance.
     */
    data: XOR<InsuranceCreateInput, InsuranceUncheckedCreateInput>
  }


  /**
   * Insurance createMany
   */
  export type InsuranceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insurances.
     */
    data: Enumerable<InsuranceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Insurance update
   */
  export type InsuranceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The data needed to update a Insurance.
     */
    data: XOR<InsuranceUpdateInput, InsuranceUncheckedUpdateInput>
    /**
     * Choose, which Insurance to update.
     */
    where: InsuranceWhereUniqueInput
  }


  /**
   * Insurance updateMany
   */
  export type InsuranceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insurances.
     */
    data: XOR<InsuranceUpdateManyMutationInput, InsuranceUncheckedUpdateManyInput>
    /**
     * Filter which Insurances to update
     */
    where?: InsuranceWhereInput
  }


  /**
   * Insurance upsert
   */
  export type InsuranceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The filter to search for the Insurance to update in case it exists.
     */
    where: InsuranceWhereUniqueInput
    /**
     * In case the Insurance found by the `where` argument doesn't exist, create a new Insurance with this data.
     */
    create: XOR<InsuranceCreateInput, InsuranceUncheckedCreateInput>
    /**
     * In case the Insurance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsuranceUpdateInput, InsuranceUncheckedUpdateInput>
  }


  /**
   * Insurance delete
   */
  export type InsuranceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter which Insurance to delete.
     */
    where: InsuranceWhereUniqueInput
  }


  /**
   * Insurance deleteMany
   */
  export type InsuranceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insurances to delete
     */
    where?: InsuranceWhereInput
  }


  /**
   * Insurance without action
   */
  export type InsuranceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InsuranceInclude<ExtArgs> | null
  }



  /**
   * Model Client
   */


  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    userId: number | null
  }

  export type ClientSumAggregateOutputType = {
    userId: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    userId: number | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    userId?: true
  }

  export type ClientSumAggregateInputType = {
    userId?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: Enumerable<ClientOrderByWithAggregationInput>
    by: ClientScalarFieldEnum[]
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }


  export type ClientGroupByOutputType = {
    id: string
    userId: number
    agentId: string
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    agent?: boolean | AgentArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    agent?: boolean | AgentArgs<ExtArgs>
  }


  type ClientGetPayload<S extends boolean | null | undefined | ClientArgs> = $Types.GetResult<ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Client'> extends True ? Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Client'> extends True ? Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientCreateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Clients.
     *     @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    agent<T extends AgentArgs<ExtArgs> = {}>(args?: Subset<T, AgentArgs<ExtArgs>>): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Client base type for findUnique actions
   */
  export type ClientFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUnique
   */
  export interface ClientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ClientFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client base type for findFirst actions
   */
  export type ClientFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: Enumerable<ClientScalarFieldEnum>
  }

  /**
   * Client findFirst
   */
  export interface ClientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ClientFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }


  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: Enumerable<ClientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }


  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }


  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }


  /**
   * Client without action
   */
  export type ClientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
  }



  /**
   * Model Agent
   */


  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    userId: number | null
  }

  export type AgentSumAggregateOutputType = {
    userId: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    userId?: true
  }

  export type AgentSumAggregateInputType = {
    userId?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: Enumerable<AgentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: Enumerable<AgentOrderByWithAggregationInput>
    by: AgentScalarFieldEnum[]
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }


  export type AgentGroupByOutputType = {
    id: string
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clients?: boolean | Agent$clientsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    loans?: boolean | Agent$loansArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    clients?: boolean | Agent$clientsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    loans?: boolean | Agent$loansArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeArgs<ExtArgs>
  }


  type AgentGetPayload<S extends boolean | null | undefined | AgentArgs> = $Types.GetResult<AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AgentFindManyArgs, 'select' | 'include'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Agent'> extends True ? Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Agent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Agent'> extends True ? Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Agent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AgentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
    **/
    create<T extends AgentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgentCreateArgs<ExtArgs>>
    ): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Agents.
     *     @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     *     @example
     *     // Create many Agents
     *     const agent = await prisma.agent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
    **/
    delete<T extends AgentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>
    ): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>
    ): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
    **/
    upsert<T extends AgentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>
    ): Prisma__AgentClient<$Types.GetResult<AgentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    clients<T extends Agent$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    loans<T extends Agent$loansArgs<ExtArgs> = {}>(args?: Subset<T, Agent$loansArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoanApplicationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Agent base type for findUnique actions
   */
  export type AgentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUnique
   */
  export interface AgentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }


  /**
   * Agent base type for findFirst actions
   */
  export type AgentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: Enumerable<AgentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: Enumerable<AgentScalarFieldEnum>
  }

  /**
   * Agent findFirst
   */
  export interface AgentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: Enumerable<AgentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: Enumerable<AgentScalarFieldEnum>
  }


  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: Enumerable<AgentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: Enumerable<AgentScalarFieldEnum>
  }


  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }


  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: Enumerable<AgentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }


  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
  }


  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }


  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }


  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
  }


  /**
   * Agent.clients
   */
  export type Agent$clientsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: Enumerable<ClientOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Agent.loans
   */
  export type Agent$loansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: Enumerable<LoanApplicationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoanApplicationScalarFieldEnum>
  }


  /**
   * Agent without action
   */
  export type AgentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentInclude<ExtArgs> | null
  }



  /**
   * Model Visitor
   */


  export type AggregateVisitor = {
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  export type VisitorAvgAggregateOutputType = {
    id: number | null
    count: number | null
  }

  export type VisitorSumAggregateOutputType = {
    id: number | null
    count: number | null
  }

  export type VisitorMinAggregateOutputType = {
    id: number | null
    count: number | null
    createdAt: Date | null
  }

  export type VisitorMaxAggregateOutputType = {
    id: number | null
    count: number | null
    createdAt: Date | null
  }

  export type VisitorCountAggregateOutputType = {
    id: number
    count: number
    createdAt: number
    _all: number
  }


  export type VisitorAvgAggregateInputType = {
    id?: true
    count?: true
  }

  export type VisitorSumAggregateInputType = {
    id?: true
    count?: true
  }

  export type VisitorMinAggregateInputType = {
    id?: true
    count?: true
    createdAt?: true
  }

  export type VisitorMaxAggregateInputType = {
    id?: true
    count?: true
    createdAt?: true
  }

  export type VisitorCountAggregateInputType = {
    id?: true
    count?: true
    createdAt?: true
    _all?: true
  }

  export type VisitorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitor to aggregate.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: Enumerable<VisitorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visitors
    **/
    _count?: true | VisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorMaxAggregateInputType
  }

  export type GetVisitorAggregateType<T extends VisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitor[P]>
      : GetScalarType<T[P], AggregateVisitor[P]>
  }




  export type VisitorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
    orderBy?: Enumerable<VisitorOrderByWithAggregationInput>
    by: VisitorScalarFieldEnum[]
    having?: VisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorCountAggregateInputType | true
    _avg?: VisitorAvgAggregateInputType
    _sum?: VisitorSumAggregateInputType
    _min?: VisitorMinAggregateInputType
    _max?: VisitorMaxAggregateInputType
  }


  export type VisitorGroupByOutputType = {
    id: number
    count: number
    createdAt: Date
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  type GetVisitorGroupByPayload<T extends VisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorGroupByOutputType[P]>
        }
      >
    >


  export type VisitorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    count?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectScalar = {
    id?: boolean
    count?: boolean
    createdAt?: boolean
  }


  type VisitorGetPayload<S extends boolean | null | undefined | VisitorArgs> = $Types.GetResult<VisitorPayload, S>

  type VisitorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<VisitorFindManyArgs, 'select' | 'include'> & {
      select?: VisitorCountAggregateInputType | true
    }

  export interface VisitorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visitor'], meta: { name: 'Visitor' } }
    /**
     * Find zero or one Visitor that matches the filter.
     * @param {VisitorFindUniqueArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VisitorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VisitorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Visitor'> extends True ? Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Visitor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VisitorFindUniqueOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VisitorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Visitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VisitorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VisitorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Visitor'> extends True ? Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Visitor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VisitorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitors
     * const visitors = await prisma.visitor.findMany()
     * 
     * // Get first 10 Visitors
     * const visitors = await prisma.visitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorWithIdOnly = await prisma.visitor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VisitorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Visitor.
     * @param {VisitorCreateArgs} args - Arguments to create a Visitor.
     * @example
     * // Create one Visitor
     * const Visitor = await prisma.visitor.create({
     *   data: {
     *     // ... data to create a Visitor
     *   }
     * })
     * 
    **/
    create<T extends VisitorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VisitorCreateArgs<ExtArgs>>
    ): Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Visitors.
     *     @param {VisitorCreateManyArgs} args - Arguments to create many Visitors.
     *     @example
     *     // Create many Visitors
     *     const visitor = await prisma.visitor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VisitorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitor.
     * @param {VisitorDeleteArgs} args - Arguments to delete one Visitor.
     * @example
     * // Delete one Visitor
     * const Visitor = await prisma.visitor.delete({
     *   where: {
     *     // ... filter to delete one Visitor
     *   }
     * })
     * 
    **/
    delete<T extends VisitorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VisitorDeleteArgs<ExtArgs>>
    ): Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Visitor.
     * @param {VisitorUpdateArgs} args - Arguments to update one Visitor.
     * @example
     * // Update one Visitor
     * const visitor = await prisma.visitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VisitorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VisitorUpdateArgs<ExtArgs>>
    ): Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Visitors.
     * @param {VisitorDeleteManyArgs} args - Arguments to filter Visitors to delete.
     * @example
     * // Delete a few Visitors
     * const { count } = await prisma.visitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VisitorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VisitorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VisitorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitor.
     * @param {VisitorUpsertArgs} args - Arguments to update or create a Visitor.
     * @example
     * // Update or create a Visitor
     * const visitor = await prisma.visitor.upsert({
     *   create: {
     *     // ... data to create a Visitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitor we want to update
     *   }
     * })
    **/
    upsert<T extends VisitorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VisitorUpsertArgs<ExtArgs>>
    ): Prisma__VisitorClient<$Types.GetResult<VisitorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorCountArgs} args - Arguments to filter Visitors to count.
     * @example
     * // Count the number of Visitors
     * const count = await prisma.visitor.count({
     *   where: {
     *     // ... the filter for the Visitors we want to count
     *   }
     * })
    **/
    count<T extends VisitorCountArgs>(
      args?: Subset<T, VisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorAggregateArgs>(args: Subset<T, VisitorAggregateArgs>): Prisma.PrismaPromise<GetVisitorAggregateType<T>>

    /**
     * Group by Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorGroupByArgs['orderBy'] }
        : { orderBy?: VisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Visitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VisitorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Visitor base type for findUnique actions
   */
  export type VisitorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findUnique
   */
  export interface VisitorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VisitorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Visitor findUniqueOrThrow
   */
  export type VisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }


  /**
   * Visitor base type for findFirst actions
   */
  export type VisitorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: Enumerable<VisitorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: Enumerable<VisitorScalarFieldEnum>
  }

  /**
   * Visitor findFirst
   */
  export interface VisitorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VisitorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Visitor findFirstOrThrow
   */
  export type VisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: Enumerable<VisitorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: Enumerable<VisitorScalarFieldEnum>
  }


  /**
   * Visitor findMany
   */
  export type VisitorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitors to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: Enumerable<VisitorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    distinct?: Enumerable<VisitorScalarFieldEnum>
  }


  /**
   * Visitor create
   */
  export type VisitorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * The data needed to create a Visitor.
     */
    data?: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
  }


  /**
   * Visitor createMany
   */
  export type VisitorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visitors.
     */
    data: Enumerable<VisitorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Visitor update
   */
  export type VisitorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * The data needed to update a Visitor.
     */
    data: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    /**
     * Choose, which Visitor to update.
     */
    where: VisitorWhereUniqueInput
  }


  /**
   * Visitor updateMany
   */
  export type VisitorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
  }


  /**
   * Visitor upsert
   */
  export type VisitorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * The filter to search for the Visitor to update in case it exists.
     */
    where: VisitorWhereUniqueInput
    /**
     * In case the Visitor found by the `where` argument doesn't exist, create a new Visitor with this data.
     */
    create: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    /**
     * In case the Visitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
  }


  /**
   * Visitor delete
   */
  export type VisitorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter which Visitor to delete.
     */
    where: VisitorWhereUniqueInput
  }


  /**
   * Visitor deleteMany
   */
  export type VisitorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitors to delete
     */
    where?: VisitorWhereInput
  }


  /**
   * Visitor without action
   */
  export type VisitorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
  }



  /**
   * Model RegisterStartup
   */


  export type AggregateRegisterStartup = {
    _count: RegisterStartupCountAggregateOutputType | null
    _avg: RegisterStartupAvgAggregateOutputType | null
    _sum: RegisterStartupSumAggregateOutputType | null
    _min: RegisterStartupMinAggregateOutputType | null
    _max: RegisterStartupMaxAggregateOutputType | null
  }

  export type RegisterStartupAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RegisterStartupSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RegisterStartupMinAggregateOutputType = {
    id: number | null
    title: string | null
    image: string | null
    userId: number | null
    categories: StartupCategory | null
  }

  export type RegisterStartupMaxAggregateOutputType = {
    id: number | null
    title: string | null
    image: string | null
    userId: number | null
    categories: StartupCategory | null
  }

  export type RegisterStartupCountAggregateOutputType = {
    id: number
    title: number
    image: number
    userId: number
    categories: number
    _all: number
  }


  export type RegisterStartupAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RegisterStartupSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RegisterStartupMinAggregateInputType = {
    id?: true
    title?: true
    image?: true
    userId?: true
    categories?: true
  }

  export type RegisterStartupMaxAggregateInputType = {
    id?: true
    title?: true
    image?: true
    userId?: true
    categories?: true
  }

  export type RegisterStartupCountAggregateInputType = {
    id?: true
    title?: true
    image?: true
    userId?: true
    categories?: true
    _all?: true
  }

  export type RegisterStartupAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisterStartup to aggregate.
     */
    where?: RegisterStartupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterStartups to fetch.
     */
    orderBy?: Enumerable<RegisterStartupOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegisterStartupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterStartups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterStartups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegisterStartups
    **/
    _count?: true | RegisterStartupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegisterStartupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegisterStartupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegisterStartupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegisterStartupMaxAggregateInputType
  }

  export type GetRegisterStartupAggregateType<T extends RegisterStartupAggregateArgs> = {
        [P in keyof T & keyof AggregateRegisterStartup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegisterStartup[P]>
      : GetScalarType<T[P], AggregateRegisterStartup[P]>
  }




  export type RegisterStartupGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RegisterStartupWhereInput
    orderBy?: Enumerable<RegisterStartupOrderByWithAggregationInput>
    by: RegisterStartupScalarFieldEnum[]
    having?: RegisterStartupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegisterStartupCountAggregateInputType | true
    _avg?: RegisterStartupAvgAggregateInputType
    _sum?: RegisterStartupSumAggregateInputType
    _min?: RegisterStartupMinAggregateInputType
    _max?: RegisterStartupMaxAggregateInputType
  }


  export type RegisterStartupGroupByOutputType = {
    id: number
    title: string
    image: string
    userId: number
    categories: StartupCategory
    _count: RegisterStartupCountAggregateOutputType | null
    _avg: RegisterStartupAvgAggregateOutputType | null
    _sum: RegisterStartupSumAggregateOutputType | null
    _min: RegisterStartupMinAggregateOutputType | null
    _max: RegisterStartupMaxAggregateOutputType | null
  }

  type GetRegisterStartupGroupByPayload<T extends RegisterStartupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RegisterStartupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegisterStartupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegisterStartupGroupByOutputType[P]>
            : GetScalarType<T[P], RegisterStartupGroupByOutputType[P]>
        }
      >
    >


  export type RegisterStartupSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    userId?: boolean
    categories?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["registerStartup"]>

  export type RegisterStartupSelectScalar = {
    id?: boolean
    title?: boolean
    image?: boolean
    userId?: boolean
    categories?: boolean
  }

  export type RegisterStartupInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type RegisterStartupGetPayload<S extends boolean | null | undefined | RegisterStartupArgs> = $Types.GetResult<RegisterStartupPayload, S>

  type RegisterStartupCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RegisterStartupFindManyArgs, 'select' | 'include'> & {
      select?: RegisterStartupCountAggregateInputType | true
    }

  export interface RegisterStartupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegisterStartup'], meta: { name: 'RegisterStartup' } }
    /**
     * Find zero or one RegisterStartup that matches the filter.
     * @param {RegisterStartupFindUniqueArgs} args - Arguments to find a RegisterStartup
     * @example
     * // Get one RegisterStartup
     * const registerStartup = await prisma.registerStartup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegisterStartupFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RegisterStartupFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RegisterStartup'> extends True ? Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one RegisterStartup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RegisterStartupFindUniqueOrThrowArgs} args - Arguments to find a RegisterStartup
     * @example
     * // Get one RegisterStartup
     * const registerStartup = await prisma.registerStartup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegisterStartupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegisterStartupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first RegisterStartup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterStartupFindFirstArgs} args - Arguments to find a RegisterStartup
     * @example
     * // Get one RegisterStartup
     * const registerStartup = await prisma.registerStartup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegisterStartupFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RegisterStartupFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RegisterStartup'> extends True ? Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first RegisterStartup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterStartupFindFirstOrThrowArgs} args - Arguments to find a RegisterStartup
     * @example
     * // Get one RegisterStartup
     * const registerStartup = await prisma.registerStartup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegisterStartupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegisterStartupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more RegisterStartups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterStartupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegisterStartups
     * const registerStartups = await prisma.registerStartup.findMany()
     * 
     * // Get first 10 RegisterStartups
     * const registerStartups = await prisma.registerStartup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registerStartupWithIdOnly = await prisma.registerStartup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegisterStartupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegisterStartupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a RegisterStartup.
     * @param {RegisterStartupCreateArgs} args - Arguments to create a RegisterStartup.
     * @example
     * // Create one RegisterStartup
     * const RegisterStartup = await prisma.registerStartup.create({
     *   data: {
     *     // ... data to create a RegisterStartup
     *   }
     * })
     * 
    **/
    create<T extends RegisterStartupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RegisterStartupCreateArgs<ExtArgs>>
    ): Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many RegisterStartups.
     *     @param {RegisterStartupCreateManyArgs} args - Arguments to create many RegisterStartups.
     *     @example
     *     // Create many RegisterStartups
     *     const registerStartup = await prisma.registerStartup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegisterStartupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegisterStartupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RegisterStartup.
     * @param {RegisterStartupDeleteArgs} args - Arguments to delete one RegisterStartup.
     * @example
     * // Delete one RegisterStartup
     * const RegisterStartup = await prisma.registerStartup.delete({
     *   where: {
     *     // ... filter to delete one RegisterStartup
     *   }
     * })
     * 
    **/
    delete<T extends RegisterStartupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RegisterStartupDeleteArgs<ExtArgs>>
    ): Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one RegisterStartup.
     * @param {RegisterStartupUpdateArgs} args - Arguments to update one RegisterStartup.
     * @example
     * // Update one RegisterStartup
     * const registerStartup = await prisma.registerStartup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegisterStartupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RegisterStartupUpdateArgs<ExtArgs>>
    ): Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more RegisterStartups.
     * @param {RegisterStartupDeleteManyArgs} args - Arguments to filter RegisterStartups to delete.
     * @example
     * // Delete a few RegisterStartups
     * const { count } = await prisma.registerStartup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegisterStartupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegisterStartupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisterStartups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterStartupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegisterStartups
     * const registerStartup = await prisma.registerStartup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegisterStartupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RegisterStartupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RegisterStartup.
     * @param {RegisterStartupUpsertArgs} args - Arguments to update or create a RegisterStartup.
     * @example
     * // Update or create a RegisterStartup
     * const registerStartup = await prisma.registerStartup.upsert({
     *   create: {
     *     // ... data to create a RegisterStartup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegisterStartup we want to update
     *   }
     * })
    **/
    upsert<T extends RegisterStartupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RegisterStartupUpsertArgs<ExtArgs>>
    ): Prisma__RegisterStartupClient<$Types.GetResult<RegisterStartupPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of RegisterStartups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterStartupCountArgs} args - Arguments to filter RegisterStartups to count.
     * @example
     * // Count the number of RegisterStartups
     * const count = await prisma.registerStartup.count({
     *   where: {
     *     // ... the filter for the RegisterStartups we want to count
     *   }
     * })
    **/
    count<T extends RegisterStartupCountArgs>(
      args?: Subset<T, RegisterStartupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegisterStartupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegisterStartup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterStartupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegisterStartupAggregateArgs>(args: Subset<T, RegisterStartupAggregateArgs>): Prisma.PrismaPromise<GetRegisterStartupAggregateType<T>>

    /**
     * Group by RegisterStartup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterStartupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegisterStartupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegisterStartupGroupByArgs['orderBy'] }
        : { orderBy?: RegisterStartupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegisterStartupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegisterStartupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RegisterStartup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RegisterStartupClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RegisterStartup base type for findUnique actions
   */
  export type RegisterStartupFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * Filter, which RegisterStartup to fetch.
     */
    where: RegisterStartupWhereUniqueInput
  }

  /**
   * RegisterStartup findUnique
   */
  export interface RegisterStartupFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RegisterStartupFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RegisterStartup findUniqueOrThrow
   */
  export type RegisterStartupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * Filter, which RegisterStartup to fetch.
     */
    where: RegisterStartupWhereUniqueInput
  }


  /**
   * RegisterStartup base type for findFirst actions
   */
  export type RegisterStartupFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * Filter, which RegisterStartup to fetch.
     */
    where?: RegisterStartupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterStartups to fetch.
     */
    orderBy?: Enumerable<RegisterStartupOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisterStartups.
     */
    cursor?: RegisterStartupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterStartups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterStartups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisterStartups.
     */
    distinct?: Enumerable<RegisterStartupScalarFieldEnum>
  }

  /**
   * RegisterStartup findFirst
   */
  export interface RegisterStartupFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RegisterStartupFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RegisterStartup findFirstOrThrow
   */
  export type RegisterStartupFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * Filter, which RegisterStartup to fetch.
     */
    where?: RegisterStartupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterStartups to fetch.
     */
    orderBy?: Enumerable<RegisterStartupOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisterStartups.
     */
    cursor?: RegisterStartupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterStartups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterStartups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisterStartups.
     */
    distinct?: Enumerable<RegisterStartupScalarFieldEnum>
  }


  /**
   * RegisterStartup findMany
   */
  export type RegisterStartupFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * Filter, which RegisterStartups to fetch.
     */
    where?: RegisterStartupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterStartups to fetch.
     */
    orderBy?: Enumerable<RegisterStartupOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegisterStartups.
     */
    cursor?: RegisterStartupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterStartups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterStartups.
     */
    skip?: number
    distinct?: Enumerable<RegisterStartupScalarFieldEnum>
  }


  /**
   * RegisterStartup create
   */
  export type RegisterStartupCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * The data needed to create a RegisterStartup.
     */
    data: XOR<RegisterStartupCreateInput, RegisterStartupUncheckedCreateInput>
  }


  /**
   * RegisterStartup createMany
   */
  export type RegisterStartupCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegisterStartups.
     */
    data: Enumerable<RegisterStartupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RegisterStartup update
   */
  export type RegisterStartupUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * The data needed to update a RegisterStartup.
     */
    data: XOR<RegisterStartupUpdateInput, RegisterStartupUncheckedUpdateInput>
    /**
     * Choose, which RegisterStartup to update.
     */
    where: RegisterStartupWhereUniqueInput
  }


  /**
   * RegisterStartup updateMany
   */
  export type RegisterStartupUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegisterStartups.
     */
    data: XOR<RegisterStartupUpdateManyMutationInput, RegisterStartupUncheckedUpdateManyInput>
    /**
     * Filter which RegisterStartups to update
     */
    where?: RegisterStartupWhereInput
  }


  /**
   * RegisterStartup upsert
   */
  export type RegisterStartupUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * The filter to search for the RegisterStartup to update in case it exists.
     */
    where: RegisterStartupWhereUniqueInput
    /**
     * In case the RegisterStartup found by the `where` argument doesn't exist, create a new RegisterStartup with this data.
     */
    create: XOR<RegisterStartupCreateInput, RegisterStartupUncheckedCreateInput>
    /**
     * In case the RegisterStartup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegisterStartupUpdateInput, RegisterStartupUncheckedUpdateInput>
  }


  /**
   * RegisterStartup delete
   */
  export type RegisterStartupDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
    /**
     * Filter which RegisterStartup to delete.
     */
    where: RegisterStartupWhereUniqueInput
  }


  /**
   * RegisterStartup deleteMany
   */
  export type RegisterStartupDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisterStartups to delete
     */
    where?: RegisterStartupWhereInput
  }


  /**
   * RegisterStartup without action
   */
  export type RegisterStartupArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterStartup
     */
    select?: RegisterStartupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegisterStartupInclude<ExtArgs> | null
  }



  /**
   * Model ContactUs
   */


  export type AggregateContactUs = {
    _count: ContactUsCountAggregateOutputType | null
    _avg: ContactUsAvgAggregateOutputType | null
    _sum: ContactUsSumAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  export type ContactUsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ContactUsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ContactUsMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    message: string | null
    phoneNumber: string | null
    userId: number | null
  }

  export type ContactUsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    message: string | null
    phoneNumber: string | null
    userId: number | null
  }

  export type ContactUsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    message: number
    phoneNumber: number
    userId: number
    _all: number
  }


  export type ContactUsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ContactUsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ContactUsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    phoneNumber?: true
    userId?: true
  }

  export type ContactUsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    phoneNumber?: true
    userId?: true
  }

  export type ContactUsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    phoneNumber?: true
    userId?: true
    _all?: true
  }

  export type ContactUsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactUs to aggregate.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: Enumerable<ContactUsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contactuses
    **/
    _count?: true | ContactUsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactUsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactUsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUsMaxAggregateInputType
  }

  export type GetContactUsAggregateType<T extends ContactUsAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUs[P]>
      : GetScalarType<T[P], AggregateContactUs[P]>
  }




  export type ContactUsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContactUsWhereInput
    orderBy?: Enumerable<ContactUsOrderByWithAggregationInput>
    by: ContactUsScalarFieldEnum[]
    having?: ContactUsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUsCountAggregateInputType | true
    _avg?: ContactUsAvgAggregateInputType
    _sum?: ContactUsSumAggregateInputType
    _min?: ContactUsMinAggregateInputType
    _max?: ContactUsMaxAggregateInputType
  }


  export type ContactUsGroupByOutputType = {
    id: number
    name: string
    email: string
    message: string
    phoneNumber: string
    userId: number
    _count: ContactUsCountAggregateOutputType | null
    _avg: ContactUsAvgAggregateOutputType | null
    _sum: ContactUsSumAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  type GetContactUsGroupByPayload<T extends ContactUsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ContactUsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
        }
      >
    >


  export type ContactUsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    message?: boolean
    phoneNumber?: boolean
    userId?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["contactUs"]>

  export type ContactUsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    message?: boolean
    phoneNumber?: boolean
    userId?: boolean
  }

  export type ContactUsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type ContactUsGetPayload<S extends boolean | null | undefined | ContactUsArgs> = $Types.GetResult<ContactUsPayload, S>

  type ContactUsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContactUsFindManyArgs, 'select' | 'include'> & {
      select?: ContactUsCountAggregateInputType | true
    }

  export interface ContactUsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactUs'], meta: { name: 'ContactUs' } }
    /**
     * Find zero or one ContactUs that matches the filter.
     * @param {ContactUsFindUniqueArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactUsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContactUsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ContactUs'> extends True ? Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ContactUs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactUsFindUniqueOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactUsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ContactUs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactUsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContactUsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ContactUs'> extends True ? Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ContactUs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactUsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Contactuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactuses
     * const contactuses = await prisma.contactUs.findMany()
     * 
     * // Get first 10 Contactuses
     * const contactuses = await prisma.contactUs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContactUsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ContactUs.
     * @param {ContactUsCreateArgs} args - Arguments to create a ContactUs.
     * @example
     * // Create one ContactUs
     * const ContactUs = await prisma.contactUs.create({
     *   data: {
     *     // ... data to create a ContactUs
     *   }
     * })
     * 
    **/
    create<T extends ContactUsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsCreateArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Contactuses.
     *     @param {ContactUsCreateManyArgs} args - Arguments to create many Contactuses.
     *     @example
     *     // Create many Contactuses
     *     const contactUs = await prisma.contactUs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactUsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactUs.
     * @param {ContactUsDeleteArgs} args - Arguments to delete one ContactUs.
     * @example
     * // Delete one ContactUs
     * const ContactUs = await prisma.contactUs.delete({
     *   where: {
     *     // ... filter to delete one ContactUs
     *   }
     * })
     * 
    **/
    delete<T extends ContactUsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsDeleteArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ContactUs.
     * @param {ContactUsUpdateArgs} args - Arguments to update one ContactUs.
     * @example
     * // Update one ContactUs
     * const contactUs = await prisma.contactUs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactUsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsUpdateArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Contactuses.
     * @param {ContactUsDeleteManyArgs} args - Arguments to filter Contactuses to delete.
     * @example
     * // Delete a few Contactuses
     * const { count } = await prisma.contactUs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactUsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactUsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactUs.
     * @param {ContactUsUpsertArgs} args - Arguments to update or create a ContactUs.
     * @example
     * // Update or create a ContactUs
     * const contactUs = await prisma.contactUs.upsert({
     *   create: {
     *     // ... data to create a ContactUs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUs we want to update
     *   }
     * })
    **/
    upsert<T extends ContactUsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsUpsertArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Types.GetResult<ContactUsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsCountArgs} args - Arguments to filter Contactuses to count.
     * @example
     * // Count the number of Contactuses
     * const count = await prisma.contactUs.count({
     *   where: {
     *     // ... the filter for the Contactuses we want to count
     *   }
     * })
    **/
    count<T extends ContactUsCountArgs>(
      args?: Subset<T, ContactUsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUsAggregateArgs>(args: Subset<T, ContactUsAggregateArgs>): Prisma.PrismaPromise<GetContactUsAggregateType<T>>

    /**
     * Group by ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactUsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactUsGroupByArgs['orderBy'] }
        : { orderBy?: ContactUsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactUsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactUs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContactUsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ContactUs base type for findUnique actions
   */
  export type ContactUsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findUnique
   */
  export interface ContactUsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ContactUsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ContactUs findUniqueOrThrow
   */
  export type ContactUsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs base type for findFirst actions
   */
  export type ContactUsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: Enumerable<ContactUsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: Enumerable<ContactUsScalarFieldEnum>
  }

  /**
   * ContactUs findFirst
   */
  export interface ContactUsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ContactUsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ContactUs findFirstOrThrow
   */
  export type ContactUsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: Enumerable<ContactUsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: Enumerable<ContactUsScalarFieldEnum>
  }


  /**
   * ContactUs findMany
   */
  export type ContactUsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which Contactuses to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: Enumerable<ContactUsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    distinct?: Enumerable<ContactUsScalarFieldEnum>
  }


  /**
   * ContactUs create
   */
  export type ContactUsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactUs.
     */
    data: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
  }


  /**
   * ContactUs createMany
   */
  export type ContactUsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contactuses.
     */
    data: Enumerable<ContactUsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ContactUs update
   */
  export type ContactUsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactUs.
     */
    data: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
    /**
     * Choose, which ContactUs to update.
     */
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs updateMany
   */
  export type ContactUsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contactuses.
     */
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     */
    where?: ContactUsWhereInput
  }


  /**
   * ContactUs upsert
   */
  export type ContactUsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactUs to update in case it exists.
     */
    where: ContactUsWhereUniqueInput
    /**
     * In case the ContactUs found by the `where` argument doesn't exist, create a new ContactUs with this data.
     */
    create: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
    /**
     * In case the ContactUs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
  }


  /**
   * ContactUs delete
   */
  export type ContactUsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter which ContactUs to delete.
     */
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs deleteMany
   */
  export type ContactUsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contactuses to delete
     */
    where?: ContactUsWhereInput
  }


  /**
   * ContactUs without action
   */
  export type ContactUsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
  }



  /**
   * Model About
   */


  export type AggregateAbout = {
    _count: AboutCountAggregateOutputType | null
    _min: AboutMinAggregateOutputType | null
    _max: AboutMaxAggregateOutputType | null
  }

  export type AboutMinAggregateOutputType = {
    id: string | null
    name: string | null
    position: string | null
    image: string | null
    description: string | null
  }

  export type AboutMaxAggregateOutputType = {
    id: string | null
    name: string | null
    position: string | null
    image: string | null
    description: string | null
  }

  export type AboutCountAggregateOutputType = {
    id: number
    name: number
    position: number
    image: number
    description: number
    _all: number
  }


  export type AboutMinAggregateInputType = {
    id?: true
    name?: true
    position?: true
    image?: true
    description?: true
  }

  export type AboutMaxAggregateInputType = {
    id?: true
    name?: true
    position?: true
    image?: true
    description?: true
  }

  export type AboutCountAggregateInputType = {
    id?: true
    name?: true
    position?: true
    image?: true
    description?: true
    _all?: true
  }

  export type AboutAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which About to aggregate.
     */
    where?: AboutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abouts to fetch.
     */
    orderBy?: Enumerable<AboutOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AboutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Abouts
    **/
    _count?: true | AboutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutMaxAggregateInputType
  }

  export type GetAboutAggregateType<T extends AboutAggregateArgs> = {
        [P in keyof T & keyof AggregateAbout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbout[P]>
      : GetScalarType<T[P], AggregateAbout[P]>
  }




  export type AboutGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AboutWhereInput
    orderBy?: Enumerable<AboutOrderByWithAggregationInput>
    by: AboutScalarFieldEnum[]
    having?: AboutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutCountAggregateInputType | true
    _min?: AboutMinAggregateInputType
    _max?: AboutMaxAggregateInputType
  }


  export type AboutGroupByOutputType = {
    id: string
    name: string
    position: string
    image: string
    description: string
    _count: AboutCountAggregateOutputType | null
    _min: AboutMinAggregateOutputType | null
    _max: AboutMaxAggregateOutputType | null
  }

  type GetAboutGroupByPayload<T extends AboutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AboutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutGroupByOutputType[P]>
            : GetScalarType<T[P], AboutGroupByOutputType[P]>
        }
      >
    >


  export type AboutSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    image?: boolean
    description?: boolean
  }, ExtArgs["result"]["about"]>

  export type AboutSelectScalar = {
    id?: boolean
    name?: boolean
    position?: boolean
    image?: boolean
    description?: boolean
  }


  type AboutGetPayload<S extends boolean | null | undefined | AboutArgs> = $Types.GetResult<AboutPayload, S>

  type AboutCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AboutFindManyArgs, 'select' | 'include'> & {
      select?: AboutCountAggregateInputType | true
    }

  export interface AboutDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['About'], meta: { name: 'About' } }
    /**
     * Find zero or one About that matches the filter.
     * @param {AboutFindUniqueArgs} args - Arguments to find a About
     * @example
     * // Get one About
     * const about = await prisma.about.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AboutFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AboutFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'About'> extends True ? Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one About that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AboutFindUniqueOrThrowArgs} args - Arguments to find a About
     * @example
     * // Get one About
     * const about = await prisma.about.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AboutFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AboutFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first About that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutFindFirstArgs} args - Arguments to find a About
     * @example
     * // Get one About
     * const about = await prisma.about.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AboutFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AboutFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'About'> extends True ? Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first About that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutFindFirstOrThrowArgs} args - Arguments to find a About
     * @example
     * // Get one About
     * const about = await prisma.about.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AboutFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AboutFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Abouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abouts
     * const abouts = await prisma.about.findMany()
     * 
     * // Get first 10 Abouts
     * const abouts = await prisma.about.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutWithIdOnly = await prisma.about.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AboutFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AboutFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AboutPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a About.
     * @param {AboutCreateArgs} args - Arguments to create a About.
     * @example
     * // Create one About
     * const About = await prisma.about.create({
     *   data: {
     *     // ... data to create a About
     *   }
     * })
     * 
    **/
    create<T extends AboutCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AboutCreateArgs<ExtArgs>>
    ): Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Abouts.
     *     @param {AboutCreateManyArgs} args - Arguments to create many Abouts.
     *     @example
     *     // Create many Abouts
     *     const about = await prisma.about.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AboutCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AboutCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a About.
     * @param {AboutDeleteArgs} args - Arguments to delete one About.
     * @example
     * // Delete one About
     * const About = await prisma.about.delete({
     *   where: {
     *     // ... filter to delete one About
     *   }
     * })
     * 
    **/
    delete<T extends AboutDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AboutDeleteArgs<ExtArgs>>
    ): Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one About.
     * @param {AboutUpdateArgs} args - Arguments to update one About.
     * @example
     * // Update one About
     * const about = await prisma.about.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AboutUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AboutUpdateArgs<ExtArgs>>
    ): Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Abouts.
     * @param {AboutDeleteManyArgs} args - Arguments to filter Abouts to delete.
     * @example
     * // Delete a few Abouts
     * const { count } = await prisma.about.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AboutDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AboutDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abouts
     * const about = await prisma.about.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AboutUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AboutUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one About.
     * @param {AboutUpsertArgs} args - Arguments to update or create a About.
     * @example
     * // Update or create a About
     * const about = await prisma.about.upsert({
     *   create: {
     *     // ... data to create a About
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the About we want to update
     *   }
     * })
    **/
    upsert<T extends AboutUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AboutUpsertArgs<ExtArgs>>
    ): Prisma__AboutClient<$Types.GetResult<AboutPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Abouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutCountArgs} args - Arguments to filter Abouts to count.
     * @example
     * // Count the number of Abouts
     * const count = await prisma.about.count({
     *   where: {
     *     // ... the filter for the Abouts we want to count
     *   }
     * })
    **/
    count<T extends AboutCountArgs>(
      args?: Subset<T, AboutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a About.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutAggregateArgs>(args: Subset<T, AboutAggregateArgs>): Prisma.PrismaPromise<GetAboutAggregateType<T>>

    /**
     * Group by About.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AboutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AboutGroupByArgs['orderBy'] }
        : { orderBy?: AboutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AboutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for About.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AboutClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * About base type for findUnique actions
   */
  export type AboutFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * Filter, which About to fetch.
     */
    where: AboutWhereUniqueInput
  }

  /**
   * About findUnique
   */
  export interface AboutFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AboutFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * About findUniqueOrThrow
   */
  export type AboutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * Filter, which About to fetch.
     */
    where: AboutWhereUniqueInput
  }


  /**
   * About base type for findFirst actions
   */
  export type AboutFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * Filter, which About to fetch.
     */
    where?: AboutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abouts to fetch.
     */
    orderBy?: Enumerable<AboutOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abouts.
     */
    cursor?: AboutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abouts.
     */
    distinct?: Enumerable<AboutScalarFieldEnum>
  }

  /**
   * About findFirst
   */
  export interface AboutFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AboutFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * About findFirstOrThrow
   */
  export type AboutFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * Filter, which About to fetch.
     */
    where?: AboutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abouts to fetch.
     */
    orderBy?: Enumerable<AboutOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abouts.
     */
    cursor?: AboutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abouts.
     */
    distinct?: Enumerable<AboutScalarFieldEnum>
  }


  /**
   * About findMany
   */
  export type AboutFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * Filter, which Abouts to fetch.
     */
    where?: AboutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abouts to fetch.
     */
    orderBy?: Enumerable<AboutOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Abouts.
     */
    cursor?: AboutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abouts.
     */
    skip?: number
    distinct?: Enumerable<AboutScalarFieldEnum>
  }


  /**
   * About create
   */
  export type AboutCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * The data needed to create a About.
     */
    data: XOR<AboutCreateInput, AboutUncheckedCreateInput>
  }


  /**
   * About createMany
   */
  export type AboutCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Abouts.
     */
    data: Enumerable<AboutCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * About update
   */
  export type AboutUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * The data needed to update a About.
     */
    data: XOR<AboutUpdateInput, AboutUncheckedUpdateInput>
    /**
     * Choose, which About to update.
     */
    where: AboutWhereUniqueInput
  }


  /**
   * About updateMany
   */
  export type AboutUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Abouts.
     */
    data: XOR<AboutUpdateManyMutationInput, AboutUncheckedUpdateManyInput>
    /**
     * Filter which Abouts to update
     */
    where?: AboutWhereInput
  }


  /**
   * About upsert
   */
  export type AboutUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * The filter to search for the About to update in case it exists.
     */
    where: AboutWhereUniqueInput
    /**
     * In case the About found by the `where` argument doesn't exist, create a new About with this data.
     */
    create: XOR<AboutCreateInput, AboutUncheckedCreateInput>
    /**
     * In case the About was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AboutUpdateInput, AboutUncheckedUpdateInput>
  }


  /**
   * About delete
   */
  export type AboutDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
    /**
     * Filter which About to delete.
     */
    where: AboutWhereUniqueInput
  }


  /**
   * About deleteMany
   */
  export type AboutDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abouts to delete
     */
    where?: AboutWhereInput
  }


  /**
   * About without action
   */
  export type AboutArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About
     */
    select?: AboutSelect<ExtArgs> | null
  }



  /**
   * Model Gstr1_4A
   */


  export type AggregateGstr1_4A = {
    _count: Gstr1_4ACountAggregateOutputType | null
    _avg: Gstr1_4AAvgAggregateOutputType | null
    _sum: Gstr1_4ASumAggregateOutputType | null
    _min: Gstr1_4AMinAggregateOutputType | null
    _max: Gstr1_4AMaxAggregateOutputType | null
  }

  export type Gstr1_4AAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Gstr1_4ASumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Gstr1_4AMinAggregateOutputType = {
    id: number | null
    userId: number | null
    LegalName: string | null
    GSTN: string | null
    pos: string | null
    invoice_No: string | null
    invoice_date: string | null
    invoice_value: string | null
    rate: string | null
    nature: string | null
    source: string | null
    cgst: string | null
    igst: string | null
    sgst: string | null
    supply_type: string | null
    fy: string | null
    period: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Gstr1_4AMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    LegalName: string | null
    GSTN: string | null
    pos: string | null
    invoice_No: string | null
    invoice_date: string | null
    invoice_value: string | null
    rate: string | null
    nature: string | null
    source: string | null
    cgst: string | null
    igst: string | null
    sgst: string | null
    supply_type: string | null
    fy: string | null
    period: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Gstr1_4ACountAggregateOutputType = {
    id: number
    userId: number
    LegalName: number
    GSTN: number
    pos: number
    invoice_No: number
    invoice_date: number
    invoice_value: number
    rate: number
    nature: number
    source: number
    cgst: number
    igst: number
    sgst: number
    supply_type: number
    fy: number
    period: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Gstr1_4AAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Gstr1_4ASumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Gstr1_4AMinAggregateInputType = {
    id?: true
    userId?: true
    LegalName?: true
    GSTN?: true
    pos?: true
    invoice_No?: true
    invoice_date?: true
    invoice_value?: true
    rate?: true
    nature?: true
    source?: true
    cgst?: true
    igst?: true
    sgst?: true
    supply_type?: true
    fy?: true
    period?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Gstr1_4AMaxAggregateInputType = {
    id?: true
    userId?: true
    LegalName?: true
    GSTN?: true
    pos?: true
    invoice_No?: true
    invoice_date?: true
    invoice_value?: true
    rate?: true
    nature?: true
    source?: true
    cgst?: true
    igst?: true
    sgst?: true
    supply_type?: true
    fy?: true
    period?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Gstr1_4ACountAggregateInputType = {
    id?: true
    userId?: true
    LegalName?: true
    GSTN?: true
    pos?: true
    invoice_No?: true
    invoice_date?: true
    invoice_value?: true
    rate?: true
    nature?: true
    source?: true
    cgst?: true
    igst?: true
    sgst?: true
    supply_type?: true
    fy?: true
    period?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Gstr1_4AAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gstr1_4A to aggregate.
     */
    where?: Gstr1_4AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_4AS to fetch.
     */
    orderBy?: Enumerable<Gstr1_4AOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gstr1_4AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_4AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_4AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gstr1_4AS
    **/
    _count?: true | Gstr1_4ACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gstr1_4AAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gstr1_4ASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gstr1_4AMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gstr1_4AMaxAggregateInputType
  }

  export type GetGstr1_4AAggregateType<T extends Gstr1_4AAggregateArgs> = {
        [P in keyof T & keyof AggregateGstr1_4A]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGstr1_4A[P]>
      : GetScalarType<T[P], AggregateGstr1_4A[P]>
  }




  export type Gstr1_4AGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Gstr1_4AWhereInput
    orderBy?: Enumerable<Gstr1_4AOrderByWithAggregationInput>
    by: Gstr1_4AScalarFieldEnum[]
    having?: Gstr1_4AScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gstr1_4ACountAggregateInputType | true
    _avg?: Gstr1_4AAvgAggregateInputType
    _sum?: Gstr1_4ASumAggregateInputType
    _min?: Gstr1_4AMinAggregateInputType
    _max?: Gstr1_4AMaxAggregateInputType
  }


  export type Gstr1_4AGroupByOutputType = {
    id: number
    userId: number
    LegalName: string
    GSTN: string
    pos: string
    invoice_No: string
    invoice_date: string
    invoice_value: string
    rate: string
    nature: string
    source: string
    cgst: string
    igst: string
    sgst: string
    supply_type: string
    fy: string
    period: string
    createdAt: Date
    updatedAt: Date
    _count: Gstr1_4ACountAggregateOutputType | null
    _avg: Gstr1_4AAvgAggregateOutputType | null
    _sum: Gstr1_4ASumAggregateOutputType | null
    _min: Gstr1_4AMinAggregateOutputType | null
    _max: Gstr1_4AMaxAggregateOutputType | null
  }

  type GetGstr1_4AGroupByPayload<T extends Gstr1_4AGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Gstr1_4AGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gstr1_4AGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gstr1_4AGroupByOutputType[P]>
            : GetScalarType<T[P], Gstr1_4AGroupByOutputType[P]>
        }
      >
    >


  export type Gstr1_4ASelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    LegalName?: boolean
    GSTN?: boolean
    pos?: boolean
    invoice_No?: boolean
    invoice_date?: boolean
    invoice_value?: boolean
    rate?: boolean
    nature?: boolean
    source?: boolean
    cgst?: boolean
    igst?: boolean
    sgst?: boolean
    supply_type?: boolean
    fy?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["gstr1_4A"]>

  export type Gstr1_4ASelectScalar = {
    id?: boolean
    userId?: boolean
    LegalName?: boolean
    GSTN?: boolean
    pos?: boolean
    invoice_No?: boolean
    invoice_date?: boolean
    invoice_value?: boolean
    rate?: boolean
    nature?: boolean
    source?: boolean
    cgst?: boolean
    igst?: boolean
    sgst?: boolean
    supply_type?: boolean
    fy?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Gstr1_4AInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type Gstr1_4AGetPayload<S extends boolean | null | undefined | Gstr1_4AArgs> = $Types.GetResult<Gstr1_4APayload, S>

  type Gstr1_4ACountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Gstr1_4AFindManyArgs, 'select' | 'include'> & {
      select?: Gstr1_4ACountAggregateInputType | true
    }

  export interface Gstr1_4ADelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gstr1_4A'], meta: { name: 'Gstr1_4A' } }
    /**
     * Find zero or one Gstr1_4A that matches the filter.
     * @param {Gstr1_4AFindUniqueArgs} args - Arguments to find a Gstr1_4A
     * @example
     * // Get one Gstr1_4A
     * const gstr1_4A = await prisma.gstr1_4A.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Gstr1_4AFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Gstr1_4AFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Gstr1_4A'> extends True ? Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gstr1_4A that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Gstr1_4AFindUniqueOrThrowArgs} args - Arguments to find a Gstr1_4A
     * @example
     * // Get one Gstr1_4A
     * const gstr1_4A = await prisma.gstr1_4A.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Gstr1_4AFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_4AFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gstr1_4A that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_4AFindFirstArgs} args - Arguments to find a Gstr1_4A
     * @example
     * // Get one Gstr1_4A
     * const gstr1_4A = await prisma.gstr1_4A.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Gstr1_4AFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Gstr1_4AFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Gstr1_4A'> extends True ? Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gstr1_4A that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_4AFindFirstOrThrowArgs} args - Arguments to find a Gstr1_4A
     * @example
     * // Get one Gstr1_4A
     * const gstr1_4A = await prisma.gstr1_4A.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Gstr1_4AFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_4AFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gstr1_4AS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_4AFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gstr1_4AS
     * const gstr1_4AS = await prisma.gstr1_4A.findMany()
     * 
     * // Get first 10 Gstr1_4AS
     * const gstr1_4AS = await prisma.gstr1_4A.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gstr1_4AWithIdOnly = await prisma.gstr1_4A.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Gstr1_4AFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_4AFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gstr1_4A.
     * @param {Gstr1_4ACreateArgs} args - Arguments to create a Gstr1_4A.
     * @example
     * // Create one Gstr1_4A
     * const Gstr1_4A = await prisma.gstr1_4A.create({
     *   data: {
     *     // ... data to create a Gstr1_4A
     *   }
     * })
     * 
    **/
    create<T extends Gstr1_4ACreateArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_4ACreateArgs<ExtArgs>>
    ): Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gstr1_4AS.
     *     @param {Gstr1_4ACreateManyArgs} args - Arguments to create many Gstr1_4AS.
     *     @example
     *     // Create many Gstr1_4AS
     *     const gstr1_4A = await prisma.gstr1_4A.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Gstr1_4ACreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_4ACreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gstr1_4A.
     * @param {Gstr1_4ADeleteArgs} args - Arguments to delete one Gstr1_4A.
     * @example
     * // Delete one Gstr1_4A
     * const Gstr1_4A = await prisma.gstr1_4A.delete({
     *   where: {
     *     // ... filter to delete one Gstr1_4A
     *   }
     * })
     * 
    **/
    delete<T extends Gstr1_4ADeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_4ADeleteArgs<ExtArgs>>
    ): Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gstr1_4A.
     * @param {Gstr1_4AUpdateArgs} args - Arguments to update one Gstr1_4A.
     * @example
     * // Update one Gstr1_4A
     * const gstr1_4A = await prisma.gstr1_4A.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Gstr1_4AUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_4AUpdateArgs<ExtArgs>>
    ): Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gstr1_4AS.
     * @param {Gstr1_4ADeleteManyArgs} args - Arguments to filter Gstr1_4AS to delete.
     * @example
     * // Delete a few Gstr1_4AS
     * const { count } = await prisma.gstr1_4A.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Gstr1_4ADeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_4ADeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gstr1_4AS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_4AUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gstr1_4AS
     * const gstr1_4A = await prisma.gstr1_4A.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Gstr1_4AUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_4AUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gstr1_4A.
     * @param {Gstr1_4AUpsertArgs} args - Arguments to update or create a Gstr1_4A.
     * @example
     * // Update or create a Gstr1_4A
     * const gstr1_4A = await prisma.gstr1_4A.upsert({
     *   create: {
     *     // ... data to create a Gstr1_4A
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gstr1_4A we want to update
     *   }
     * })
    **/
    upsert<T extends Gstr1_4AUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_4AUpsertArgs<ExtArgs>>
    ): Prisma__Gstr1_4AClient<$Types.GetResult<Gstr1_4APayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gstr1_4AS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_4ACountArgs} args - Arguments to filter Gstr1_4AS to count.
     * @example
     * // Count the number of Gstr1_4AS
     * const count = await prisma.gstr1_4A.count({
     *   where: {
     *     // ... the filter for the Gstr1_4AS we want to count
     *   }
     * })
    **/
    count<T extends Gstr1_4ACountArgs>(
      args?: Subset<T, Gstr1_4ACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gstr1_4ACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gstr1_4A.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_4AAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gstr1_4AAggregateArgs>(args: Subset<T, Gstr1_4AAggregateArgs>): Prisma.PrismaPromise<GetGstr1_4AAggregateType<T>>

    /**
     * Group by Gstr1_4A.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_4AGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gstr1_4AGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gstr1_4AGroupByArgs['orderBy'] }
        : { orderBy?: Gstr1_4AGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gstr1_4AGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGstr1_4AGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Gstr1_4A.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Gstr1_4AClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Gstr1_4A base type for findUnique actions
   */
  export type Gstr1_4AFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_4A to fetch.
     */
    where: Gstr1_4AWhereUniqueInput
  }

  /**
   * Gstr1_4A findUnique
   */
  export interface Gstr1_4AFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Gstr1_4AFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gstr1_4A findUniqueOrThrow
   */
  export type Gstr1_4AFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_4A to fetch.
     */
    where: Gstr1_4AWhereUniqueInput
  }


  /**
   * Gstr1_4A base type for findFirst actions
   */
  export type Gstr1_4AFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_4A to fetch.
     */
    where?: Gstr1_4AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_4AS to fetch.
     */
    orderBy?: Enumerable<Gstr1_4AOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gstr1_4AS.
     */
    cursor?: Gstr1_4AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_4AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_4AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gstr1_4AS.
     */
    distinct?: Enumerable<Gstr1_4AScalarFieldEnum>
  }

  /**
   * Gstr1_4A findFirst
   */
  export interface Gstr1_4AFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Gstr1_4AFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gstr1_4A findFirstOrThrow
   */
  export type Gstr1_4AFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_4A to fetch.
     */
    where?: Gstr1_4AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_4AS to fetch.
     */
    orderBy?: Enumerable<Gstr1_4AOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gstr1_4AS.
     */
    cursor?: Gstr1_4AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_4AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_4AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gstr1_4AS.
     */
    distinct?: Enumerable<Gstr1_4AScalarFieldEnum>
  }


  /**
   * Gstr1_4A findMany
   */
  export type Gstr1_4AFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_4AS to fetch.
     */
    where?: Gstr1_4AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_4AS to fetch.
     */
    orderBy?: Enumerable<Gstr1_4AOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gstr1_4AS.
     */
    cursor?: Gstr1_4AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_4AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_4AS.
     */
    skip?: number
    distinct?: Enumerable<Gstr1_4AScalarFieldEnum>
  }


  /**
   * Gstr1_4A create
   */
  export type Gstr1_4ACreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * The data needed to create a Gstr1_4A.
     */
    data: XOR<Gstr1_4ACreateInput, Gstr1_4AUncheckedCreateInput>
  }


  /**
   * Gstr1_4A createMany
   */
  export type Gstr1_4ACreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gstr1_4AS.
     */
    data: Enumerable<Gstr1_4ACreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Gstr1_4A update
   */
  export type Gstr1_4AUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * The data needed to update a Gstr1_4A.
     */
    data: XOR<Gstr1_4AUpdateInput, Gstr1_4AUncheckedUpdateInput>
    /**
     * Choose, which Gstr1_4A to update.
     */
    where: Gstr1_4AWhereUniqueInput
  }


  /**
   * Gstr1_4A updateMany
   */
  export type Gstr1_4AUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gstr1_4AS.
     */
    data: XOR<Gstr1_4AUpdateManyMutationInput, Gstr1_4AUncheckedUpdateManyInput>
    /**
     * Filter which Gstr1_4AS to update
     */
    where?: Gstr1_4AWhereInput
  }


  /**
   * Gstr1_4A upsert
   */
  export type Gstr1_4AUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * The filter to search for the Gstr1_4A to update in case it exists.
     */
    where: Gstr1_4AWhereUniqueInput
    /**
     * In case the Gstr1_4A found by the `where` argument doesn't exist, create a new Gstr1_4A with this data.
     */
    create: XOR<Gstr1_4ACreateInput, Gstr1_4AUncheckedCreateInput>
    /**
     * In case the Gstr1_4A was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gstr1_4AUpdateInput, Gstr1_4AUncheckedUpdateInput>
  }


  /**
   * Gstr1_4A delete
   */
  export type Gstr1_4ADeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
    /**
     * Filter which Gstr1_4A to delete.
     */
    where: Gstr1_4AWhereUniqueInput
  }


  /**
   * Gstr1_4A deleteMany
   */
  export type Gstr1_4ADeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gstr1_4AS to delete
     */
    where?: Gstr1_4AWhereInput
  }


  /**
   * Gstr1_4A without action
   */
  export type Gstr1_4AArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_4A
     */
    select?: Gstr1_4ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_4AInclude<ExtArgs> | null
  }



  /**
   * Model Gstr1_5A
   */


  export type AggregateGstr1_5A = {
    _count: Gstr1_5ACountAggregateOutputType | null
    _avg: Gstr1_5AAvgAggregateOutputType | null
    _sum: Gstr1_5ASumAggregateOutputType | null
    _min: Gstr1_5AMinAggregateOutputType | null
    _max: Gstr1_5AMaxAggregateOutputType | null
  }

  export type Gstr1_5AAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Gstr1_5ASumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Gstr1_5AMinAggregateOutputType = {
    id: number | null
    userId: number | null
    pos: string | null
    invoice_No: string | null
    supply_type: string | null
    invoice_date: string | null
    invoice_value: string | null
    total_invoice_value: string | null
  }

  export type Gstr1_5AMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    pos: string | null
    invoice_No: string | null
    supply_type: string | null
    invoice_date: string | null
    invoice_value: string | null
    total_invoice_value: string | null
  }

  export type Gstr1_5ACountAggregateOutputType = {
    id: number
    userId: number
    pos: number
    invoice_No: number
    supply_type: number
    invoice_date: number
    invoice_value: number
    total_invoice_value: number
    _all: number
  }


  export type Gstr1_5AAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Gstr1_5ASumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Gstr1_5AMinAggregateInputType = {
    id?: true
    userId?: true
    pos?: true
    invoice_No?: true
    supply_type?: true
    invoice_date?: true
    invoice_value?: true
    total_invoice_value?: true
  }

  export type Gstr1_5AMaxAggregateInputType = {
    id?: true
    userId?: true
    pos?: true
    invoice_No?: true
    supply_type?: true
    invoice_date?: true
    invoice_value?: true
    total_invoice_value?: true
  }

  export type Gstr1_5ACountAggregateInputType = {
    id?: true
    userId?: true
    pos?: true
    invoice_No?: true
    supply_type?: true
    invoice_date?: true
    invoice_value?: true
    total_invoice_value?: true
    _all?: true
  }

  export type Gstr1_5AAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gstr1_5A to aggregate.
     */
    where?: Gstr1_5AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_5AS to fetch.
     */
    orderBy?: Enumerable<Gstr1_5AOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gstr1_5AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_5AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_5AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gstr1_5AS
    **/
    _count?: true | Gstr1_5ACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gstr1_5AAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gstr1_5ASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gstr1_5AMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gstr1_5AMaxAggregateInputType
  }

  export type GetGstr1_5AAggregateType<T extends Gstr1_5AAggregateArgs> = {
        [P in keyof T & keyof AggregateGstr1_5A]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGstr1_5A[P]>
      : GetScalarType<T[P], AggregateGstr1_5A[P]>
  }




  export type Gstr1_5AGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Gstr1_5AWhereInput
    orderBy?: Enumerable<Gstr1_5AOrderByWithAggregationInput>
    by: Gstr1_5AScalarFieldEnum[]
    having?: Gstr1_5AScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gstr1_5ACountAggregateInputType | true
    _avg?: Gstr1_5AAvgAggregateInputType
    _sum?: Gstr1_5ASumAggregateInputType
    _min?: Gstr1_5AMinAggregateInputType
    _max?: Gstr1_5AMaxAggregateInputType
  }


  export type Gstr1_5AGroupByOutputType = {
    id: number
    userId: number
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
    _count: Gstr1_5ACountAggregateOutputType | null
    _avg: Gstr1_5AAvgAggregateOutputType | null
    _sum: Gstr1_5ASumAggregateOutputType | null
    _min: Gstr1_5AMinAggregateOutputType | null
    _max: Gstr1_5AMaxAggregateOutputType | null
  }

  type GetGstr1_5AGroupByPayload<T extends Gstr1_5AGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Gstr1_5AGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gstr1_5AGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gstr1_5AGroupByOutputType[P]>
            : GetScalarType<T[P], Gstr1_5AGroupByOutputType[P]>
        }
      >
    >


  export type Gstr1_5ASelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pos?: boolean
    invoice_No?: boolean
    supply_type?: boolean
    invoice_date?: boolean
    invoice_value?: boolean
    total_invoice_value?: boolean
    user?: boolean | UserArgs<ExtArgs>
    gstr1_5A_items?: boolean | Gstr1_5A$gstr1_5A_itemsArgs<ExtArgs>
    _count?: boolean | Gstr1_5ACountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["gstr1_5A"]>

  export type Gstr1_5ASelectScalar = {
    id?: boolean
    userId?: boolean
    pos?: boolean
    invoice_No?: boolean
    supply_type?: boolean
    invoice_date?: boolean
    invoice_value?: boolean
    total_invoice_value?: boolean
  }

  export type Gstr1_5AInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    gstr1_5A_items?: boolean | Gstr1_5A$gstr1_5A_itemsArgs<ExtArgs>
    _count?: boolean | Gstr1_5ACountOutputTypeArgs<ExtArgs>
  }


  type Gstr1_5AGetPayload<S extends boolean | null | undefined | Gstr1_5AArgs> = $Types.GetResult<Gstr1_5APayload, S>

  type Gstr1_5ACountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Gstr1_5AFindManyArgs, 'select' | 'include'> & {
      select?: Gstr1_5ACountAggregateInputType | true
    }

  export interface Gstr1_5ADelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gstr1_5A'], meta: { name: 'Gstr1_5A' } }
    /**
     * Find zero or one Gstr1_5A that matches the filter.
     * @param {Gstr1_5AFindUniqueArgs} args - Arguments to find a Gstr1_5A
     * @example
     * // Get one Gstr1_5A
     * const gstr1_5A = await prisma.gstr1_5A.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Gstr1_5AFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Gstr1_5AFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Gstr1_5A'> extends True ? Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gstr1_5A that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Gstr1_5AFindUniqueOrThrowArgs} args - Arguments to find a Gstr1_5A
     * @example
     * // Get one Gstr1_5A
     * const gstr1_5A = await prisma.gstr1_5A.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Gstr1_5AFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5AFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gstr1_5A that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5AFindFirstArgs} args - Arguments to find a Gstr1_5A
     * @example
     * // Get one Gstr1_5A
     * const gstr1_5A = await prisma.gstr1_5A.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Gstr1_5AFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Gstr1_5AFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Gstr1_5A'> extends True ? Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gstr1_5A that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5AFindFirstOrThrowArgs} args - Arguments to find a Gstr1_5A
     * @example
     * // Get one Gstr1_5A
     * const gstr1_5A = await prisma.gstr1_5A.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Gstr1_5AFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5AFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gstr1_5AS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5AFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gstr1_5AS
     * const gstr1_5AS = await prisma.gstr1_5A.findMany()
     * 
     * // Get first 10 Gstr1_5AS
     * const gstr1_5AS = await prisma.gstr1_5A.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gstr1_5AWithIdOnly = await prisma.gstr1_5A.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Gstr1_5AFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5AFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gstr1_5A.
     * @param {Gstr1_5ACreateArgs} args - Arguments to create a Gstr1_5A.
     * @example
     * // Create one Gstr1_5A
     * const Gstr1_5A = await prisma.gstr1_5A.create({
     *   data: {
     *     // ... data to create a Gstr1_5A
     *   }
     * })
     * 
    **/
    create<T extends Gstr1_5ACreateArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5ACreateArgs<ExtArgs>>
    ): Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gstr1_5AS.
     *     @param {Gstr1_5ACreateManyArgs} args - Arguments to create many Gstr1_5AS.
     *     @example
     *     // Create many Gstr1_5AS
     *     const gstr1_5A = await prisma.gstr1_5A.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Gstr1_5ACreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5ACreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gstr1_5A.
     * @param {Gstr1_5ADeleteArgs} args - Arguments to delete one Gstr1_5A.
     * @example
     * // Delete one Gstr1_5A
     * const Gstr1_5A = await prisma.gstr1_5A.delete({
     *   where: {
     *     // ... filter to delete one Gstr1_5A
     *   }
     * })
     * 
    **/
    delete<T extends Gstr1_5ADeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5ADeleteArgs<ExtArgs>>
    ): Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gstr1_5A.
     * @param {Gstr1_5AUpdateArgs} args - Arguments to update one Gstr1_5A.
     * @example
     * // Update one Gstr1_5A
     * const gstr1_5A = await prisma.gstr1_5A.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Gstr1_5AUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5AUpdateArgs<ExtArgs>>
    ): Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gstr1_5AS.
     * @param {Gstr1_5ADeleteManyArgs} args - Arguments to filter Gstr1_5AS to delete.
     * @example
     * // Delete a few Gstr1_5AS
     * const { count } = await prisma.gstr1_5A.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Gstr1_5ADeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5ADeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gstr1_5AS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5AUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gstr1_5AS
     * const gstr1_5A = await prisma.gstr1_5A.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Gstr1_5AUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5AUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gstr1_5A.
     * @param {Gstr1_5AUpsertArgs} args - Arguments to update or create a Gstr1_5A.
     * @example
     * // Update or create a Gstr1_5A
     * const gstr1_5A = await prisma.gstr1_5A.upsert({
     *   create: {
     *     // ... data to create a Gstr1_5A
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gstr1_5A we want to update
     *   }
     * })
    **/
    upsert<T extends Gstr1_5AUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5AUpsertArgs<ExtArgs>>
    ): Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gstr1_5AS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5ACountArgs} args - Arguments to filter Gstr1_5AS to count.
     * @example
     * // Count the number of Gstr1_5AS
     * const count = await prisma.gstr1_5A.count({
     *   where: {
     *     // ... the filter for the Gstr1_5AS we want to count
     *   }
     * })
    **/
    count<T extends Gstr1_5ACountArgs>(
      args?: Subset<T, Gstr1_5ACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gstr1_5ACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gstr1_5A.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5AAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gstr1_5AAggregateArgs>(args: Subset<T, Gstr1_5AAggregateArgs>): Prisma.PrismaPromise<GetGstr1_5AAggregateType<T>>

    /**
     * Group by Gstr1_5A.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5AGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gstr1_5AGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gstr1_5AGroupByArgs['orderBy'] }
        : { orderBy?: Gstr1_5AGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gstr1_5AGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGstr1_5AGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Gstr1_5A.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Gstr1_5AClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    gstr1_5A_items<T extends Gstr1_5A$gstr1_5A_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Gstr1_5A$gstr1_5A_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Gstr1_5A base type for findUnique actions
   */
  export type Gstr1_5AFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A to fetch.
     */
    where: Gstr1_5AWhereUniqueInput
  }

  /**
   * Gstr1_5A findUnique
   */
  export interface Gstr1_5AFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Gstr1_5AFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gstr1_5A findUniqueOrThrow
   */
  export type Gstr1_5AFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A to fetch.
     */
    where: Gstr1_5AWhereUniqueInput
  }


  /**
   * Gstr1_5A base type for findFirst actions
   */
  export type Gstr1_5AFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A to fetch.
     */
    where?: Gstr1_5AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_5AS to fetch.
     */
    orderBy?: Enumerable<Gstr1_5AOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gstr1_5AS.
     */
    cursor?: Gstr1_5AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_5AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_5AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gstr1_5AS.
     */
    distinct?: Enumerable<Gstr1_5AScalarFieldEnum>
  }

  /**
   * Gstr1_5A findFirst
   */
  export interface Gstr1_5AFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Gstr1_5AFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gstr1_5A findFirstOrThrow
   */
  export type Gstr1_5AFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A to fetch.
     */
    where?: Gstr1_5AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_5AS to fetch.
     */
    orderBy?: Enumerable<Gstr1_5AOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gstr1_5AS.
     */
    cursor?: Gstr1_5AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_5AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_5AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gstr1_5AS.
     */
    distinct?: Enumerable<Gstr1_5AScalarFieldEnum>
  }


  /**
   * Gstr1_5A findMany
   */
  export type Gstr1_5AFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5AS to fetch.
     */
    where?: Gstr1_5AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_5AS to fetch.
     */
    orderBy?: Enumerable<Gstr1_5AOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gstr1_5AS.
     */
    cursor?: Gstr1_5AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_5AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_5AS.
     */
    skip?: number
    distinct?: Enumerable<Gstr1_5AScalarFieldEnum>
  }


  /**
   * Gstr1_5A create
   */
  export type Gstr1_5ACreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * The data needed to create a Gstr1_5A.
     */
    data: XOR<Gstr1_5ACreateInput, Gstr1_5AUncheckedCreateInput>
  }


  /**
   * Gstr1_5A createMany
   */
  export type Gstr1_5ACreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gstr1_5AS.
     */
    data: Enumerable<Gstr1_5ACreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Gstr1_5A update
   */
  export type Gstr1_5AUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * The data needed to update a Gstr1_5A.
     */
    data: XOR<Gstr1_5AUpdateInput, Gstr1_5AUncheckedUpdateInput>
    /**
     * Choose, which Gstr1_5A to update.
     */
    where: Gstr1_5AWhereUniqueInput
  }


  /**
   * Gstr1_5A updateMany
   */
  export type Gstr1_5AUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gstr1_5AS.
     */
    data: XOR<Gstr1_5AUpdateManyMutationInput, Gstr1_5AUncheckedUpdateManyInput>
    /**
     * Filter which Gstr1_5AS to update
     */
    where?: Gstr1_5AWhereInput
  }


  /**
   * Gstr1_5A upsert
   */
  export type Gstr1_5AUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * The filter to search for the Gstr1_5A to update in case it exists.
     */
    where: Gstr1_5AWhereUniqueInput
    /**
     * In case the Gstr1_5A found by the `where` argument doesn't exist, create a new Gstr1_5A with this data.
     */
    create: XOR<Gstr1_5ACreateInput, Gstr1_5AUncheckedCreateInput>
    /**
     * In case the Gstr1_5A was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gstr1_5AUpdateInput, Gstr1_5AUncheckedUpdateInput>
  }


  /**
   * Gstr1_5A delete
   */
  export type Gstr1_5ADeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
    /**
     * Filter which Gstr1_5A to delete.
     */
    where: Gstr1_5AWhereUniqueInput
  }


  /**
   * Gstr1_5A deleteMany
   */
  export type Gstr1_5ADeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gstr1_5AS to delete
     */
    where?: Gstr1_5AWhereInput
  }


  /**
   * Gstr1_5A.gstr1_5A_items
   */
  export type Gstr1_5A$gstr1_5A_itemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    where?: Gstr1_5A_itemWhereInput
    orderBy?: Enumerable<Gstr1_5A_itemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: Gstr1_5A_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Gstr1_5A_itemScalarFieldEnum>
  }


  /**
   * Gstr1_5A without action
   */
  export type Gstr1_5AArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A
     */
    select?: Gstr1_5ASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5AInclude<ExtArgs> | null
  }



  /**
   * Model Gstr1_5A_item
   */


  export type AggregateGstr1_5A_item = {
    _count: Gstr1_5A_itemCountAggregateOutputType | null
    _avg: Gstr1_5A_itemAvgAggregateOutputType | null
    _sum: Gstr1_5A_itemSumAggregateOutputType | null
    _min: Gstr1_5A_itemMinAggregateOutputType | null
    _max: Gstr1_5A_itemMaxAggregateOutputType | null
  }

  export type Gstr1_5A_itemAvgAggregateOutputType = {
    id: number | null
    gstr1_5A_id: number | null
  }

  export type Gstr1_5A_itemSumAggregateOutputType = {
    id: number | null
    gstr1_5A_id: number | null
  }

  export type Gstr1_5A_itemMinAggregateOutputType = {
    id: number | null
    SN: string | null
    turnover: string | null
    cgst: string | null
    sgst: string | null
    gstr1_5A_id: number | null
  }

  export type Gstr1_5A_itemMaxAggregateOutputType = {
    id: number | null
    SN: string | null
    turnover: string | null
    cgst: string | null
    sgst: string | null
    gstr1_5A_id: number | null
  }

  export type Gstr1_5A_itemCountAggregateOutputType = {
    id: number
    SN: number
    turnover: number
    cgst: number
    sgst: number
    gstr1_5A_id: number
    _all: number
  }


  export type Gstr1_5A_itemAvgAggregateInputType = {
    id?: true
    gstr1_5A_id?: true
  }

  export type Gstr1_5A_itemSumAggregateInputType = {
    id?: true
    gstr1_5A_id?: true
  }

  export type Gstr1_5A_itemMinAggregateInputType = {
    id?: true
    SN?: true
    turnover?: true
    cgst?: true
    sgst?: true
    gstr1_5A_id?: true
  }

  export type Gstr1_5A_itemMaxAggregateInputType = {
    id?: true
    SN?: true
    turnover?: true
    cgst?: true
    sgst?: true
    gstr1_5A_id?: true
  }

  export type Gstr1_5A_itemCountAggregateInputType = {
    id?: true
    SN?: true
    turnover?: true
    cgst?: true
    sgst?: true
    gstr1_5A_id?: true
    _all?: true
  }

  export type Gstr1_5A_itemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gstr1_5A_item to aggregate.
     */
    where?: Gstr1_5A_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_5A_items to fetch.
     */
    orderBy?: Enumerable<Gstr1_5A_itemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gstr1_5A_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_5A_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_5A_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gstr1_5A_items
    **/
    _count?: true | Gstr1_5A_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gstr1_5A_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gstr1_5A_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gstr1_5A_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gstr1_5A_itemMaxAggregateInputType
  }

  export type GetGstr1_5A_itemAggregateType<T extends Gstr1_5A_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateGstr1_5A_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGstr1_5A_item[P]>
      : GetScalarType<T[P], AggregateGstr1_5A_item[P]>
  }




  export type Gstr1_5A_itemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Gstr1_5A_itemWhereInput
    orderBy?: Enumerable<Gstr1_5A_itemOrderByWithAggregationInput>
    by: Gstr1_5A_itemScalarFieldEnum[]
    having?: Gstr1_5A_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gstr1_5A_itemCountAggregateInputType | true
    _avg?: Gstr1_5A_itemAvgAggregateInputType
    _sum?: Gstr1_5A_itemSumAggregateInputType
    _min?: Gstr1_5A_itemMinAggregateInputType
    _max?: Gstr1_5A_itemMaxAggregateInputType
  }


  export type Gstr1_5A_itemGroupByOutputType = {
    id: number
    SN: string
    turnover: string
    cgst: string
    sgst: string
    gstr1_5A_id: number
    _count: Gstr1_5A_itemCountAggregateOutputType | null
    _avg: Gstr1_5A_itemAvgAggregateOutputType | null
    _sum: Gstr1_5A_itemSumAggregateOutputType | null
    _min: Gstr1_5A_itemMinAggregateOutputType | null
    _max: Gstr1_5A_itemMaxAggregateOutputType | null
  }

  type GetGstr1_5A_itemGroupByPayload<T extends Gstr1_5A_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Gstr1_5A_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gstr1_5A_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gstr1_5A_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Gstr1_5A_itemGroupByOutputType[P]>
        }
      >
    >


  export type Gstr1_5A_itemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    SN?: boolean
    turnover?: boolean
    cgst?: boolean
    sgst?: boolean
    gstr1_5A_id?: boolean
    gstr1_5A?: boolean | Gstr1_5AArgs<ExtArgs>
  }, ExtArgs["result"]["gstr1_5A_item"]>

  export type Gstr1_5A_itemSelectScalar = {
    id?: boolean
    SN?: boolean
    turnover?: boolean
    cgst?: boolean
    sgst?: boolean
    gstr1_5A_id?: boolean
  }

  export type Gstr1_5A_itemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    gstr1_5A?: boolean | Gstr1_5AArgs<ExtArgs>
  }


  type Gstr1_5A_itemGetPayload<S extends boolean | null | undefined | Gstr1_5A_itemArgs> = $Types.GetResult<Gstr1_5A_itemPayload, S>

  type Gstr1_5A_itemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Gstr1_5A_itemFindManyArgs, 'select' | 'include'> & {
      select?: Gstr1_5A_itemCountAggregateInputType | true
    }

  export interface Gstr1_5A_itemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gstr1_5A_item'], meta: { name: 'Gstr1_5A_item' } }
    /**
     * Find zero or one Gstr1_5A_item that matches the filter.
     * @param {Gstr1_5A_itemFindUniqueArgs} args - Arguments to find a Gstr1_5A_item
     * @example
     * // Get one Gstr1_5A_item
     * const gstr1_5A_item = await prisma.gstr1_5A_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Gstr1_5A_itemFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Gstr1_5A_itemFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Gstr1_5A_item'> extends True ? Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gstr1_5A_item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Gstr1_5A_itemFindUniqueOrThrowArgs} args - Arguments to find a Gstr1_5A_item
     * @example
     * // Get one Gstr1_5A_item
     * const gstr1_5A_item = await prisma.gstr1_5A_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Gstr1_5A_itemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5A_itemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gstr1_5A_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5A_itemFindFirstArgs} args - Arguments to find a Gstr1_5A_item
     * @example
     * // Get one Gstr1_5A_item
     * const gstr1_5A_item = await prisma.gstr1_5A_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Gstr1_5A_itemFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Gstr1_5A_itemFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Gstr1_5A_item'> extends True ? Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gstr1_5A_item that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5A_itemFindFirstOrThrowArgs} args - Arguments to find a Gstr1_5A_item
     * @example
     * // Get one Gstr1_5A_item
     * const gstr1_5A_item = await prisma.gstr1_5A_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Gstr1_5A_itemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5A_itemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gstr1_5A_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5A_itemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gstr1_5A_items
     * const gstr1_5A_items = await prisma.gstr1_5A_item.findMany()
     * 
     * // Get first 10 Gstr1_5A_items
     * const gstr1_5A_items = await prisma.gstr1_5A_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gstr1_5A_itemWithIdOnly = await prisma.gstr1_5A_item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Gstr1_5A_itemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5A_itemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gstr1_5A_item.
     * @param {Gstr1_5A_itemCreateArgs} args - Arguments to create a Gstr1_5A_item.
     * @example
     * // Create one Gstr1_5A_item
     * const Gstr1_5A_item = await prisma.gstr1_5A_item.create({
     *   data: {
     *     // ... data to create a Gstr1_5A_item
     *   }
     * })
     * 
    **/
    create<T extends Gstr1_5A_itemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5A_itemCreateArgs<ExtArgs>>
    ): Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gstr1_5A_items.
     *     @param {Gstr1_5A_itemCreateManyArgs} args - Arguments to create many Gstr1_5A_items.
     *     @example
     *     // Create many Gstr1_5A_items
     *     const gstr1_5A_item = await prisma.gstr1_5A_item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Gstr1_5A_itemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5A_itemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gstr1_5A_item.
     * @param {Gstr1_5A_itemDeleteArgs} args - Arguments to delete one Gstr1_5A_item.
     * @example
     * // Delete one Gstr1_5A_item
     * const Gstr1_5A_item = await prisma.gstr1_5A_item.delete({
     *   where: {
     *     // ... filter to delete one Gstr1_5A_item
     *   }
     * })
     * 
    **/
    delete<T extends Gstr1_5A_itemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5A_itemDeleteArgs<ExtArgs>>
    ): Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gstr1_5A_item.
     * @param {Gstr1_5A_itemUpdateArgs} args - Arguments to update one Gstr1_5A_item.
     * @example
     * // Update one Gstr1_5A_item
     * const gstr1_5A_item = await prisma.gstr1_5A_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Gstr1_5A_itemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5A_itemUpdateArgs<ExtArgs>>
    ): Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gstr1_5A_items.
     * @param {Gstr1_5A_itemDeleteManyArgs} args - Arguments to filter Gstr1_5A_items to delete.
     * @example
     * // Delete a few Gstr1_5A_items
     * const { count } = await prisma.gstr1_5A_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Gstr1_5A_itemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gstr1_5A_itemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gstr1_5A_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5A_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gstr1_5A_items
     * const gstr1_5A_item = await prisma.gstr1_5A_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Gstr1_5A_itemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5A_itemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gstr1_5A_item.
     * @param {Gstr1_5A_itemUpsertArgs} args - Arguments to update or create a Gstr1_5A_item.
     * @example
     * // Update or create a Gstr1_5A_item
     * const gstr1_5A_item = await prisma.gstr1_5A_item.upsert({
     *   create: {
     *     // ... data to create a Gstr1_5A_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gstr1_5A_item we want to update
     *   }
     * })
    **/
    upsert<T extends Gstr1_5A_itemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Gstr1_5A_itemUpsertArgs<ExtArgs>>
    ): Prisma__Gstr1_5A_itemClient<$Types.GetResult<Gstr1_5A_itemPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gstr1_5A_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5A_itemCountArgs} args - Arguments to filter Gstr1_5A_items to count.
     * @example
     * // Count the number of Gstr1_5A_items
     * const count = await prisma.gstr1_5A_item.count({
     *   where: {
     *     // ... the filter for the Gstr1_5A_items we want to count
     *   }
     * })
    **/
    count<T extends Gstr1_5A_itemCountArgs>(
      args?: Subset<T, Gstr1_5A_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gstr1_5A_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gstr1_5A_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5A_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gstr1_5A_itemAggregateArgs>(args: Subset<T, Gstr1_5A_itemAggregateArgs>): Prisma.PrismaPromise<GetGstr1_5A_itemAggregateType<T>>

    /**
     * Group by Gstr1_5A_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gstr1_5A_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gstr1_5A_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gstr1_5A_itemGroupByArgs['orderBy'] }
        : { orderBy?: Gstr1_5A_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gstr1_5A_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGstr1_5A_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Gstr1_5A_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Gstr1_5A_itemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    gstr1_5A<T extends Gstr1_5AArgs<ExtArgs> = {}>(args?: Subset<T, Gstr1_5AArgs<ExtArgs>>): Prisma__Gstr1_5AClient<$Types.GetResult<Gstr1_5APayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Gstr1_5A_item base type for findUnique actions
   */
  export type Gstr1_5A_itemFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A_item to fetch.
     */
    where: Gstr1_5A_itemWhereUniqueInput
  }

  /**
   * Gstr1_5A_item findUnique
   */
  export interface Gstr1_5A_itemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Gstr1_5A_itemFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gstr1_5A_item findUniqueOrThrow
   */
  export type Gstr1_5A_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A_item to fetch.
     */
    where: Gstr1_5A_itemWhereUniqueInput
  }


  /**
   * Gstr1_5A_item base type for findFirst actions
   */
  export type Gstr1_5A_itemFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A_item to fetch.
     */
    where?: Gstr1_5A_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_5A_items to fetch.
     */
    orderBy?: Enumerable<Gstr1_5A_itemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gstr1_5A_items.
     */
    cursor?: Gstr1_5A_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_5A_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_5A_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gstr1_5A_items.
     */
    distinct?: Enumerable<Gstr1_5A_itemScalarFieldEnum>
  }

  /**
   * Gstr1_5A_item findFirst
   */
  export interface Gstr1_5A_itemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Gstr1_5A_itemFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gstr1_5A_item findFirstOrThrow
   */
  export type Gstr1_5A_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A_item to fetch.
     */
    where?: Gstr1_5A_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_5A_items to fetch.
     */
    orderBy?: Enumerable<Gstr1_5A_itemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gstr1_5A_items.
     */
    cursor?: Gstr1_5A_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_5A_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_5A_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gstr1_5A_items.
     */
    distinct?: Enumerable<Gstr1_5A_itemScalarFieldEnum>
  }


  /**
   * Gstr1_5A_item findMany
   */
  export type Gstr1_5A_itemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * Filter, which Gstr1_5A_items to fetch.
     */
    where?: Gstr1_5A_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gstr1_5A_items to fetch.
     */
    orderBy?: Enumerable<Gstr1_5A_itemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gstr1_5A_items.
     */
    cursor?: Gstr1_5A_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gstr1_5A_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gstr1_5A_items.
     */
    skip?: number
    distinct?: Enumerable<Gstr1_5A_itemScalarFieldEnum>
  }


  /**
   * Gstr1_5A_item create
   */
  export type Gstr1_5A_itemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * The data needed to create a Gstr1_5A_item.
     */
    data: XOR<Gstr1_5A_itemCreateInput, Gstr1_5A_itemUncheckedCreateInput>
  }


  /**
   * Gstr1_5A_item createMany
   */
  export type Gstr1_5A_itemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gstr1_5A_items.
     */
    data: Enumerable<Gstr1_5A_itemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Gstr1_5A_item update
   */
  export type Gstr1_5A_itemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * The data needed to update a Gstr1_5A_item.
     */
    data: XOR<Gstr1_5A_itemUpdateInput, Gstr1_5A_itemUncheckedUpdateInput>
    /**
     * Choose, which Gstr1_5A_item to update.
     */
    where: Gstr1_5A_itemWhereUniqueInput
  }


  /**
   * Gstr1_5A_item updateMany
   */
  export type Gstr1_5A_itemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gstr1_5A_items.
     */
    data: XOR<Gstr1_5A_itemUpdateManyMutationInput, Gstr1_5A_itemUncheckedUpdateManyInput>
    /**
     * Filter which Gstr1_5A_items to update
     */
    where?: Gstr1_5A_itemWhereInput
  }


  /**
   * Gstr1_5A_item upsert
   */
  export type Gstr1_5A_itemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * The filter to search for the Gstr1_5A_item to update in case it exists.
     */
    where: Gstr1_5A_itemWhereUniqueInput
    /**
     * In case the Gstr1_5A_item found by the `where` argument doesn't exist, create a new Gstr1_5A_item with this data.
     */
    create: XOR<Gstr1_5A_itemCreateInput, Gstr1_5A_itemUncheckedCreateInput>
    /**
     * In case the Gstr1_5A_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gstr1_5A_itemUpdateInput, Gstr1_5A_itemUncheckedUpdateInput>
  }


  /**
   * Gstr1_5A_item delete
   */
  export type Gstr1_5A_itemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
    /**
     * Filter which Gstr1_5A_item to delete.
     */
    where: Gstr1_5A_itemWhereUniqueInput
  }


  /**
   * Gstr1_5A_item deleteMany
   */
  export type Gstr1_5A_itemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gstr1_5A_items to delete
     */
    where?: Gstr1_5A_itemWhereInput
  }


  /**
   * Gstr1_5A_item without action
   */
  export type Gstr1_5A_itemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gstr1_5A_item
     */
    select?: Gstr1_5A_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Gstr1_5A_itemInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    fatherName: 'fatherName',
    phone: 'phone',
    gender: 'gender',
    address: 'address',
    pin: 'pin',
    aadhaar: 'aadhaar',
    pan: 'pan',
    dob: 'dob',
    avatar: 'avatar',
    adminId: 'adminId',
    superadminId: 'superadminId',
    verified: 'verified',
    userType: 'userType'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    otp: 'otp',
    userId: 'userId',
    used: 'used'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const BusinessProfileScalarFieldEnum: {
    id: 'id',
    businessName: 'businessName',
    pan: 'pan',
    tan: 'tan',
    gstin: 'gstin',
    address: 'address',
    bankName: 'bankName',
    bankAccountNo: 'bankAccountNo',
    bankIfsc: 'bankIfsc',
    bankBranch: 'bankBranch',
    state: 'state',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isAddressVerified: 'isAddressVerified',
    isBusinessNameVerified: 'isBusinessNameVerified',
    isGstinVerified: 'isGstinVerified',
    isPanVerified: 'isPanVerified',
    isStateVerified: 'isStateVerified'
  };

  export type BusinessProfileScalarFieldEnum = (typeof BusinessProfileScalarFieldEnum)[keyof typeof BusinessProfileScalarFieldEnum]


  export const LedgerScalarFieldEnum: {
    id: 'id',
    ledgerName: 'ledgerName',
    openingBalance: 'openingBalance',
    balance: 'balance',
    userId: 'userId',
    partyId: 'partyId',
    year: 'year',
    month: 'month',
    ledgerType: 'ledgerType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LedgerScalarFieldEnum = (typeof LedgerScalarFieldEnum)[keyof typeof LedgerScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    entryDate: 'entryDate',
    description: 'description',
    userId: 'userId'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    ledgerId: 'ledgerId',
    journalEntryId: 'journalEntryId',
    amount: 'amount',
    transactionType: 'transactionType',
    userId: 'userId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const PartyScalarFieldEnum: {
    id: 'id',
    partyName: 'partyName',
    type: 'type',
    gstin: 'gstin',
    pan: 'pan',
    tan: 'tan',
    upi: 'upi',
    email: 'email',
    phone: 'phone',
    address: 'address',
    bankName: 'bankName',
    bankAccountNumber: 'bankAccountNumber',
    bankIfsc: 'bankIfsc',
    bankBranch: 'bankBranch',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartyScalarFieldEnum = (typeof PartyScalarFieldEnum)[keyof typeof PartyScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    categoryName: 'categoryName',
    userId: 'userId'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    itemName: 'itemName',
    unit: 'unit',
    price: 'price',
    openingStock: 'openingStock',
    closingStock: 'closingStock',
    purchasePrice: 'purchasePrice',
    gst: 'gst',
    taxExempted: 'taxExempted',
    description: 'description',
    hsnCode: 'hsnCode',
    categoryId: 'categoryId',
    supplierId: 'supplierId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    type: 'type',
    totalAmount: 'totalAmount',
    totalGst: 'totalGst',
    stateOfSupply: 'stateOfSupply',
    cgst: 'cgst',
    sgst: 'sgst',
    igst: 'igst',
    utgst: 'utgst',
    details: 'details',
    extraDetails: 'extraDetails',
    modeOfPayment: 'modeOfPayment',
    credit: 'credit',
    userId: 'userId',
    partyId: 'partyId',
    gstNumber: 'gstNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    quantity: 'quantity',
    discount: 'discount',
    invoiceId: 'invoiceId'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    serviceName: 'serviceName',
    serviceType: 'serviceType',
    imgUrl: 'imgUrl',
    description: 'description',
    price: 'price',
    gst: 'gst',
    documents: 'documents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    services: 'services',
    status: 'status',
    price: 'price',
    gst: 'gst',
    orderTotal: 'orderTotal',
    stateOfSupply: 'stateOfSupply',
    userId: 'userId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    razorpay_order_id: 'razorpay_order_id',
    razorpay_payment_id: 'razorpay_payment_id',
    status: 'status',
    userId: 'userId',
    orderId: 'orderId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const LibraryScalarFieldEnum: {
    id: 'id',
    pan: 'pan',
    section: 'section',
    sub_section: 'sub_section',
    subject: 'subject',
    ao_order: 'ao_order',
    itat_no: 'itat_no',
    rsa_no: 'rsa_no',
    bench: 'bench',
    appeal_no: 'appeal_no',
    appellant: 'appellant',
    respondent: 'respondent',
    appeal_type: 'appeal_type',
    appeal_filed_by: 'appeal_filed_by',
    order_result: 'order_result',
    tribunal_order_date: 'tribunal_order_date',
    assessment_year: 'assessment_year',
    judgment: 'judgment',
    conclusion: 'conclusion',
    download: 'download',
    upload: 'upload',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryScalarFieldEnum = (typeof LibraryScalarFieldEnum)[keyof typeof LibraryScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    contentheading: 'contentheading',
    contentdiscription: 'contentdiscription',
    category: 'category',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountName: 'accountName',
    totalDebit: 'totalDebit',
    totalCredit: 'totalCredit',
    debitBalance: 'debitBalance',
    creditBalance: 'creditBalance',
    date: 'date',
    userId: 'userId'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const CareerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    pin: 'pin',
    email: 'email',
    mobile: 'mobile',
    skills: 'skills',
    gender: 'gender',
    cv: 'cv',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CareerScalarFieldEnum = (typeof CareerScalarFieldEnum)[keyof typeof CareerScalarFieldEnum]


  export const BillrecieveScalarFieldEnum: {
    id: 'id',
    billNumber: 'billNumber',
    amount: 'amount',
    tax: 'tax',
    customerName: 'customerName',
    customerAddress: 'customerAddress',
    contact: 'contact',
    itemQuantity: 'itemQuantity',
    itemPrice: 'itemPrice',
    itemDescription: 'itemDescription',
    paymentStatus: 'paymentStatus',
    paymentMethod: 'paymentMethod',
    dueDate: 'dueDate',
    comment: 'comment'
  };

  export type BillrecieveScalarFieldEnum = (typeof BillrecieveScalarFieldEnum)[keyof typeof BillrecieveScalarFieldEnum]


  export const BillpayableScalarFieldEnum: {
    id: 'id',
    supplierName: 'supplierName',
    supplierAddress: 'supplierAddress',
    contact: 'contact',
    billDate: 'billDate',
    dueDate: 'dueDate',
    billAmount: 'billAmount',
    billNumber: 'billNumber',
    billDiscription: 'billDiscription',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    paymentDate: 'paymentDate',
    paymentAmount: 'paymentAmount',
    tax: 'tax',
    comment: 'comment',
    invoiceNumber: 'invoiceNumber'
  };

  export type BillpayableScalarFieldEnum = (typeof BillpayableScalarFieldEnum)[keyof typeof BillpayableScalarFieldEnum]


  export const UploadedDocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fileName: 'fileName',
    applicationId: 'applicationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UploadedDocumentScalarFieldEnum = (typeof UploadedDocumentScalarFieldEnum)[keyof typeof UploadedDocumentScalarFieldEnum]


  export const LoanDocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    mandatory: 'mandatory',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanDocumentScalarFieldEnum = (typeof LoanDocumentScalarFieldEnum)[keyof typeof LoanDocumentScalarFieldEnum]


  export const LoanScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    shortName: 'shortName',
    description: 'description',
    maxAmount: 'maxAmount',
    minAmount: 'minAmount',
    interest: 'interest',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanScalarFieldEnum = (typeof LoanScalarFieldEnum)[keyof typeof LoanScalarFieldEnum]


  export const LoanApplicationScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    loanAmount: 'loanAmount',
    loanStatus: 'loanStatus',
    applicantName: 'applicantName',
    applicantAge: 'applicantAge',
    loanType: 'loanType',
    applicantGender: 'applicantGender',
    nationality: 'nationality',
    description: 'description',
    salaried: 'salaried',
    bankAccountId: 'bankAccountId',
    phone: 'phone',
    email: 'email',
    address: 'address',
    permanentAddress: 'permanentAddress',
    userId: 'userId',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanApplicationScalarFieldEnum = (typeof LoanApplicationScalarFieldEnum)[keyof typeof LoanApplicationScalarFieldEnum]


  export const BankDetailsScalarFieldEnum: {
    id: 'id',
    accountHolderName: 'accountHolderName',
    bankName: 'bankName',
    bankAccountNo: 'bankAccountNo',
    bankIfsc: 'bankIfsc',
    bankBranch: 'bankBranch',
    bankAccountType: 'bankAccountType',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankDetailsScalarFieldEnum = (typeof BankDetailsScalarFieldEnum)[keyof typeof BankDetailsScalarFieldEnum]


  export const InsuranceScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    mobile: 'mobile',
    email: 'email',
    address: 'address',
    dob: 'dob',
    maritalStatus: 'maritalStatus',
    gender: 'gender',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsuranceScalarFieldEnum = (typeof InsuranceScalarFieldEnum)[keyof typeof InsuranceScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const VisitorScalarFieldEnum: {
    id: 'id',
    count: 'count',
    createdAt: 'createdAt'
  };

  export type VisitorScalarFieldEnum = (typeof VisitorScalarFieldEnum)[keyof typeof VisitorScalarFieldEnum]


  export const RegisterStartupScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image: 'image',
    userId: 'userId',
    categories: 'categories'
  };

  export type RegisterStartupScalarFieldEnum = (typeof RegisterStartupScalarFieldEnum)[keyof typeof RegisterStartupScalarFieldEnum]


  export const ContactUsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    message: 'message',
    phoneNumber: 'phoneNumber',
    userId: 'userId'
  };

  export type ContactUsScalarFieldEnum = (typeof ContactUsScalarFieldEnum)[keyof typeof ContactUsScalarFieldEnum]


  export const AboutScalarFieldEnum: {
    id: 'id',
    name: 'name',
    position: 'position',
    image: 'image',
    description: 'description'
  };

  export type AboutScalarFieldEnum = (typeof AboutScalarFieldEnum)[keyof typeof AboutScalarFieldEnum]


  export const Gstr1_4AScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    LegalName: 'LegalName',
    GSTN: 'GSTN',
    pos: 'pos',
    invoice_No: 'invoice_No',
    invoice_date: 'invoice_date',
    invoice_value: 'invoice_value',
    rate: 'rate',
    nature: 'nature',
    source: 'source',
    cgst: 'cgst',
    igst: 'igst',
    sgst: 'sgst',
    supply_type: 'supply_type',
    fy: 'fy',
    period: 'period',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Gstr1_4AScalarFieldEnum = (typeof Gstr1_4AScalarFieldEnum)[keyof typeof Gstr1_4AScalarFieldEnum]


  export const Gstr1_5AScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    pos: 'pos',
    invoice_No: 'invoice_No',
    supply_type: 'supply_type',
    invoice_date: 'invoice_date',
    invoice_value: 'invoice_value',
    total_invoice_value: 'total_invoice_value'
  };

  export type Gstr1_5AScalarFieldEnum = (typeof Gstr1_5AScalarFieldEnum)[keyof typeof Gstr1_5AScalarFieldEnum]


  export const Gstr1_5A_itemScalarFieldEnum: {
    id: 'id',
    SN: 'SN',
    turnover: 'turnover',
    cgst: 'cgst',
    sgst: 'sgst',
    gstr1_5A_id: 'gstr1_5A_id'
  };

  export type Gstr1_5A_itemScalarFieldEnum = (typeof Gstr1_5A_itemScalarFieldEnum)[keyof typeof Gstr1_5A_itemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    fatherName: 'fatherName',
    phone: 'phone',
    address: 'address',
    pin: 'pin',
    aadhaar: 'aadhaar',
    pan: 'pan',
    avatar: 'avatar'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const OtpOrderByRelevanceFieldEnum: {
    otp: 'otp'
  };

  export type OtpOrderByRelevanceFieldEnum = (typeof OtpOrderByRelevanceFieldEnum)[keyof typeof OtpOrderByRelevanceFieldEnum]


  export const BusinessProfileOrderByRelevanceFieldEnum: {
    businessName: 'businessName',
    pan: 'pan',
    tan: 'tan',
    gstin: 'gstin',
    address: 'address',
    bankName: 'bankName',
    bankAccountNo: 'bankAccountNo',
    bankIfsc: 'bankIfsc',
    bankBranch: 'bankBranch',
    state: 'state'
  };

  export type BusinessProfileOrderByRelevanceFieldEnum = (typeof BusinessProfileOrderByRelevanceFieldEnum)[keyof typeof BusinessProfileOrderByRelevanceFieldEnum]


  export const LedgerOrderByRelevanceFieldEnum: {
    id: 'id',
    ledgerName: 'ledgerName',
    partyId: 'partyId'
  };

  export type LedgerOrderByRelevanceFieldEnum = (typeof LedgerOrderByRelevanceFieldEnum)[keyof typeof LedgerOrderByRelevanceFieldEnum]


  export const JournalEntryOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description'
  };

  export type JournalEntryOrderByRelevanceFieldEnum = (typeof JournalEntryOrderByRelevanceFieldEnum)[keyof typeof JournalEntryOrderByRelevanceFieldEnum]


  export const TransactionOrderByRelevanceFieldEnum: {
    id: 'id',
    ledgerId: 'ledgerId',
    journalEntryId: 'journalEntryId'
  };

  export type TransactionOrderByRelevanceFieldEnum = (typeof TransactionOrderByRelevanceFieldEnum)[keyof typeof TransactionOrderByRelevanceFieldEnum]


  export const PartyOrderByRelevanceFieldEnum: {
    id: 'id',
    partyName: 'partyName',
    gstin: 'gstin',
    pan: 'pan',
    tan: 'tan',
    upi: 'upi',
    email: 'email',
    phone: 'phone',
    address: 'address',
    bankName: 'bankName',
    bankAccountNumber: 'bankAccountNumber',
    bankIfsc: 'bankIfsc',
    bankBranch: 'bankBranch'
  };

  export type PartyOrderByRelevanceFieldEnum = (typeof PartyOrderByRelevanceFieldEnum)[keyof typeof PartyOrderByRelevanceFieldEnum]


  export const CategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    categoryName: 'categoryName'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const ItemOrderByRelevanceFieldEnum: {
    id: 'id',
    itemName: 'itemName',
    description: 'description',
    hsnCode: 'hsnCode',
    categoryId: 'categoryId',
    supplierId: 'supplierId'
  };

  export type ItemOrderByRelevanceFieldEnum = (typeof ItemOrderByRelevanceFieldEnum)[keyof typeof ItemOrderByRelevanceFieldEnum]


  export const InvoiceOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    stateOfSupply: 'stateOfSupply',
    details: 'details',
    extraDetails: 'extraDetails',
    partyId: 'partyId',
    gstNumber: 'gstNumber'
  };

  export type InvoiceOrderByRelevanceFieldEnum = (typeof InvoiceOrderByRelevanceFieldEnum)[keyof typeof InvoiceOrderByRelevanceFieldEnum]


  export const InvoiceItemOrderByRelevanceFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    invoiceId: 'invoiceId'
  };

  export type InvoiceItemOrderByRelevanceFieldEnum = (typeof InvoiceItemOrderByRelevanceFieldEnum)[keyof typeof InvoiceItemOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const ServiceOrderByRelevanceFieldEnum: {
    id: 'id',
    serviceName: 'serviceName',
    serviceType: 'serviceType',
    imgUrl: 'imgUrl',
    description: 'description'
  };

  export type ServiceOrderByRelevanceFieldEnum = (typeof ServiceOrderByRelevanceFieldEnum)[keyof typeof ServiceOrderByRelevanceFieldEnum]


  export const OrderOrderByRelevanceFieldEnum: {
    stateOfSupply: 'stateOfSupply'
  };

  export type OrderOrderByRelevanceFieldEnum = (typeof OrderOrderByRelevanceFieldEnum)[keyof typeof OrderOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    razorpay_order_id: 'razorpay_order_id',
    razorpay_payment_id: 'razorpay_payment_id'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const LibraryOrderByRelevanceFieldEnum: {
    pan: 'pan',
    section: 'section',
    sub_section: 'sub_section',
    subject: 'subject',
    ao_order: 'ao_order',
    itat_no: 'itat_no',
    rsa_no: 'rsa_no',
    bench: 'bench',
    appeal_no: 'appeal_no',
    appellant: 'appellant',
    respondent: 'respondent',
    appeal_type: 'appeal_type',
    appeal_filed_by: 'appeal_filed_by',
    order_result: 'order_result',
    tribunal_order_date: 'tribunal_order_date',
    assessment_year: 'assessment_year',
    judgment: 'judgment',
    conclusion: 'conclusion',
    download: 'download',
    upload: 'upload'
  };

  export type LibraryOrderByRelevanceFieldEnum = (typeof LibraryOrderByRelevanceFieldEnum)[keyof typeof LibraryOrderByRelevanceFieldEnum]


  export const PostOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    contentheading: 'contentheading',
    contentdiscription: 'contentdiscription',
    category: 'category',
    imageUrl: 'imageUrl'
  };

  export type PostOrderByRelevanceFieldEnum = (typeof PostOrderByRelevanceFieldEnum)[keyof typeof PostOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    accountName: 'accountName'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const CareerOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    pin: 'pin',
    email: 'email',
    mobile: 'mobile',
    skills: 'skills',
    cv: 'cv'
  };

  export type CareerOrderByRelevanceFieldEnum = (typeof CareerOrderByRelevanceFieldEnum)[keyof typeof CareerOrderByRelevanceFieldEnum]


  export const BillrecieveOrderByRelevanceFieldEnum: {
    billNumber: 'billNumber',
    amount: 'amount',
    tax: 'tax',
    customerName: 'customerName',
    customerAddress: 'customerAddress',
    contact: 'contact',
    itemQuantity: 'itemQuantity',
    itemPrice: 'itemPrice',
    itemDescription: 'itemDescription',
    dueDate: 'dueDate',
    comment: 'comment'
  };

  export type BillrecieveOrderByRelevanceFieldEnum = (typeof BillrecieveOrderByRelevanceFieldEnum)[keyof typeof BillrecieveOrderByRelevanceFieldEnum]


  export const BillpayableOrderByRelevanceFieldEnum: {
    supplierName: 'supplierName',
    supplierAddress: 'supplierAddress',
    contact: 'contact',
    billDate: 'billDate',
    dueDate: 'dueDate',
    billAmount: 'billAmount',
    billNumber: 'billNumber',
    billDiscription: 'billDiscription',
    transactionId: 'transactionId',
    paymentDate: 'paymentDate',
    paymentAmount: 'paymentAmount',
    tax: 'tax',
    comment: 'comment',
    invoiceNumber: 'invoiceNumber'
  };

  export type BillpayableOrderByRelevanceFieldEnum = (typeof BillpayableOrderByRelevanceFieldEnum)[keyof typeof BillpayableOrderByRelevanceFieldEnum]


  export const UploadedDocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    applicationId: 'applicationId'
  };

  export type UploadedDocumentOrderByRelevanceFieldEnum = (typeof UploadedDocumentOrderByRelevanceFieldEnum)[keyof typeof UploadedDocumentOrderByRelevanceFieldEnum]


  export const LoanDocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    description: 'description'
  };

  export type LoanDocumentOrderByRelevanceFieldEnum = (typeof LoanDocumentOrderByRelevanceFieldEnum)[keyof typeof LoanDocumentOrderByRelevanceFieldEnum]


  export const LoanOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    description: 'description'
  };

  export type LoanOrderByRelevanceFieldEnum = (typeof LoanOrderByRelevanceFieldEnum)[keyof typeof LoanOrderByRelevanceFieldEnum]


  export const LoanApplicationOrderByRelevanceFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    applicantName: 'applicantName',
    description: 'description',
    bankAccountId: 'bankAccountId',
    phone: 'phone',
    email: 'email',
    address: 'address',
    permanentAddress: 'permanentAddress',
    agentId: 'agentId'
  };

  export type LoanApplicationOrderByRelevanceFieldEnum = (typeof LoanApplicationOrderByRelevanceFieldEnum)[keyof typeof LoanApplicationOrderByRelevanceFieldEnum]


  export const BankDetailsOrderByRelevanceFieldEnum: {
    id: 'id',
    accountHolderName: 'accountHolderName',
    bankName: 'bankName',
    bankAccountNo: 'bankAccountNo',
    bankIfsc: 'bankIfsc',
    bankBranch: 'bankBranch'
  };

  export type BankDetailsOrderByRelevanceFieldEnum = (typeof BankDetailsOrderByRelevanceFieldEnum)[keyof typeof BankDetailsOrderByRelevanceFieldEnum]


  export const InsuranceOrderByRelevanceFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    mobile: 'mobile',
    email: 'email',
    address: 'address',
    maritalStatus: 'maritalStatus'
  };

  export type InsuranceOrderByRelevanceFieldEnum = (typeof InsuranceOrderByRelevanceFieldEnum)[keyof typeof InsuranceOrderByRelevanceFieldEnum]


  export const ClientOrderByRelevanceFieldEnum: {
    id: 'id',
    agentId: 'agentId'
  };

  export type ClientOrderByRelevanceFieldEnum = (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum]


  export const AgentOrderByRelevanceFieldEnum: {
    id: 'id'
  };

  export type AgentOrderByRelevanceFieldEnum = (typeof AgentOrderByRelevanceFieldEnum)[keyof typeof AgentOrderByRelevanceFieldEnum]


  export const RegisterStartupOrderByRelevanceFieldEnum: {
    title: 'title',
    image: 'image'
  };

  export type RegisterStartupOrderByRelevanceFieldEnum = (typeof RegisterStartupOrderByRelevanceFieldEnum)[keyof typeof RegisterStartupOrderByRelevanceFieldEnum]


  export const ContactUsOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    message: 'message',
    phoneNumber: 'phoneNumber'
  };

  export type ContactUsOrderByRelevanceFieldEnum = (typeof ContactUsOrderByRelevanceFieldEnum)[keyof typeof ContactUsOrderByRelevanceFieldEnum]


  export const AboutOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    position: 'position',
    image: 'image',
    description: 'description'
  };

  export type AboutOrderByRelevanceFieldEnum = (typeof AboutOrderByRelevanceFieldEnum)[keyof typeof AboutOrderByRelevanceFieldEnum]


  export const Gstr1_4AOrderByRelevanceFieldEnum: {
    LegalName: 'LegalName',
    GSTN: 'GSTN',
    pos: 'pos',
    invoice_No: 'invoice_No',
    invoice_date: 'invoice_date',
    invoice_value: 'invoice_value',
    rate: 'rate',
    nature: 'nature',
    source: 'source',
    cgst: 'cgst',
    igst: 'igst',
    sgst: 'sgst',
    supply_type: 'supply_type',
    fy: 'fy',
    period: 'period'
  };

  export type Gstr1_4AOrderByRelevanceFieldEnum = (typeof Gstr1_4AOrderByRelevanceFieldEnum)[keyof typeof Gstr1_4AOrderByRelevanceFieldEnum]


  export const Gstr1_5AOrderByRelevanceFieldEnum: {
    pos: 'pos',
    invoice_No: 'invoice_No',
    supply_type: 'supply_type',
    invoice_date: 'invoice_date',
    invoice_value: 'invoice_value',
    total_invoice_value: 'total_invoice_value'
  };

  export type Gstr1_5AOrderByRelevanceFieldEnum = (typeof Gstr1_5AOrderByRelevanceFieldEnum)[keyof typeof Gstr1_5AOrderByRelevanceFieldEnum]


  export const Gstr1_5A_itemOrderByRelevanceFieldEnum: {
    SN: 'SN',
    turnover: 'turnover',
    cgst: 'cgst',
    sgst: 'sgst'
  };

  export type Gstr1_5A_itemOrderByRelevanceFieldEnum = (typeof Gstr1_5A_itemOrderByRelevanceFieldEnum)[keyof typeof Gstr1_5A_itemOrderByRelevanceFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    email?: StringFilter | string
    password?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringNullableFilter | string | null
    fatherName?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    gender?: EnumUserGenderFilter | UserGender
    address?: StringNullableFilter | string | null
    pin?: StringNullableFilter | string | null
    aadhaar?: StringNullableFilter | string | null
    pan?: StringNullableFilter | string | null
    dob?: DateTimeNullableFilter | Date | string | null
    avatar?: StringNullableFilter | string | null
    adminId?: IntNullableFilter | number | null
    superadminId?: IntNullableFilter | number | null
    verified?: BoolFilter | boolean
    userType?: EnumUserTypeFilter | UserType
    otps?: OtpListRelationFilter
    businessProfile?: XOR<BusinessProfileRelationFilter, BusinessProfileWhereInput> | null
    invoices?: InvoiceListRelationFilter
    categories?: CategoryListRelationFilter
    items?: ItemListRelationFilter
    parties?: PartyListRelationFilter
    payments?: PaymentListRelationFilter
    orders?: OrderListRelationFilter
    posts?: PostListRelationFilter
    accounts?: AccountListRelationFilter
    bankAccounts?: BankDetailsListRelationFilter
    loans?: LoanApplicationListRelationFilter
    documents?: UploadedDocumentListRelationFilter
    insurances?: InsuranceListRelationFilter
    registerStartup?: RegisterStartupListRelationFilter
    contactUs?: ContactUsListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    legders?: LedgerListRelationFilter
    transactions?: TransactionListRelationFilter
    agentId?: XOR<AgentRelationFilter, AgentWhereInput> | null
    clientAccounts?: ClientListRelationFilter
    gstr1?: Gstr1_4AListRelationFilter
    gstr1_5A?: Gstr1_5AListRelationFilter
  }

  export type UserOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    fatherName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    gender?: SortOrder
    address?: SortOrderInput | SortOrder
    pin?: SortOrderInput | SortOrder
    aadhaar?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    superadminId?: SortOrderInput | SortOrder
    verified?: SortOrder
    userType?: SortOrder
    otps?: OtpOrderByRelationAggregateInput
    businessProfile?: BusinessProfileOrderByWithRelationAndSearchRelevanceInput
    invoices?: InvoiceOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
    parties?: PartyOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    bankAccounts?: BankDetailsOrderByRelationAggregateInput
    loans?: LoanApplicationOrderByRelationAggregateInput
    documents?: UploadedDocumentOrderByRelationAggregateInput
    insurances?: InsuranceOrderByRelationAggregateInput
    registerStartup?: RegisterStartupOrderByRelationAggregateInput
    contactUs?: ContactUsOrderByRelationAggregateInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    legders?: LedgerOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    agentId?: AgentOrderByWithRelationAndSearchRelevanceInput
    clientAccounts?: ClientOrderByRelationAggregateInput
    gstr1?: Gstr1_4AOrderByRelationAggregateInput
    gstr1_5A?: Gstr1_5AOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    fatherName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    gender?: SortOrder
    address?: SortOrderInput | SortOrder
    pin?: SortOrderInput | SortOrder
    aadhaar?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    superadminId?: SortOrderInput | SortOrder
    verified?: SortOrder
    userType?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringNullableWithAggregatesFilter | string | null
    fatherName?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumUserGenderWithAggregatesFilter | UserGender
    address?: StringNullableWithAggregatesFilter | string | null
    pin?: StringNullableWithAggregatesFilter | string | null
    aadhaar?: StringNullableWithAggregatesFilter | string | null
    pan?: StringNullableWithAggregatesFilter | string | null
    dob?: DateTimeNullableWithAggregatesFilter | Date | string | null
    avatar?: StringNullableWithAggregatesFilter | string | null
    adminId?: IntNullableWithAggregatesFilter | number | null
    superadminId?: IntNullableWithAggregatesFilter | number | null
    verified?: BoolWithAggregatesFilter | boolean
    userType?: EnumUserTypeWithAggregatesFilter | UserType
  }

  export type OtpWhereInput = {
    AND?: Enumerable<OtpWhereInput>
    OR?: Enumerable<OtpWhereInput>
    NOT?: Enumerable<OtpWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    otp?: StringFilter | string
    userId?: IntFilter | number
    used?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OtpOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    otp?: SortOrder
    userId?: SortOrder
    used?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: OtpOrderByRelevanceInput
  }

  export type OtpWhereUniqueInput = {
    id?: number
  }

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    otp?: SortOrder
    userId?: SortOrder
    used?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _avg?: OtpAvgOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
    _sum?: OtpSumOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OtpScalarWhereWithAggregatesInput>
    OR?: Enumerable<OtpScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OtpScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    otp?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    used?: BoolWithAggregatesFilter | boolean
  }

  export type BusinessProfileWhereInput = {
    AND?: Enumerable<BusinessProfileWhereInput>
    OR?: Enumerable<BusinessProfileWhereInput>
    NOT?: Enumerable<BusinessProfileWhereInput>
    id?: IntFilter | number
    businessName?: StringFilter | string
    pan?: StringNullableFilter | string | null
    tan?: StringNullableFilter | string | null
    gstin?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    bankName?: StringNullableFilter | string | null
    bankAccountNo?: StringNullableFilter | string | null
    bankIfsc?: StringNullableFilter | string | null
    bankBranch?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isAddressVerified?: BoolNullableFilter | boolean | null
    isBusinessNameVerified?: BoolNullableFilter | boolean | null
    isGstinVerified?: BoolNullableFilter | boolean | null
    isPanVerified?: BoolNullableFilter | boolean | null
    isStateVerified?: BoolNullableFilter | boolean | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BusinessProfileOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    businessName?: SortOrder
    pan?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccountNo?: SortOrderInput | SortOrder
    bankIfsc?: SortOrderInput | SortOrder
    bankBranch?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAddressVerified?: SortOrderInput | SortOrder
    isBusinessNameVerified?: SortOrderInput | SortOrder
    isGstinVerified?: SortOrderInput | SortOrder
    isPanVerified?: SortOrderInput | SortOrder
    isStateVerified?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: BusinessProfileOrderByRelevanceInput
  }

  export type BusinessProfileWhereUniqueInput = {
    id?: number
    userId?: number
  }

  export type BusinessProfileOrderByWithAggregationInput = {
    id?: SortOrder
    businessName?: SortOrder
    pan?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccountNo?: SortOrderInput | SortOrder
    bankIfsc?: SortOrderInput | SortOrder
    bankBranch?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAddressVerified?: SortOrderInput | SortOrder
    isBusinessNameVerified?: SortOrderInput | SortOrder
    isGstinVerified?: SortOrderInput | SortOrder
    isPanVerified?: SortOrderInput | SortOrder
    isStateVerified?: SortOrderInput | SortOrder
    _count?: BusinessProfileCountOrderByAggregateInput
    _avg?: BusinessProfileAvgOrderByAggregateInput
    _max?: BusinessProfileMaxOrderByAggregateInput
    _min?: BusinessProfileMinOrderByAggregateInput
    _sum?: BusinessProfileSumOrderByAggregateInput
  }

  export type BusinessProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessProfileScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    businessName?: StringWithAggregatesFilter | string
    pan?: StringNullableWithAggregatesFilter | string | null
    tan?: StringNullableWithAggregatesFilter | string | null
    gstin?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    bankName?: StringNullableWithAggregatesFilter | string | null
    bankAccountNo?: StringNullableWithAggregatesFilter | string | null
    bankIfsc?: StringNullableWithAggregatesFilter | string | null
    bankBranch?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isAddressVerified?: BoolNullableWithAggregatesFilter | boolean | null
    isBusinessNameVerified?: BoolNullableWithAggregatesFilter | boolean | null
    isGstinVerified?: BoolNullableWithAggregatesFilter | boolean | null
    isPanVerified?: BoolNullableWithAggregatesFilter | boolean | null
    isStateVerified?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type LedgerWhereInput = {
    AND?: Enumerable<LedgerWhereInput>
    OR?: Enumerable<LedgerWhereInput>
    NOT?: Enumerable<LedgerWhereInput>
    id?: StringFilter | string
    ledgerName?: StringFilter | string
    openingBalance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    userId?: IntFilter | number
    partyId?: StringNullableFilter | string | null
    year?: IntFilter | number
    month?: IntFilter | number
    ledgerType?: EnumLedgerTypeFilter | LedgerType
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
    party?: XOR<PartyRelationFilter, PartyWhereInput> | null
  }

  export type LedgerOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    openingBalance?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    partyId?: SortOrderInput | SortOrder
    year?: SortOrder
    month?: SortOrder
    ledgerType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    transactions?: TransactionOrderByRelationAggregateInput
    party?: PartyOrderByWithRelationAndSearchRelevanceInput
    _relevance?: LedgerOrderByRelevanceInput
  }

  export type LedgerWhereUniqueInput = {
    id?: string
  }

  export type LedgerOrderByWithAggregationInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    openingBalance?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    partyId?: SortOrderInput | SortOrder
    year?: SortOrder
    month?: SortOrder
    ledgerType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LedgerCountOrderByAggregateInput
    _avg?: LedgerAvgOrderByAggregateInput
    _max?: LedgerMaxOrderByAggregateInput
    _min?: LedgerMinOrderByAggregateInput
    _sum?: LedgerSumOrderByAggregateInput
  }

  export type LedgerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LedgerScalarWhereWithAggregatesInput>
    OR?: Enumerable<LedgerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LedgerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    ledgerName?: StringWithAggregatesFilter | string
    openingBalance?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    balance?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    userId?: IntWithAggregatesFilter | number
    partyId?: StringNullableWithAggregatesFilter | string | null
    year?: IntWithAggregatesFilter | number
    month?: IntWithAggregatesFilter | number
    ledgerType?: EnumLedgerTypeWithAggregatesFilter | LedgerType
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type JournalEntryWhereInput = {
    AND?: Enumerable<JournalEntryWhereInput>
    OR?: Enumerable<JournalEntryWhereInput>
    NOT?: Enumerable<JournalEntryWhereInput>
    id?: StringFilter | string
    entryDate?: DateTimeFilter | Date | string
    description?: StringFilter | string
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type JournalEntryOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    entryDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    transactions?: TransactionOrderByRelationAggregateInput
    _relevance?: JournalEntryOrderByRelevanceInput
  }

  export type JournalEntryWhereUniqueInput = {
    id?: string
  }

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    entryDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _avg?: JournalEntryAvgOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
    _sum?: JournalEntrySumOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JournalEntryScalarWhereWithAggregatesInput>
    OR?: Enumerable<JournalEntryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JournalEntryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    entryDate?: DateTimeWithAggregatesFilter | Date | string
    description?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
  }

  export type TransactionWhereInput = {
    AND?: Enumerable<TransactionWhereInput>
    OR?: Enumerable<TransactionWhereInput>
    NOT?: Enumerable<TransactionWhereInput>
    id?: StringFilter | string
    ledgerId?: StringFilter | string
    journalEntryId?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFilter | TransactionType
    userId?: IntFilter | number
    ledger?: XOR<LedgerRelationFilter, LedgerWhereInput>
    journalEntry?: XOR<JournalEntryRelationFilter, JournalEntryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    ledgerId?: SortOrder
    journalEntryId?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    userId?: SortOrder
    ledger?: LedgerOrderByWithRelationAndSearchRelevanceInput
    journalEntry?: JournalEntryOrderByWithRelationAndSearchRelevanceInput
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: TransactionOrderByRelevanceInput
  }

  export type TransactionWhereUniqueInput = {
    id?: string
  }

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    ledgerId?: SortOrder
    journalEntryId?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    userId?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    ledgerId?: StringWithAggregatesFilter | string
    journalEntryId?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeWithAggregatesFilter | TransactionType
    userId?: IntWithAggregatesFilter | number
  }

  export type PartyWhereInput = {
    AND?: Enumerable<PartyWhereInput>
    OR?: Enumerable<PartyWhereInput>
    NOT?: Enumerable<PartyWhereInput>
    id?: StringFilter | string
    partyName?: StringFilter | string
    type?: EnumPartyTypeFilter | PartyType
    gstin?: StringNullableFilter | string | null
    pan?: StringNullableFilter | string | null
    tan?: StringNullableFilter | string | null
    upi?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    bankName?: StringNullableFilter | string | null
    bankAccountNumber?: StringNullableFilter | string | null
    bankIfsc?: StringNullableFilter | string | null
    bankBranch?: StringNullableFilter | string | null
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    invoices?: InvoiceListRelationFilter
    items?: ItemListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    ledgers?: LedgerListRelationFilter
  }

  export type PartyOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    partyName?: SortOrder
    type?: SortOrder
    gstin?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    upi?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccountNumber?: SortOrderInput | SortOrder
    bankIfsc?: SortOrderInput | SortOrder
    bankBranch?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    ledgers?: LedgerOrderByRelationAggregateInput
    _relevance?: PartyOrderByRelevanceInput
  }

  export type PartyWhereUniqueInput = {
    id?: string
  }

  export type PartyOrderByWithAggregationInput = {
    id?: SortOrder
    partyName?: SortOrder
    type?: SortOrder
    gstin?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    upi?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccountNumber?: SortOrderInput | SortOrder
    bankIfsc?: SortOrderInput | SortOrder
    bankBranch?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartyCountOrderByAggregateInput
    _avg?: PartyAvgOrderByAggregateInput
    _max?: PartyMaxOrderByAggregateInput
    _min?: PartyMinOrderByAggregateInput
    _sum?: PartySumOrderByAggregateInput
  }

  export type PartyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PartyScalarWhereWithAggregatesInput>
    OR?: Enumerable<PartyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PartyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    partyName?: StringWithAggregatesFilter | string
    type?: EnumPartyTypeWithAggregatesFilter | PartyType
    gstin?: StringNullableWithAggregatesFilter | string | null
    pan?: StringNullableWithAggregatesFilter | string | null
    tan?: StringNullableWithAggregatesFilter | string | null
    upi?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    bankName?: StringNullableWithAggregatesFilter | string | null
    bankAccountNumber?: StringNullableWithAggregatesFilter | string | null
    bankIfsc?: StringNullableWithAggregatesFilter | string | null
    bankBranch?: StringNullableWithAggregatesFilter | string | null
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: StringFilter | string
    categoryName?: StringFilter | string
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: ItemListRelationFilter
  }

  export type CategoryOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    categoryName?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    items?: ItemOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = {
    id?: string
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    categoryName?: SortOrder
    userId?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    categoryName?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
  }

  export type ItemWhereInput = {
    AND?: Enumerable<ItemWhereInput>
    OR?: Enumerable<ItemWhereInput>
    NOT?: Enumerable<ItemWhereInput>
    id?: StringFilter | string
    itemName?: StringFilter | string
    unit?: EnumItemUnitFilter | ItemUnit
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    closingStock?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    gst?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    hsnCode?: StringNullableFilter | string | null
    categoryId?: StringNullableFilter | string | null
    supplierId?: StringNullableFilter | string | null
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    category?: XOR<CategoryRelationFilter, CategoryWhereInput> | null
    supplier?: XOR<PartyRelationFilter, PartyWhereInput> | null
    invoiceItems?: InvoiceItemListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ItemOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    itemName?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    openingStock?: SortOrderInput | SortOrder
    closingStock?: SortOrderInput | SortOrder
    purchasePrice?: SortOrderInput | SortOrder
    gst?: SortOrderInput | SortOrder
    taxExempted?: SortOrder
    description?: SortOrderInput | SortOrder
    hsnCode?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationAndSearchRelevanceInput
    supplier?: PartyOrderByWithRelationAndSearchRelevanceInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ItemOrderByRelevanceInput
  }

  export type ItemWhereUniqueInput = {
    id?: string
  }

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    itemName?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    openingStock?: SortOrderInput | SortOrder
    closingStock?: SortOrderInput | SortOrder
    purchasePrice?: SortOrderInput | SortOrder
    gst?: SortOrderInput | SortOrder
    taxExempted?: SortOrder
    description?: SortOrderInput | SortOrder
    hsnCode?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    itemName?: StringWithAggregatesFilter | string
    unit?: EnumItemUnitWithAggregatesFilter | ItemUnit
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    closingStock?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    gst?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolWithAggregatesFilter | boolean
    description?: StringNullableWithAggregatesFilter | string | null
    hsnCode?: StringNullableWithAggregatesFilter | string | null
    categoryId?: StringNullableWithAggregatesFilter | string | null
    supplierId?: StringNullableWithAggregatesFilter | string | null
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: Enumerable<InvoiceWhereInput>
    OR?: Enumerable<InvoiceWhereInput>
    NOT?: Enumerable<InvoiceWhereInput>
    id?: StringFilter | string
    invoiceNumber?: StringNullableFilter | string | null
    type?: EnumInvoiceTypeFilter | InvoiceType
    totalAmount?: FloatFilter | number
    totalGst?: FloatNullableFilter | number | null
    stateOfSupply?: StringFilter | string
    cgst?: FloatNullableFilter | number | null
    sgst?: FloatNullableFilter | number | null
    igst?: FloatNullableFilter | number | null
    utgst?: FloatNullableFilter | number | null
    details?: StringNullableFilter | string | null
    extraDetails?: StringNullableFilter | string | null
    modeOfPayment?: EnumModeOfPaymentFilter | ModeOfPayment
    credit?: BoolFilter | boolean
    userId?: IntFilter | number
    partyId?: StringFilter | string
    gstNumber?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: EnumInvoiceStatusFilter | InvoiceStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
    party?: XOR<PartyRelationFilter, PartyWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    accounts?: AccountListRelationFilter
  }

  export type InvoiceOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    totalGst?: SortOrderInput | SortOrder
    stateOfSupply?: SortOrder
    cgst?: SortOrderInput | SortOrder
    sgst?: SortOrderInput | SortOrder
    igst?: SortOrderInput | SortOrder
    utgst?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    extraDetails?: SortOrderInput | SortOrder
    modeOfPayment?: SortOrder
    credit?: SortOrder
    userId?: SortOrder
    partyId?: SortOrder
    gstNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    party?: PartyOrderByWithRelationAndSearchRelevanceInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    _relevance?: InvoiceOrderByRelevanceInput
  }

  export type InvoiceWhereUniqueInput = {
    id?: string
  }

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    totalGst?: SortOrderInput | SortOrder
    stateOfSupply?: SortOrder
    cgst?: SortOrderInput | SortOrder
    sgst?: SortOrderInput | SortOrder
    igst?: SortOrderInput | SortOrder
    utgst?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    extraDetails?: SortOrderInput | SortOrder
    modeOfPayment?: SortOrder
    credit?: SortOrder
    userId?: SortOrder
    partyId?: SortOrder
    gstNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    invoiceNumber?: StringNullableWithAggregatesFilter | string | null
    type?: EnumInvoiceTypeWithAggregatesFilter | InvoiceType
    totalAmount?: FloatWithAggregatesFilter | number
    totalGst?: FloatNullableWithAggregatesFilter | number | null
    stateOfSupply?: StringWithAggregatesFilter | string
    cgst?: FloatNullableWithAggregatesFilter | number | null
    sgst?: FloatNullableWithAggregatesFilter | number | null
    igst?: FloatNullableWithAggregatesFilter | number | null
    utgst?: FloatNullableWithAggregatesFilter | number | null
    details?: StringNullableWithAggregatesFilter | string | null
    extraDetails?: StringNullableWithAggregatesFilter | string | null
    modeOfPayment?: EnumModeOfPaymentWithAggregatesFilter | ModeOfPayment
    credit?: BoolWithAggregatesFilter | boolean
    userId?: IntWithAggregatesFilter | number
    partyId?: StringWithAggregatesFilter | string
    gstNumber?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter | InvoiceStatus
  }

  export type InvoiceItemWhereInput = {
    AND?: Enumerable<InvoiceItemWhereInput>
    OR?: Enumerable<InvoiceItemWhereInput>
    NOT?: Enumerable<InvoiceItemWhereInput>
    id?: StringFilter | string
    itemId?: StringFilter | string
    quantity?: IntFilter | number
    discount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFilter | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    invoiceId?: SortOrder
    item?: ItemOrderByWithRelationAndSearchRelevanceInput
    invoice?: InvoiceOrderByWithRelationAndSearchRelevanceInput
    _relevance?: InvoiceItemOrderByRelevanceInput
  }

  export type InvoiceItemWhereUniqueInput = {
    id?: string
  }

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    invoiceId?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    itemId?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    discount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    invoiceId?: StringWithAggregatesFilter | string
  }

  export type ServiceWhereInput = {
    AND?: Enumerable<ServiceWhereInput>
    OR?: Enumerable<ServiceWhereInput>
    NOT?: Enumerable<ServiceWhereInput>
    id?: StringFilter | string
    serviceName?: StringFilter | string
    serviceType?: StringNullableFilter | string | null
    imgUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    gst?: DecimalFilter | Decimal | DecimalJsLike | number | string
    documents?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ServiceOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceType?: SortOrderInput | SortOrder
    imgUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    gst?: SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ServiceOrderByRelevanceInput
  }

  export type ServiceWhereUniqueInput = {
    id?: string
  }

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceType?: SortOrderInput | SortOrder
    imgUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    gst?: SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    serviceName?: StringWithAggregatesFilter | string
    serviceType?: StringNullableWithAggregatesFilter | string | null
    imgUrl?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    gst?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    documents?: JsonWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: IntFilter | number
    services?: JsonFilter
    status?: EnumOrderStatusFilter | OrderStatus
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    gst?: DecimalFilter | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFilter | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFilter | string
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OrderOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    services?: SortOrder
    status?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    orderTotal?: SortOrder
    stateOfSupply?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: OrderOrderByRelevanceInput
  }

  export type OrderWhereUniqueInput = {
    id?: number
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    services?: SortOrder
    status?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    orderTotal?: SortOrder
    stateOfSupply?: SortOrder
    userId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    services?: JsonWithAggregatesFilter
    status?: EnumOrderStatusWithAggregatesFilter | OrderStatus
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    gst?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
  }

  export type PaymentWhereInput = {
    AND?: Enumerable<PaymentWhereInput>
    OR?: Enumerable<PaymentWhereInput>
    NOT?: Enumerable<PaymentWhereInput>
    id?: StringFilter | string
    razorpay_order_id?: StringFilter | string
    razorpay_payment_id?: StringFilter | string
    status?: EnumPaymentStatusFilter | PaymentStatus
    userId?: IntFilter | number
    orderId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    razorpay_order_id?: SortOrder
    razorpay_payment_id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = {
    id?: string
  }

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    razorpay_order_id?: SortOrder
    razorpay_payment_id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    razorpay_order_id?: StringWithAggregatesFilter | string
    razorpay_payment_id?: StringWithAggregatesFilter | string
    status?: EnumPaymentStatusWithAggregatesFilter | PaymentStatus
    userId?: IntWithAggregatesFilter | number
    orderId?: IntWithAggregatesFilter | number
  }

  export type LibraryWhereInput = {
    AND?: Enumerable<LibraryWhereInput>
    OR?: Enumerable<LibraryWhereInput>
    NOT?: Enumerable<LibraryWhereInput>
    id?: IntFilter | number
    pan?: StringFilter | string
    section?: StringFilter | string
    sub_section?: StringNullableFilter | string | null
    subject?: StringFilter | string
    ao_order?: StringFilter | string
    itat_no?: StringFilter | string
    rsa_no?: StringNullableFilter | string | null
    bench?: StringFilter | string
    appeal_no?: StringNullableFilter | string | null
    appellant?: StringNullableFilter | string | null
    respondent?: StringFilter | string
    appeal_type?: StringFilter | string
    appeal_filed_by?: StringFilter | string
    order_result?: StringFilter | string
    tribunal_order_date?: StringFilter | string
    assessment_year?: StringFilter | string
    judgment?: StringFilter | string
    conclusion?: StringFilter | string
    download?: StringFilter | string
    upload?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    pan?: SortOrder
    section?: SortOrder
    sub_section?: SortOrderInput | SortOrder
    subject?: SortOrder
    ao_order?: SortOrder
    itat_no?: SortOrder
    rsa_no?: SortOrderInput | SortOrder
    bench?: SortOrder
    appeal_no?: SortOrderInput | SortOrder
    appellant?: SortOrderInput | SortOrder
    respondent?: SortOrder
    appeal_type?: SortOrder
    appeal_filed_by?: SortOrder
    order_result?: SortOrder
    tribunal_order_date?: SortOrder
    assessment_year?: SortOrder
    judgment?: SortOrder
    conclusion?: SortOrder
    download?: SortOrder
    upload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: LibraryOrderByRelevanceInput
  }

  export type LibraryWhereUniqueInput = {
    id?: number
  }

  export type LibraryOrderByWithAggregationInput = {
    id?: SortOrder
    pan?: SortOrder
    section?: SortOrder
    sub_section?: SortOrderInput | SortOrder
    subject?: SortOrder
    ao_order?: SortOrder
    itat_no?: SortOrder
    rsa_no?: SortOrderInput | SortOrder
    bench?: SortOrder
    appeal_no?: SortOrderInput | SortOrder
    appellant?: SortOrderInput | SortOrder
    respondent?: SortOrder
    appeal_type?: SortOrder
    appeal_filed_by?: SortOrder
    order_result?: SortOrder
    tribunal_order_date?: SortOrder
    assessment_year?: SortOrder
    judgment?: SortOrder
    conclusion?: SortOrder
    download?: SortOrder
    upload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryCountOrderByAggregateInput
    _avg?: LibraryAvgOrderByAggregateInput
    _max?: LibraryMaxOrderByAggregateInput
    _min?: LibraryMinOrderByAggregateInput
    _sum?: LibrarySumOrderByAggregateInput
  }

  export type LibraryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pan?: StringWithAggregatesFilter | string
    section?: StringWithAggregatesFilter | string
    sub_section?: StringNullableWithAggregatesFilter | string | null
    subject?: StringWithAggregatesFilter | string
    ao_order?: StringWithAggregatesFilter | string
    itat_no?: StringWithAggregatesFilter | string
    rsa_no?: StringNullableWithAggregatesFilter | string | null
    bench?: StringWithAggregatesFilter | string
    appeal_no?: StringNullableWithAggregatesFilter | string | null
    appellant?: StringNullableWithAggregatesFilter | string | null
    respondent?: StringWithAggregatesFilter | string
    appeal_type?: StringWithAggregatesFilter | string
    appeal_filed_by?: StringWithAggregatesFilter | string
    order_result?: StringWithAggregatesFilter | string
    tribunal_order_date?: StringWithAggregatesFilter | string
    assessment_year?: StringWithAggregatesFilter | string
    judgment?: StringWithAggregatesFilter | string
    conclusion?: StringWithAggregatesFilter | string
    download?: StringWithAggregatesFilter | string
    upload?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: StringFilter | string
    userId?: IntFilter | number
    title?: StringFilter | string
    contentheading?: StringFilter | string
    contentdiscription?: StringFilter | string
    category?: StringFilter | string
    imageUrl?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PostOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    contentheading?: SortOrder
    contentdiscription?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: PostOrderByRelevanceInput
  }

  export type PostWhereUniqueInput = {
    id?: string
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    contentheading?: SortOrder
    contentdiscription?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    contentheading?: StringWithAggregatesFilter | string
    contentdiscription?: StringWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    imageUrl?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    accountName?: StringFilter | string
    totalDebit?: DecimalFilter | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFilter | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type AccountOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    accountName?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    debitBalance?: SortOrder
    creditBalance?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    invoices?: InvoiceOrderByRelationAggregateInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountName?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    debitBalance?: SortOrder
    creditBalance?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    accountName?: StringWithAggregatesFilter | string
    totalDebit?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter | Date | string
    userId?: IntWithAggregatesFilter | number
  }

  export type CareerWhereInput = {
    AND?: Enumerable<CareerWhereInput>
    OR?: Enumerable<CareerWhereInput>
    NOT?: Enumerable<CareerWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringFilter | string
    pin?: StringFilter | string
    email?: StringFilter | string
    mobile?: StringFilter | string
    skills?: StringFilter | string
    gender?: EnumUserGenderFilter | UserGender
    cv?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CareerOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pin?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    skills?: SortOrder
    gender?: SortOrder
    cv?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CareerOrderByRelevanceInput
  }

  export type CareerWhereUniqueInput = {
    id?: number
  }

  export type CareerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pin?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    skills?: SortOrder
    gender?: SortOrder
    cv?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CareerCountOrderByAggregateInput
    _avg?: CareerAvgOrderByAggregateInput
    _max?: CareerMaxOrderByAggregateInput
    _min?: CareerMinOrderByAggregateInput
    _sum?: CareerSumOrderByAggregateInput
  }

  export type CareerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CareerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CareerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CareerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    pin?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    mobile?: StringWithAggregatesFilter | string
    skills?: StringWithAggregatesFilter | string
    gender?: EnumUserGenderWithAggregatesFilter | UserGender
    cv?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BillrecieveWhereInput = {
    AND?: Enumerable<BillrecieveWhereInput>
    OR?: Enumerable<BillrecieveWhereInput>
    NOT?: Enumerable<BillrecieveWhereInput>
    id?: IntFilter | number
    billNumber?: StringFilter | string
    amount?: StringFilter | string
    tax?: StringFilter | string
    customerName?: StringFilter | string
    customerAddress?: StringFilter | string
    contact?: StringFilter | string
    itemQuantity?: StringFilter | string
    itemPrice?: StringFilter | string
    itemDescription?: StringFilter | string
    paymentStatus?: EnumpaymentStatusFilter | paymentStatus
    paymentMethod?: EnumpaymentMethodFilter | paymentMethod
    dueDate?: StringFilter | string
    comment?: StringNullableFilter | string | null
  }

  export type BillrecieveOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    billNumber?: SortOrder
    amount?: SortOrder
    tax?: SortOrder
    customerName?: SortOrder
    customerAddress?: SortOrder
    contact?: SortOrder
    itemQuantity?: SortOrder
    itemPrice?: SortOrder
    itemDescription?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    dueDate?: SortOrder
    comment?: SortOrderInput | SortOrder
    _relevance?: BillrecieveOrderByRelevanceInput
  }

  export type BillrecieveWhereUniqueInput = {
    id?: number
  }

  export type BillrecieveOrderByWithAggregationInput = {
    id?: SortOrder
    billNumber?: SortOrder
    amount?: SortOrder
    tax?: SortOrder
    customerName?: SortOrder
    customerAddress?: SortOrder
    contact?: SortOrder
    itemQuantity?: SortOrder
    itemPrice?: SortOrder
    itemDescription?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    dueDate?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: BillrecieveCountOrderByAggregateInput
    _avg?: BillrecieveAvgOrderByAggregateInput
    _max?: BillrecieveMaxOrderByAggregateInput
    _min?: BillrecieveMinOrderByAggregateInput
    _sum?: BillrecieveSumOrderByAggregateInput
  }

  export type BillrecieveScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BillrecieveScalarWhereWithAggregatesInput>
    OR?: Enumerable<BillrecieveScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BillrecieveScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    billNumber?: StringWithAggregatesFilter | string
    amount?: StringWithAggregatesFilter | string
    tax?: StringWithAggregatesFilter | string
    customerName?: StringWithAggregatesFilter | string
    customerAddress?: StringWithAggregatesFilter | string
    contact?: StringWithAggregatesFilter | string
    itemQuantity?: StringWithAggregatesFilter | string
    itemPrice?: StringWithAggregatesFilter | string
    itemDescription?: StringWithAggregatesFilter | string
    paymentStatus?: EnumpaymentStatusWithAggregatesFilter | paymentStatus
    paymentMethod?: EnumpaymentMethodWithAggregatesFilter | paymentMethod
    dueDate?: StringWithAggregatesFilter | string
    comment?: StringNullableWithAggregatesFilter | string | null
  }

  export type BillpayableWhereInput = {
    AND?: Enumerable<BillpayableWhereInput>
    OR?: Enumerable<BillpayableWhereInput>
    NOT?: Enumerable<BillpayableWhereInput>
    id?: IntFilter | number
    supplierName?: StringFilter | string
    supplierAddress?: StringFilter | string
    contact?: StringFilter | string
    billDate?: StringFilter | string
    dueDate?: StringFilter | string
    billAmount?: StringFilter | string
    billNumber?: StringFilter | string
    billDiscription?: StringFilter | string
    paymentMethod?: EnumpaymentMethodFilter | paymentMethod
    transactionId?: StringNullableFilter | string | null
    paymentDate?: StringFilter | string
    paymentAmount?: StringFilter | string
    tax?: StringFilter | string
    comment?: StringNullableFilter | string | null
    invoiceNumber?: StringNullableFilter | string | null
  }

  export type BillpayableOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    supplierName?: SortOrder
    supplierAddress?: SortOrder
    contact?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrder
    billAmount?: SortOrder
    billNumber?: SortOrder
    billDiscription?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    paymentDate?: SortOrder
    paymentAmount?: SortOrder
    tax?: SortOrder
    comment?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    _relevance?: BillpayableOrderByRelevanceInput
  }

  export type BillpayableWhereUniqueInput = {
    id?: number
  }

  export type BillpayableOrderByWithAggregationInput = {
    id?: SortOrder
    supplierName?: SortOrder
    supplierAddress?: SortOrder
    contact?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrder
    billAmount?: SortOrder
    billNumber?: SortOrder
    billDiscription?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    paymentDate?: SortOrder
    paymentAmount?: SortOrder
    tax?: SortOrder
    comment?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    _count?: BillpayableCountOrderByAggregateInput
    _avg?: BillpayableAvgOrderByAggregateInput
    _max?: BillpayableMaxOrderByAggregateInput
    _min?: BillpayableMinOrderByAggregateInput
    _sum?: BillpayableSumOrderByAggregateInput
  }

  export type BillpayableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BillpayableScalarWhereWithAggregatesInput>
    OR?: Enumerable<BillpayableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BillpayableScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    supplierName?: StringWithAggregatesFilter | string
    supplierAddress?: StringWithAggregatesFilter | string
    contact?: StringWithAggregatesFilter | string
    billDate?: StringWithAggregatesFilter | string
    dueDate?: StringWithAggregatesFilter | string
    billAmount?: StringWithAggregatesFilter | string
    billNumber?: StringWithAggregatesFilter | string
    billDiscription?: StringWithAggregatesFilter | string
    paymentMethod?: EnumpaymentMethodWithAggregatesFilter | paymentMethod
    transactionId?: StringNullableWithAggregatesFilter | string | null
    paymentDate?: StringWithAggregatesFilter | string
    paymentAmount?: StringWithAggregatesFilter | string
    tax?: StringWithAggregatesFilter | string
    comment?: StringNullableWithAggregatesFilter | string | null
    invoiceNumber?: StringNullableWithAggregatesFilter | string | null
  }

  export type UploadedDocumentWhereInput = {
    AND?: Enumerable<UploadedDocumentWhereInput>
    OR?: Enumerable<UploadedDocumentWhereInput>
    NOT?: Enumerable<UploadedDocumentWhereInput>
    id?: StringFilter | string
    userId?: IntFilter | number
    fileName?: StringFilter | string
    applicationId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    docs?: LoanDocumentListRelationFilter
    application?: XOR<LoanApplicationRelationFilter, LoanApplicationWhereInput> | null
  }

  export type UploadedDocumentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    userId?: SortOrder
    fileName?: SortOrder
    applicationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    docs?: LoanDocumentOrderByRelationAggregateInput
    application?: LoanApplicationOrderByWithRelationAndSearchRelevanceInput
    _relevance?: UploadedDocumentOrderByRelevanceInput
  }

  export type UploadedDocumentWhereUniqueInput = {
    id?: string
  }

  export type UploadedDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fileName?: SortOrder
    applicationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UploadedDocumentCountOrderByAggregateInput
    _avg?: UploadedDocumentAvgOrderByAggregateInput
    _max?: UploadedDocumentMaxOrderByAggregateInput
    _min?: UploadedDocumentMinOrderByAggregateInput
    _sum?: UploadedDocumentSumOrderByAggregateInput
  }

  export type UploadedDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UploadedDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<UploadedDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UploadedDocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    fileName?: StringWithAggregatesFilter | string
    applicationId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LoanDocumentWhereInput = {
    AND?: Enumerable<LoanDocumentWhereInput>
    OR?: Enumerable<LoanDocumentWhereInput>
    NOT?: Enumerable<LoanDocumentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    shortName?: StringFilter | string
    mandatory?: BoolFilter | boolean
    type?: EnumDocumentTypeFilter | DocumentType
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    documents?: UploadedDocumentListRelationFilter
    loans?: LoanListRelationFilter
  }

  export type LoanDocumentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    mandatory?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documents?: UploadedDocumentOrderByRelationAggregateInput
    loans?: LoanOrderByRelationAggregateInput
    _relevance?: LoanDocumentOrderByRelevanceInput
  }

  export type LoanDocumentWhereUniqueInput = {
    id?: string
  }

  export type LoanDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    mandatory?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanDocumentCountOrderByAggregateInput
    _max?: LoanDocumentMaxOrderByAggregateInput
    _min?: LoanDocumentMinOrderByAggregateInput
  }

  export type LoanDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoanDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoanDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoanDocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    shortName?: StringWithAggregatesFilter | string
    mandatory?: BoolWithAggregatesFilter | boolean
    type?: EnumDocumentTypeWithAggregatesFilter | DocumentType
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LoanWhereInput = {
    AND?: Enumerable<LoanWhereInput>
    OR?: Enumerable<LoanWhereInput>
    NOT?: Enumerable<LoanWhereInput>
    id?: StringFilter | string
    type?: EnumLoanTypeFilter | LoanType
    name?: StringFilter | string
    shortName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    maxAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    minAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    documents?: LoanDocumentListRelationFilter
    applications?: LoanApplicationListRelationFilter
  }

  export type LoanOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    shortName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    maxAmount?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documents?: LoanDocumentOrderByRelationAggregateInput
    applications?: LoanApplicationOrderByRelationAggregateInput
    _relevance?: LoanOrderByRelevanceInput
  }

  export type LoanWhereUniqueInput = {
    id?: string
  }

  export type LoanOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    shortName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    maxAmount?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanCountOrderByAggregateInput
    _avg?: LoanAvgOrderByAggregateInput
    _max?: LoanMaxOrderByAggregateInput
    _min?: LoanMinOrderByAggregateInput
    _sum?: LoanSumOrderByAggregateInput
  }

  export type LoanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoanScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoanScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumLoanTypeWithAggregatesFilter | LoanType
    name?: StringWithAggregatesFilter | string
    shortName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    maxAmount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    minAmount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LoanApplicationWhereInput = {
    AND?: Enumerable<LoanApplicationWhereInput>
    OR?: Enumerable<LoanApplicationWhereInput>
    NOT?: Enumerable<LoanApplicationWhereInput>
    id?: StringFilter | string
    loanId?: StringFilter | string
    loanAmount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFilter | LoanStatus
    applicantName?: StringFilter | string
    applicantAge?: IntFilter | number
    loanType?: EnumLoanTypeFilter | LoanType
    applicantGender?: EnumUserGenderFilter | UserGender
    nationality?: EnumNationalityFilter | Nationality
    description?: StringFilter | string
    salaried?: BoolFilter | boolean
    bankAccountId?: StringFilter | string
    phone?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    permanentAddress?: StringFilter | string
    userId?: IntFilter | number
    agentId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    loan?: XOR<LoanRelationFilter, LoanWhereInput>
    documents?: UploadedDocumentListRelationFilter
    bankDetails?: XOR<BankDetailsRelationFilter, BankDetailsWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    agent?: XOR<AgentRelationFilter, AgentWhereInput> | null
  }

  export type LoanApplicationOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    loanId?: SortOrder
    loanAmount?: SortOrder
    loanStatus?: SortOrder
    applicantName?: SortOrder
    applicantAge?: SortOrder
    loanType?: SortOrder
    applicantGender?: SortOrder
    nationality?: SortOrder
    description?: SortOrder
    salaried?: SortOrder
    bankAccountId?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    permanentAddress?: SortOrder
    userId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loan?: LoanOrderByWithRelationAndSearchRelevanceInput
    documents?: UploadedDocumentOrderByRelationAggregateInput
    bankDetails?: BankDetailsOrderByWithRelationAndSearchRelevanceInput
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    agent?: AgentOrderByWithRelationAndSearchRelevanceInput
    _relevance?: LoanApplicationOrderByRelevanceInput
  }

  export type LoanApplicationWhereUniqueInput = {
    id?: string
  }

  export type LoanApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    loanAmount?: SortOrder
    loanStatus?: SortOrder
    applicantName?: SortOrder
    applicantAge?: SortOrder
    loanType?: SortOrder
    applicantGender?: SortOrder
    nationality?: SortOrder
    description?: SortOrder
    salaried?: SortOrder
    bankAccountId?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    permanentAddress?: SortOrder
    userId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanApplicationCountOrderByAggregateInput
    _avg?: LoanApplicationAvgOrderByAggregateInput
    _max?: LoanApplicationMaxOrderByAggregateInput
    _min?: LoanApplicationMinOrderByAggregateInput
    _sum?: LoanApplicationSumOrderByAggregateInput
  }

  export type LoanApplicationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoanApplicationScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoanApplicationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoanApplicationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    loanId?: StringWithAggregatesFilter | string
    loanAmount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusWithAggregatesFilter | LoanStatus
    applicantName?: StringWithAggregatesFilter | string
    applicantAge?: IntWithAggregatesFilter | number
    loanType?: EnumLoanTypeWithAggregatesFilter | LoanType
    applicantGender?: EnumUserGenderWithAggregatesFilter | UserGender
    nationality?: EnumNationalityWithAggregatesFilter | Nationality
    description?: StringWithAggregatesFilter | string
    salaried?: BoolWithAggregatesFilter | boolean
    bankAccountId?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    permanentAddress?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    agentId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BankDetailsWhereInput = {
    AND?: Enumerable<BankDetailsWhereInput>
    OR?: Enumerable<BankDetailsWhereInput>
    NOT?: Enumerable<BankDetailsWhereInput>
    id?: StringFilter | string
    accountHolderName?: StringFilter | string
    bankName?: StringFilter | string
    bankAccountNo?: StringFilter | string
    bankIfsc?: StringFilter | string
    bankBranch?: StringFilter | string
    bankAccountType?: EnumBankAccountTypeFilter | BankAccountType
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    loans?: LoanApplicationListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BankDetailsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    accountHolderName?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    bankAccountType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loans?: LoanApplicationOrderByRelationAggregateInput
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: BankDetailsOrderByRelevanceInput
  }

  export type BankDetailsWhereUniqueInput = {
    id?: string
  }

  export type BankDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    accountHolderName?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    bankAccountType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankDetailsCountOrderByAggregateInput
    _avg?: BankDetailsAvgOrderByAggregateInput
    _max?: BankDetailsMaxOrderByAggregateInput
    _min?: BankDetailsMinOrderByAggregateInput
    _sum?: BankDetailsSumOrderByAggregateInput
  }

  export type BankDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BankDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<BankDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BankDetailsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    accountHolderName?: StringWithAggregatesFilter | string
    bankName?: StringWithAggregatesFilter | string
    bankAccountNo?: StringWithAggregatesFilter | string
    bankIfsc?: StringWithAggregatesFilter | string
    bankBranch?: StringWithAggregatesFilter | string
    bankAccountType?: EnumBankAccountTypeWithAggregatesFilter | BankAccountType
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InsuranceWhereInput = {
    AND?: Enumerable<InsuranceWhereInput>
    OR?: Enumerable<InsuranceWhereInput>
    NOT?: Enumerable<InsuranceWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    name?: StringFilter | string
    mobile?: StringFilter | string
    email?: StringFilter | string
    address?: StringFilter | string
    dob?: DateTimeFilter | Date | string
    maritalStatus?: StringFilter | string
    gender?: EnumUserGenderFilter | UserGender
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InsuranceOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    address?: SortOrder
    dob?: SortOrder
    maritalStatus?: SortOrder
    gender?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: InsuranceOrderByRelevanceInput
  }

  export type InsuranceWhereUniqueInput = {
    id?: string
  }

  export type InsuranceOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    address?: SortOrder
    dob?: SortOrder
    maritalStatus?: SortOrder
    gender?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsuranceCountOrderByAggregateInput
    _avg?: InsuranceAvgOrderByAggregateInput
    _max?: InsuranceMaxOrderByAggregateInput
    _min?: InsuranceMinOrderByAggregateInput
    _sum?: InsuranceSumOrderByAggregateInput
  }

  export type InsuranceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InsuranceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InsuranceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InsuranceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    mobile?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    dob?: DateTimeWithAggregatesFilter | Date | string
    maritalStatus?: StringWithAggregatesFilter | string
    gender?: EnumUserGenderWithAggregatesFilter | UserGender
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ClientWhereInput = {
    AND?: Enumerable<ClientWhereInput>
    OR?: Enumerable<ClientWhereInput>
    NOT?: Enumerable<ClientWhereInput>
    id?: StringFilter | string
    userId?: IntFilter | number
    agentId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }

  export type ClientOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    agent?: AgentOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ClientOrderByRelevanceInput
  }

  export type ClientWhereUniqueInput = {
    id?: string
  }

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClientScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClientScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    agentId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AgentWhereInput = {
    AND?: Enumerable<AgentWhereInput>
    OR?: Enumerable<AgentWhereInput>
    NOT?: Enumerable<AgentWhereInput>
    id?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    clients?: ClientListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    loans?: LoanApplicationListRelationFilter
  }

  export type AgentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clients?: ClientOrderByRelationAggregateInput
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    loans?: LoanApplicationOrderByRelationAggregateInput
    _relevance?: AgentOrderByRelevanceInput
  }

  export type AgentWhereUniqueInput = {
    id?: string
    userId?: number
  }

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgentScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VisitorWhereInput = {
    AND?: Enumerable<VisitorWhereInput>
    OR?: Enumerable<VisitorWhereInput>
    NOT?: Enumerable<VisitorWhereInput>
    id?: IntFilter | number
    count?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type VisitorOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitorWhereUniqueInput = {
    id?: number
  }

  export type VisitorOrderByWithAggregationInput = {
    id?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    _count?: VisitorCountOrderByAggregateInput
    _avg?: VisitorAvgOrderByAggregateInput
    _max?: VisitorMaxOrderByAggregateInput
    _min?: VisitorMinOrderByAggregateInput
    _sum?: VisitorSumOrderByAggregateInput
  }

  export type VisitorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VisitorScalarWhereWithAggregatesInput>
    OR?: Enumerable<VisitorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VisitorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    count?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RegisterStartupWhereInput = {
    AND?: Enumerable<RegisterStartupWhereInput>
    OR?: Enumerable<RegisterStartupWhereInput>
    NOT?: Enumerable<RegisterStartupWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    image?: StringFilter | string
    userId?: IntFilter | number
    categories?: EnumStartupCategoryFilter | StartupCategory
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RegisterStartupOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    categories?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: RegisterStartupOrderByRelevanceInput
  }

  export type RegisterStartupWhereUniqueInput = {
    id?: number
  }

  export type RegisterStartupOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    categories?: SortOrder
    _count?: RegisterStartupCountOrderByAggregateInput
    _avg?: RegisterStartupAvgOrderByAggregateInput
    _max?: RegisterStartupMaxOrderByAggregateInput
    _min?: RegisterStartupMinOrderByAggregateInput
    _sum?: RegisterStartupSumOrderByAggregateInput
  }

  export type RegisterStartupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RegisterStartupScalarWhereWithAggregatesInput>
    OR?: Enumerable<RegisterStartupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RegisterStartupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    categories?: EnumStartupCategoryWithAggregatesFilter | StartupCategory
  }

  export type ContactUsWhereInput = {
    AND?: Enumerable<ContactUsWhereInput>
    OR?: Enumerable<ContactUsWhereInput>
    NOT?: Enumerable<ContactUsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    message?: StringFilter | string
    phoneNumber?: StringFilter | string
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ContactUsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    phoneNumber?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ContactUsOrderByRelevanceInput
  }

  export type ContactUsWhereUniqueInput = {
    id?: number
  }

  export type ContactUsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    phoneNumber?: SortOrder
    userId?: SortOrder
    _count?: ContactUsCountOrderByAggregateInput
    _avg?: ContactUsAvgOrderByAggregateInput
    _max?: ContactUsMaxOrderByAggregateInput
    _min?: ContactUsMinOrderByAggregateInput
    _sum?: ContactUsSumOrderByAggregateInput
  }

  export type ContactUsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContactUsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContactUsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContactUsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    phoneNumber?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
  }

  export type AboutWhereInput = {
    AND?: Enumerable<AboutWhereInput>
    OR?: Enumerable<AboutWhereInput>
    NOT?: Enumerable<AboutWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    position?: StringFilter | string
    image?: StringFilter | string
    description?: StringFilter | string
  }

  export type AboutOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    image?: SortOrder
    description?: SortOrder
    _relevance?: AboutOrderByRelevanceInput
  }

  export type AboutWhereUniqueInput = {
    id?: string
  }

  export type AboutOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    image?: SortOrder
    description?: SortOrder
    _count?: AboutCountOrderByAggregateInput
    _max?: AboutMaxOrderByAggregateInput
    _min?: AboutMinOrderByAggregateInput
  }

  export type AboutScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AboutScalarWhereWithAggregatesInput>
    OR?: Enumerable<AboutScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AboutScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    position?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
  }

  export type Gstr1_4AWhereInput = {
    AND?: Enumerable<Gstr1_4AWhereInput>
    OR?: Enumerable<Gstr1_4AWhereInput>
    NOT?: Enumerable<Gstr1_4AWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    LegalName?: StringFilter | string
    GSTN?: StringFilter | string
    pos?: StringFilter | string
    invoice_No?: StringFilter | string
    invoice_date?: StringFilter | string
    invoice_value?: StringFilter | string
    rate?: StringFilter | string
    nature?: StringFilter | string
    source?: StringFilter | string
    cgst?: StringFilter | string
    igst?: StringFilter | string
    sgst?: StringFilter | string
    supply_type?: StringFilter | string
    fy?: StringFilter | string
    period?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type Gstr1_4AOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    userId?: SortOrder
    LegalName?: SortOrder
    GSTN?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    rate?: SortOrder
    nature?: SortOrder
    source?: SortOrder
    cgst?: SortOrder
    igst?: SortOrder
    sgst?: SortOrder
    supply_type?: SortOrder
    fy?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: Gstr1_4AOrderByRelevanceInput
  }

  export type Gstr1_4AWhereUniqueInput = {
    id?: number
  }

  export type Gstr1_4AOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    LegalName?: SortOrder
    GSTN?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    rate?: SortOrder
    nature?: SortOrder
    source?: SortOrder
    cgst?: SortOrder
    igst?: SortOrder
    sgst?: SortOrder
    supply_type?: SortOrder
    fy?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Gstr1_4ACountOrderByAggregateInput
    _avg?: Gstr1_4AAvgOrderByAggregateInput
    _max?: Gstr1_4AMaxOrderByAggregateInput
    _min?: Gstr1_4AMinOrderByAggregateInput
    _sum?: Gstr1_4ASumOrderByAggregateInput
  }

  export type Gstr1_4AScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Gstr1_4AScalarWhereWithAggregatesInput>
    OR?: Enumerable<Gstr1_4AScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Gstr1_4AScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    LegalName?: StringWithAggregatesFilter | string
    GSTN?: StringWithAggregatesFilter | string
    pos?: StringWithAggregatesFilter | string
    invoice_No?: StringWithAggregatesFilter | string
    invoice_date?: StringWithAggregatesFilter | string
    invoice_value?: StringWithAggregatesFilter | string
    rate?: StringWithAggregatesFilter | string
    nature?: StringWithAggregatesFilter | string
    source?: StringWithAggregatesFilter | string
    cgst?: StringWithAggregatesFilter | string
    igst?: StringWithAggregatesFilter | string
    sgst?: StringWithAggregatesFilter | string
    supply_type?: StringWithAggregatesFilter | string
    fy?: StringWithAggregatesFilter | string
    period?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Gstr1_5AWhereInput = {
    AND?: Enumerable<Gstr1_5AWhereInput>
    OR?: Enumerable<Gstr1_5AWhereInput>
    NOT?: Enumerable<Gstr1_5AWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    pos?: StringFilter | string
    invoice_No?: StringFilter | string
    supply_type?: StringFilter | string
    invoice_date?: StringFilter | string
    invoice_value?: StringFilter | string
    total_invoice_value?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    gstr1_5A_items?: Gstr1_5A_itemListRelationFilter
  }

  export type Gstr1_5AOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    userId?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    supply_type?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    total_invoice_value?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    gstr1_5A_items?: Gstr1_5A_itemOrderByRelationAggregateInput
    _relevance?: Gstr1_5AOrderByRelevanceInput
  }

  export type Gstr1_5AWhereUniqueInput = {
    id?: number
  }

  export type Gstr1_5AOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    supply_type?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    total_invoice_value?: SortOrder
    _count?: Gstr1_5ACountOrderByAggregateInput
    _avg?: Gstr1_5AAvgOrderByAggregateInput
    _max?: Gstr1_5AMaxOrderByAggregateInput
    _min?: Gstr1_5AMinOrderByAggregateInput
    _sum?: Gstr1_5ASumOrderByAggregateInput
  }

  export type Gstr1_5AScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Gstr1_5AScalarWhereWithAggregatesInput>
    OR?: Enumerable<Gstr1_5AScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Gstr1_5AScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    pos?: StringWithAggregatesFilter | string
    invoice_No?: StringWithAggregatesFilter | string
    supply_type?: StringWithAggregatesFilter | string
    invoice_date?: StringWithAggregatesFilter | string
    invoice_value?: StringWithAggregatesFilter | string
    total_invoice_value?: StringWithAggregatesFilter | string
  }

  export type Gstr1_5A_itemWhereInput = {
    AND?: Enumerable<Gstr1_5A_itemWhereInput>
    OR?: Enumerable<Gstr1_5A_itemWhereInput>
    NOT?: Enumerable<Gstr1_5A_itemWhereInput>
    id?: IntFilter | number
    SN?: StringFilter | string
    turnover?: StringFilter | string
    cgst?: StringFilter | string
    sgst?: StringFilter | string
    gstr1_5A_id?: IntFilter | number
    gstr1_5A?: XOR<Gstr1_5ARelationFilter, Gstr1_5AWhereInput>
  }

  export type Gstr1_5A_itemOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    SN?: SortOrder
    turnover?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    gstr1_5A_id?: SortOrder
    gstr1_5A?: Gstr1_5AOrderByWithRelationAndSearchRelevanceInput
    _relevance?: Gstr1_5A_itemOrderByRelevanceInput
  }

  export type Gstr1_5A_itemWhereUniqueInput = {
    id?: number
  }

  export type Gstr1_5A_itemOrderByWithAggregationInput = {
    id?: SortOrder
    SN?: SortOrder
    turnover?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    gstr1_5A_id?: SortOrder
    _count?: Gstr1_5A_itemCountOrderByAggregateInput
    _avg?: Gstr1_5A_itemAvgOrderByAggregateInput
    _max?: Gstr1_5A_itemMaxOrderByAggregateInput
    _min?: Gstr1_5A_itemMinOrderByAggregateInput
    _sum?: Gstr1_5A_itemSumOrderByAggregateInput
  }

  export type Gstr1_5A_itemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Gstr1_5A_itemScalarWhereWithAggregatesInput>
    OR?: Enumerable<Gstr1_5A_itemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Gstr1_5A_itemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    SN?: StringWithAggregatesFilter | string
    turnover?: StringWithAggregatesFilter | string
    cgst?: StringWithAggregatesFilter | string
    sgst?: StringWithAggregatesFilter | string
    gstr1_5A_id?: IntWithAggregatesFilter | number
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
  }

  export type OtpCreateInput = {
    createdAt?: Date | string
    otp: string
    used?: boolean
    user: UserCreateNestedOneWithoutOtpsInput
  }

  export type OtpUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    otp: string
    userId: number
    used?: boolean
  }

  export type OtpUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOtpsNestedInput
  }

  export type OtpUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OtpCreateManyInput = {
    id?: number
    createdAt?: Date | string
    otp: string
    userId: number
    used?: boolean
  }

  export type OtpUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BusinessProfileCreateInput = {
    businessName: string
    pan?: string | null
    tan?: string | null
    gstin?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAddressVerified?: boolean | null
    isBusinessNameVerified?: boolean | null
    isGstinVerified?: boolean | null
    isPanVerified?: boolean | null
    isStateVerified?: boolean | null
    user: UserCreateNestedOneWithoutBusinessProfileInput
  }

  export type BusinessProfileUncheckedCreateInput = {
    id?: number
    businessName: string
    pan?: string | null
    tan?: string | null
    gstin?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    state?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAddressVerified?: boolean | null
    isBusinessNameVerified?: boolean | null
    isGstinVerified?: boolean | null
    isPanVerified?: boolean | null
    isStateVerified?: boolean | null
  }

  export type BusinessProfileUpdateInput = {
    businessName?: StringFieldUpdateOperationsInput | string
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAddressVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isBusinessNameVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isGstinVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPanVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isStateVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutBusinessProfileNestedInput
  }

  export type BusinessProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessName?: StringFieldUpdateOperationsInput | string
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAddressVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isBusinessNameVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isGstinVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPanVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isStateVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BusinessProfileCreateManyInput = {
    id?: number
    businessName: string
    pan?: string | null
    tan?: string | null
    gstin?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    state?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAddressVerified?: boolean | null
    isBusinessNameVerified?: boolean | null
    isGstinVerified?: boolean | null
    isPanVerified?: boolean | null
    isStateVerified?: boolean | null
  }

  export type BusinessProfileUpdateManyMutationInput = {
    businessName?: StringFieldUpdateOperationsInput | string
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAddressVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isBusinessNameVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isGstinVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPanVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isStateVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BusinessProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessName?: StringFieldUpdateOperationsInput | string
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAddressVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isBusinessNameVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isGstinVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPanVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isStateVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LedgerCreateInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLegdersInput
    transactions?: TransactionCreateNestedManyWithoutLedgerInput
    party?: PartyCreateNestedOneWithoutLedgersInput
  }

  export type LedgerUncheckedCreateInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    userId: number
    partyId?: string | null
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutLedgerInput
  }

  export type LedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLegdersNestedInput
    transactions?: TransactionUpdateManyWithoutLedgerNestedInput
    party?: PartyUpdateOneWithoutLedgersNestedInput
  }

  export type LedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: IntFieldUpdateOperationsInput | number
    partyId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutLedgerNestedInput
  }

  export type LedgerCreateManyInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    userId: number
    partyId?: string | null
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: IntFieldUpdateOperationsInput | number
    partyId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateInput = {
    id?: string
    entryDate?: Date | string
    description: string
    user: UserCreateNestedOneWithoutJournalEntriesInput
    transactions?: TransactionCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: string
    entryDate?: Date | string
    description: string
    userId: number
    transactions?: TransactionUncheckedCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutJournalEntriesNestedInput
    transactions?: TransactionUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    transactions?: TransactionUncheckedUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryCreateManyInput = {
    id?: string
    entryDate?: Date | string
    description: string
    userId: number
  }

  export type JournalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    ledger: LedgerCreateNestedOneWithoutTransactionsInput
    journalEntry: JournalEntryCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    ledgerId: string
    journalEntryId: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    userId: number
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    ledger?: LedgerUpdateOneRequiredWithoutTransactionsNestedInput
    journalEntry?: JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerId?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyInput = {
    id?: string
    ledgerId: string
    journalEntryId: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    userId: number
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerId?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PartyCreateInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPartyInput
    items?: ItemCreateNestedManyWithoutSupplierInput
    user: UserCreateNestedOneWithoutPartiesInput
    ledgers?: LedgerCreateNestedManyWithoutPartyInput
  }

  export type PartyUncheckedCreateInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPartyInput
    items?: ItemUncheckedCreateNestedManyWithoutSupplierInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutPartyInput
  }

  export type PartyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPartyNestedInput
    items?: ItemUpdateManyWithoutSupplierNestedInput
    user?: UserUpdateOneRequiredWithoutPartiesNestedInput
    ledgers?: LedgerUpdateManyWithoutPartyNestedInput
  }

  export type PartyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPartyNestedInput
    items?: ItemUncheckedUpdateManyWithoutSupplierNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutPartyNestedInput
  }

  export type PartyCreateManyInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    categoryName: string
    user: UserCreateNestedOneWithoutCategoriesInput
    items?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    categoryName: string
    userId: number
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCategoriesNestedInput
    items?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    categoryName: string
    userId: number
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCreateInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutItemsInput
    supplier?: PartyCreateNestedOneWithoutItemsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutItemInput
    user: UserCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    categoryId?: string | null
    supplierId?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutItemsNestedInput
    supplier?: PartyUpdateOneWithoutItemsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutItemNestedInput
    user?: UserUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    categoryId?: string | null
    supplierId?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    user: UserCreateNestedOneWithoutInvoicesInput
    party: PartyCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    accounts?: AccountCreateNestedManyWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    userId: number
    partyId: string
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    party?: PartyUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    accounts?: AccountUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    partyId?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    userId: number
    partyId: string
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    partyId?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
  }

  export type InvoiceItemCreateInput = {
    id?: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutInvoiceItemsInput
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    itemId: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    invoiceId: string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutInvoiceItemsNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    itemId: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    invoiceId: string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    id?: string
    serviceName: string
    serviceType?: string | null
    imgUrl?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    documents: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    serviceName: string
    serviceType?: string | null
    imgUrl?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    documents: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    documents?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    documents?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyInput = {
    id?: string
    serviceName: string
    serviceType?: string | null
    imgUrl?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    documents: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    documents?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    documents?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    services: JsonNullValueInput | InputJsonValue
    status?: OrderStatus
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    orderTotal: Decimal | DecimalJsLike | number | string
    stateOfSupply: string
    user: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    services: JsonNullValueInput | InputJsonValue
    status?: OrderStatus
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    orderTotal: Decimal | DecimalJsLike | number | string
    stateOfSupply: string
    userId: number
  }

  export type OrderUpdateInput = {
    services?: JsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    services?: JsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderCreateManyInput = {
    id?: number
    services: JsonNullValueInput | InputJsonValue
    status?: OrderStatus
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    orderTotal: Decimal | DecimalJsLike | number | string
    stateOfSupply: string
    userId: number
  }

  export type OrderUpdateManyMutationInput = {
    services?: JsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    services?: JsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateInput = {
    id?: string
    razorpay_order_id: string
    razorpay_payment_id: string
    status?: PaymentStatus
    orderId: number
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    razorpay_order_id: string
    razorpay_payment_id: string
    status?: PaymentStatus
    userId: number
    orderId: number
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpay_order_id?: StringFieldUpdateOperationsInput | string
    razorpay_payment_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    orderId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpay_order_id?: StringFieldUpdateOperationsInput | string
    razorpay_payment_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateManyInput = {
    id?: string
    razorpay_order_id: string
    razorpay_payment_id: string
    status?: PaymentStatus
    userId: number
    orderId: number
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpay_order_id?: StringFieldUpdateOperationsInput | string
    razorpay_payment_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpay_order_id?: StringFieldUpdateOperationsInput | string
    razorpay_payment_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryCreateInput = {
    pan: string
    section: string
    sub_section?: string | null
    subject: string
    ao_order: string
    itat_no: string
    rsa_no?: string | null
    bench: string
    appeal_no?: string | null
    appellant?: string | null
    respondent: string
    appeal_type: string
    appeal_filed_by: string
    order_result: string
    tribunal_order_date: string
    assessment_year: string
    judgment: string
    conclusion: string
    download: string
    upload?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUncheckedCreateInput = {
    id?: number
    pan: string
    section: string
    sub_section?: string | null
    subject: string
    ao_order: string
    itat_no: string
    rsa_no?: string | null
    bench: string
    appeal_no?: string | null
    appellant?: string | null
    respondent: string
    appeal_type: string
    appeal_filed_by: string
    order_result: string
    tribunal_order_date: string
    assessment_year: string
    judgment: string
    conclusion: string
    download: string
    upload?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUpdateInput = {
    pan?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    sub_section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    ao_order?: StringFieldUpdateOperationsInput | string
    itat_no?: StringFieldUpdateOperationsInput | string
    rsa_no?: NullableStringFieldUpdateOperationsInput | string | null
    bench?: StringFieldUpdateOperationsInput | string
    appeal_no?: NullableStringFieldUpdateOperationsInput | string | null
    appellant?: NullableStringFieldUpdateOperationsInput | string | null
    respondent?: StringFieldUpdateOperationsInput | string
    appeal_type?: StringFieldUpdateOperationsInput | string
    appeal_filed_by?: StringFieldUpdateOperationsInput | string
    order_result?: StringFieldUpdateOperationsInput | string
    tribunal_order_date?: StringFieldUpdateOperationsInput | string
    assessment_year?: StringFieldUpdateOperationsInput | string
    judgment?: StringFieldUpdateOperationsInput | string
    conclusion?: StringFieldUpdateOperationsInput | string
    download?: StringFieldUpdateOperationsInput | string
    upload?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    sub_section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    ao_order?: StringFieldUpdateOperationsInput | string
    itat_no?: StringFieldUpdateOperationsInput | string
    rsa_no?: NullableStringFieldUpdateOperationsInput | string | null
    bench?: StringFieldUpdateOperationsInput | string
    appeal_no?: NullableStringFieldUpdateOperationsInput | string | null
    appellant?: NullableStringFieldUpdateOperationsInput | string | null
    respondent?: StringFieldUpdateOperationsInput | string
    appeal_type?: StringFieldUpdateOperationsInput | string
    appeal_filed_by?: StringFieldUpdateOperationsInput | string
    order_result?: StringFieldUpdateOperationsInput | string
    tribunal_order_date?: StringFieldUpdateOperationsInput | string
    assessment_year?: StringFieldUpdateOperationsInput | string
    judgment?: StringFieldUpdateOperationsInput | string
    conclusion?: StringFieldUpdateOperationsInput | string
    download?: StringFieldUpdateOperationsInput | string
    upload?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCreateManyInput = {
    id?: number
    pan: string
    section: string
    sub_section?: string | null
    subject: string
    ao_order: string
    itat_no: string
    rsa_no?: string | null
    bench: string
    appeal_no?: string | null
    appellant?: string | null
    respondent: string
    appeal_type: string
    appeal_filed_by: string
    order_result: string
    tribunal_order_date: string
    assessment_year: string
    judgment: string
    conclusion: string
    download: string
    upload?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUpdateManyMutationInput = {
    pan?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    sub_section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    ao_order?: StringFieldUpdateOperationsInput | string
    itat_no?: StringFieldUpdateOperationsInput | string
    rsa_no?: NullableStringFieldUpdateOperationsInput | string | null
    bench?: StringFieldUpdateOperationsInput | string
    appeal_no?: NullableStringFieldUpdateOperationsInput | string | null
    appellant?: NullableStringFieldUpdateOperationsInput | string | null
    respondent?: StringFieldUpdateOperationsInput | string
    appeal_type?: StringFieldUpdateOperationsInput | string
    appeal_filed_by?: StringFieldUpdateOperationsInput | string
    order_result?: StringFieldUpdateOperationsInput | string
    tribunal_order_date?: StringFieldUpdateOperationsInput | string
    assessment_year?: StringFieldUpdateOperationsInput | string
    judgment?: StringFieldUpdateOperationsInput | string
    conclusion?: StringFieldUpdateOperationsInput | string
    download?: StringFieldUpdateOperationsInput | string
    upload?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pan?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    sub_section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    ao_order?: StringFieldUpdateOperationsInput | string
    itat_no?: StringFieldUpdateOperationsInput | string
    rsa_no?: NullableStringFieldUpdateOperationsInput | string | null
    bench?: StringFieldUpdateOperationsInput | string
    appeal_no?: NullableStringFieldUpdateOperationsInput | string | null
    appellant?: NullableStringFieldUpdateOperationsInput | string | null
    respondent?: StringFieldUpdateOperationsInput | string
    appeal_type?: StringFieldUpdateOperationsInput | string
    appeal_filed_by?: StringFieldUpdateOperationsInput | string
    order_result?: StringFieldUpdateOperationsInput | string
    tribunal_order_date?: StringFieldUpdateOperationsInput | string
    assessment_year?: StringFieldUpdateOperationsInput | string
    judgment?: StringFieldUpdateOperationsInput | string
    conclusion?: StringFieldUpdateOperationsInput | string
    download?: StringFieldUpdateOperationsInput | string
    upload?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    title: string
    contentheading: string
    contentdiscription: string
    category: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    userId: number
    title: string
    contentheading: string
    contentdiscription: string
    category: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    contentheading?: StringFieldUpdateOperationsInput | string
    contentdiscription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    contentheading?: StringFieldUpdateOperationsInput | string
    contentdiscription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyInput = {
    id?: string
    userId: number
    title: string
    contentheading: string
    contentdiscription: string
    category: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    contentheading?: StringFieldUpdateOperationsInput | string
    contentdiscription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    contentheading?: StringFieldUpdateOperationsInput | string
    contentdiscription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountName: string
    totalDebit?: Decimal | DecimalJsLike | number | string
    totalCredit?: Decimal | DecimalJsLike | number | string
    debitBalance?: Decimal | DecimalJsLike | number | string
    creditBalance?: Decimal | DecimalJsLike | number | string
    date?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
    invoices?: InvoiceCreateNestedManyWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountName: string
    totalDebit?: Decimal | DecimalJsLike | number | string
    totalCredit?: Decimal | DecimalJsLike | number | string
    debitBalance?: Decimal | DecimalJsLike | number | string
    creditBalance?: Decimal | DecimalJsLike | number | string
    date?: Date | string
    userId: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    accountName: string
    totalDebit?: Decimal | DecimalJsLike | number | string
    totalCredit?: Decimal | DecimalJsLike | number | string
    debitBalance?: Decimal | DecimalJsLike | number | string
    creditBalance?: Decimal | DecimalJsLike | number | string
    date?: Date | string
    userId: number
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CareerCreateInput = {
    name: string
    address: string
    pin: string
    email: string
    mobile: string
    skills: string
    gender: UserGender
    cv: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    pin: string
    email: string
    mobile: string
    skills: string
    gender: UserGender
    cv: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    cv?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    cv?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerCreateManyInput = {
    id?: number
    name: string
    address: string
    pin: string
    email: string
    mobile: string
    skills: string
    gender: UserGender
    cv: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    cv?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    cv?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillrecieveCreateInput = {
    billNumber: string
    amount: string
    tax: string
    customerName: string
    customerAddress: string
    contact: string
    itemQuantity: string
    itemPrice: string
    itemDescription: string
    paymentStatus?: paymentStatus
    paymentMethod?: paymentMethod
    dueDate: string
    comment?: string | null
  }

  export type BillrecieveUncheckedCreateInput = {
    id?: number
    billNumber: string
    amount: string
    tax: string
    customerName: string
    customerAddress: string
    contact: string
    itemQuantity: string
    itemPrice: string
    itemDescription: string
    paymentStatus?: paymentStatus
    paymentMethod?: paymentMethod
    dueDate: string
    comment?: string | null
  }

  export type BillrecieveUpdateInput = {
    billNumber?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    tax?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerAddress?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    itemQuantity?: StringFieldUpdateOperationsInput | string
    itemPrice?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumpaymentStatusFieldUpdateOperationsInput | paymentStatus
    paymentMethod?: EnumpaymentMethodFieldUpdateOperationsInput | paymentMethod
    dueDate?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillrecieveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    tax?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerAddress?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    itemQuantity?: StringFieldUpdateOperationsInput | string
    itemPrice?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumpaymentStatusFieldUpdateOperationsInput | paymentStatus
    paymentMethod?: EnumpaymentMethodFieldUpdateOperationsInput | paymentMethod
    dueDate?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillrecieveCreateManyInput = {
    id?: number
    billNumber: string
    amount: string
    tax: string
    customerName: string
    customerAddress: string
    contact: string
    itemQuantity: string
    itemPrice: string
    itemDescription: string
    paymentStatus?: paymentStatus
    paymentMethod?: paymentMethod
    dueDate: string
    comment?: string | null
  }

  export type BillrecieveUpdateManyMutationInput = {
    billNumber?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    tax?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerAddress?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    itemQuantity?: StringFieldUpdateOperationsInput | string
    itemPrice?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumpaymentStatusFieldUpdateOperationsInput | paymentStatus
    paymentMethod?: EnumpaymentMethodFieldUpdateOperationsInput | paymentMethod
    dueDate?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillrecieveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    tax?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerAddress?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    itemQuantity?: StringFieldUpdateOperationsInput | string
    itemPrice?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumpaymentStatusFieldUpdateOperationsInput | paymentStatus
    paymentMethod?: EnumpaymentMethodFieldUpdateOperationsInput | paymentMethod
    dueDate?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillpayableCreateInput = {
    supplierName: string
    supplierAddress: string
    contact: string
    billDate: string
    dueDate: string
    billAmount: string
    billNumber: string
    billDiscription: string
    paymentMethod?: paymentMethod
    transactionId?: string | null
    paymentDate: string
    paymentAmount: string
    tax: string
    comment?: string | null
    invoiceNumber?: string | null
  }

  export type BillpayableUncheckedCreateInput = {
    id?: number
    supplierName: string
    supplierAddress: string
    contact: string
    billDate: string
    dueDate: string
    billAmount: string
    billNumber: string
    billDiscription: string
    paymentMethod?: paymentMethod
    transactionId?: string | null
    paymentDate: string
    paymentAmount: string
    tax: string
    comment?: string | null
    invoiceNumber?: string | null
  }

  export type BillpayableUpdateInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    supplierAddress?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    billDate?: StringFieldUpdateOperationsInput | string
    dueDate?: StringFieldUpdateOperationsInput | string
    billAmount?: StringFieldUpdateOperationsInput | string
    billNumber?: StringFieldUpdateOperationsInput | string
    billDiscription?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumpaymentMethodFieldUpdateOperationsInput | paymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: StringFieldUpdateOperationsInput | string
    paymentAmount?: StringFieldUpdateOperationsInput | string
    tax?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillpayableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    supplierAddress?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    billDate?: StringFieldUpdateOperationsInput | string
    dueDate?: StringFieldUpdateOperationsInput | string
    billAmount?: StringFieldUpdateOperationsInput | string
    billNumber?: StringFieldUpdateOperationsInput | string
    billDiscription?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumpaymentMethodFieldUpdateOperationsInput | paymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: StringFieldUpdateOperationsInput | string
    paymentAmount?: StringFieldUpdateOperationsInput | string
    tax?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillpayableCreateManyInput = {
    id?: number
    supplierName: string
    supplierAddress: string
    contact: string
    billDate: string
    dueDate: string
    billAmount: string
    billNumber: string
    billDiscription: string
    paymentMethod?: paymentMethod
    transactionId?: string | null
    paymentDate: string
    paymentAmount: string
    tax: string
    comment?: string | null
    invoiceNumber?: string | null
  }

  export type BillpayableUpdateManyMutationInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    supplierAddress?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    billDate?: StringFieldUpdateOperationsInput | string
    dueDate?: StringFieldUpdateOperationsInput | string
    billAmount?: StringFieldUpdateOperationsInput | string
    billNumber?: StringFieldUpdateOperationsInput | string
    billDiscription?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumpaymentMethodFieldUpdateOperationsInput | paymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: StringFieldUpdateOperationsInput | string
    paymentAmount?: StringFieldUpdateOperationsInput | string
    tax?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillpayableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    supplierAddress?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    billDate?: StringFieldUpdateOperationsInput | string
    dueDate?: StringFieldUpdateOperationsInput | string
    billAmount?: StringFieldUpdateOperationsInput | string
    billNumber?: StringFieldUpdateOperationsInput | string
    billDiscription?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumpaymentMethodFieldUpdateOperationsInput | paymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: StringFieldUpdateOperationsInput | string
    paymentAmount?: StringFieldUpdateOperationsInput | string
    tax?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UploadedDocumentCreateInput = {
    id?: string
    fileName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    docs?: LoanDocumentCreateNestedManyWithoutDocumentsInput
    application?: LoanApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type UploadedDocumentUncheckedCreateInput = {
    id?: string
    userId: number
    fileName: string
    applicationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    docs?: LoanDocumentUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type UploadedDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    docs?: LoanDocumentUpdateManyWithoutDocumentsNestedInput
    application?: LoanApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type UploadedDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    docs?: LoanDocumentUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type UploadedDocumentCreateManyInput = {
    id?: string
    userId: number
    fileName: string
    applicationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanDocumentCreateInput = {
    id?: string
    name: string
    shortName: string
    mandatory?: boolean
    type: DocumentType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentCreateNestedManyWithoutDocsInput
    loans?: LoanCreateNestedManyWithoutDocumentsInput
  }

  export type LoanDocumentUncheckedCreateInput = {
    id?: string
    name: string
    shortName: string
    mandatory?: boolean
    type: DocumentType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutDocsInput
    loans?: LoanUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type LoanDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUpdateManyWithoutDocsNestedInput
    loans?: LoanUpdateManyWithoutDocumentsNestedInput
  }

  export type LoanDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUncheckedUpdateManyWithoutDocsNestedInput
    loans?: LoanUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type LoanDocumentCreateManyInput = {
    id?: string
    name: string
    shortName: string
    mandatory?: boolean
    type: DocumentType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanCreateInput = {
    id?: string
    type: LoanType
    name: string
    shortName?: string | null
    description?: string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    interest: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: LoanDocumentCreateNestedManyWithoutLoansInput
    applications?: LoanApplicationCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateInput = {
    id?: string
    type: LoanType
    name: string
    shortName?: string | null
    description?: string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    interest: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: LoanDocumentUncheckedCreateNestedManyWithoutLoansInput
    applications?: LoanApplicationUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: LoanDocumentUpdateManyWithoutLoansNestedInput
    applications?: LoanApplicationUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: LoanDocumentUncheckedUpdateManyWithoutLoansNestedInput
    applications?: LoanApplicationUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoanCreateManyInput = {
    id?: string
    type: LoanType
    name: string
    shortName?: string | null
    description?: string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    interest: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationCreateInput = {
    id?: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutApplicationsInput
    documents?: UploadedDocumentCreateNestedManyWithoutApplicationInput
    bankDetails: BankDetailsCreateNestedOneWithoutLoansInput
    user: UserCreateNestedOneWithoutLoansInput
    agent?: AgentCreateNestedOneWithoutLoansInput
  }

  export type LoanApplicationUncheckedCreateInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type LoanApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutApplicationsNestedInput
    documents?: UploadedDocumentUpdateManyWithoutApplicationNestedInput
    bankDetails?: BankDetailsUpdateOneRequiredWithoutLoansNestedInput
    user?: UserUpdateOneRequiredWithoutLoansNestedInput
    agent?: AgentUpdateOneWithoutLoansNestedInput
  }

  export type LoanApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    bankAccountId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type LoanApplicationCreateManyInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    bankAccountId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailsCreateInput = {
    id?: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    createdAt?: Date | string
    updatedAt?: Date | string
    loans?: LoanApplicationCreateNestedManyWithoutBankDetailsInput
    user: UserCreateNestedOneWithoutBankAccountsInput
  }

  export type BankDetailsUncheckedCreateInput = {
    id?: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutBankDetailsInput
  }

  export type BankDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanApplicationUpdateManyWithoutBankDetailsNestedInput
    user?: UserUpdateOneRequiredWithoutBankAccountsNestedInput
  }

  export type BankDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanApplicationUncheckedUpdateManyWithoutBankDetailsNestedInput
  }

  export type BankDetailsCreateManyInput = {
    id?: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceCreateInput = {
    id?: string
    type: string
    name: string
    mobile: string
    email: string
    address: string
    dob: Date | string
    maritalStatus: string
    gender: UserGender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsurancesInput
  }

  export type InsuranceUncheckedCreateInput = {
    id?: string
    type: string
    name: string
    mobile: string
    email: string
    address: string
    dob: Date | string
    maritalStatus: string
    gender: UserGender
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsurancesNestedInput
  }

  export type InsuranceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceCreateManyInput = {
    id?: string
    type: string
    name: string
    mobile: string
    email: string
    address: string
    dob: Date | string
    maritalStatus: string
    gender: UserGender
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientAccountsInput
    agent: AgentCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    userId: number
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientAccountsNestedInput
    agent?: AgentUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateManyInput = {
    id?: string
    userId: number
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentIdInput
    loans?: LoanApplicationCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientUncheckedCreateNestedManyWithoutAgentInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentIdNestedInput
    loans?: LoanApplicationUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUncheckedUpdateManyWithoutAgentNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateInput = {
    count?: number
    createdAt?: Date | string
  }

  export type VisitorUncheckedCreateInput = {
    id?: number
    count?: number
    createdAt?: Date | string
  }

  export type VisitorUpdateInput = {
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateManyInput = {
    id?: number
    count?: number
    createdAt?: Date | string
  }

  export type VisitorUpdateManyMutationInput = {
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisterStartupCreateInput = {
    title: string
    image: string
    categories: StartupCategory
    user: UserCreateNestedOneWithoutRegisterStartupInput
  }

  export type RegisterStartupUncheckedCreateInput = {
    id?: number
    title: string
    image: string
    userId: number
    categories: StartupCategory
  }

  export type RegisterStartupUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    categories?: EnumStartupCategoryFieldUpdateOperationsInput | StartupCategory
    user?: UserUpdateOneRequiredWithoutRegisterStartupNestedInput
  }

  export type RegisterStartupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: EnumStartupCategoryFieldUpdateOperationsInput | StartupCategory
  }

  export type RegisterStartupCreateManyInput = {
    id?: number
    title: string
    image: string
    userId: number
    categories: StartupCategory
  }

  export type RegisterStartupUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    categories?: EnumStartupCategoryFieldUpdateOperationsInput | StartupCategory
  }

  export type RegisterStartupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    categories?: EnumStartupCategoryFieldUpdateOperationsInput | StartupCategory
  }

  export type ContactUsCreateInput = {
    name: string
    email: string
    message: string
    phoneNumber: string
    user: UserCreateNestedOneWithoutContactUsInput
  }

  export type ContactUsUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    message: string
    phoneNumber: string
    userId: number
  }

  export type ContactUsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutContactUsNestedInput
  }

  export type ContactUsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactUsCreateManyInput = {
    id?: number
    name: string
    email: string
    message: string
    phoneNumber: string
    userId: number
  }

  export type ContactUsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AboutCreateInput = {
    id?: string
    name: string
    position: string
    image: string
    description: string
  }

  export type AboutUncheckedCreateInput = {
    id?: string
    name: string
    position: string
    image: string
    description: string
  }

  export type AboutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AboutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AboutCreateManyInput = {
    id?: string
    name: string
    position: string
    image: string
    description: string
  }

  export type AboutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AboutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Gstr1_4ACreateInput = {
    LegalName: string
    GSTN: string
    pos: string
    invoice_No: string
    invoice_date: string
    invoice_value: string
    rate: string
    nature: string
    source: string
    cgst: string
    igst: string
    sgst: string
    supply_type: string
    fy: string
    period: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGstr1Input
  }

  export type Gstr1_4AUncheckedCreateInput = {
    id?: number
    userId: number
    LegalName: string
    GSTN: string
    pos: string
    invoice_No: string
    invoice_date: string
    invoice_value: string
    rate: string
    nature: string
    source: string
    cgst: string
    igst: string
    sgst: string
    supply_type: string
    fy: string
    period: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Gstr1_4AUpdateInput = {
    LegalName?: StringFieldUpdateOperationsInput | string
    GSTN?: StringFieldUpdateOperationsInput | string
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    igst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    fy?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGstr1NestedInput
  }

  export type Gstr1_4AUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    LegalName?: StringFieldUpdateOperationsInput | string
    GSTN?: StringFieldUpdateOperationsInput | string
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    igst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    fy?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Gstr1_4ACreateManyInput = {
    id?: number
    userId: number
    LegalName: string
    GSTN: string
    pos: string
    invoice_No: string
    invoice_date: string
    invoice_value: string
    rate: string
    nature: string
    source: string
    cgst: string
    igst: string
    sgst: string
    supply_type: string
    fy: string
    period: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Gstr1_4AUpdateManyMutationInput = {
    LegalName?: StringFieldUpdateOperationsInput | string
    GSTN?: StringFieldUpdateOperationsInput | string
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    igst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    fy?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Gstr1_4AUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    LegalName?: StringFieldUpdateOperationsInput | string
    GSTN?: StringFieldUpdateOperationsInput | string
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    igst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    fy?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Gstr1_5ACreateInput = {
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
    user: UserCreateNestedOneWithoutGstr1_5AInput
    gstr1_5A_items?: Gstr1_5A_itemCreateNestedManyWithoutGstr1_5AInput
  }

  export type Gstr1_5AUncheckedCreateInput = {
    id?: number
    userId: number
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
    gstr1_5A_items?: Gstr1_5A_itemUncheckedCreateNestedManyWithoutGstr1_5AInput
  }

  export type Gstr1_5AUpdateInput = {
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutGstr1_5ANestedInput
    gstr1_5A_items?: Gstr1_5A_itemUpdateManyWithoutGstr1_5ANestedInput
  }

  export type Gstr1_5AUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
    gstr1_5A_items?: Gstr1_5A_itemUncheckedUpdateManyWithoutGstr1_5ANestedInput
  }

  export type Gstr1_5ACreateManyInput = {
    id?: number
    userId: number
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
  }

  export type Gstr1_5AUpdateManyMutationInput = {
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
  }

  export type Gstr1_5AUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
  }

  export type Gstr1_5A_itemCreateInput = {
    SN?: string
    turnover: string
    cgst: string
    sgst: string
    gstr1_5A: Gstr1_5ACreateNestedOneWithoutGstr1_5A_itemsInput
  }

  export type Gstr1_5A_itemUncheckedCreateInput = {
    id?: number
    SN?: string
    turnover: string
    cgst: string
    sgst: string
    gstr1_5A_id: number
  }

  export type Gstr1_5A_itemUpdateInput = {
    SN?: StringFieldUpdateOperationsInput | string
    turnover?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    gstr1_5A?: Gstr1_5AUpdateOneRequiredWithoutGstr1_5A_itemsNestedInput
  }

  export type Gstr1_5A_itemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    SN?: StringFieldUpdateOperationsInput | string
    turnover?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    gstr1_5A_id?: IntFieldUpdateOperationsInput | number
  }

  export type Gstr1_5A_itemCreateManyInput = {
    id?: number
    SN?: string
    turnover: string
    cgst: string
    sgst: string
    gstr1_5A_id: number
  }

  export type Gstr1_5A_itemUpdateManyMutationInput = {
    SN?: StringFieldUpdateOperationsInput | string
    turnover?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
  }

  export type Gstr1_5A_itemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    SN?: StringFieldUpdateOperationsInput | string
    turnover?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    gstr1_5A_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumUserGenderFilter = {
    equals?: UserGender
    in?: Enumerable<UserGender>
    notIn?: Enumerable<UserGender>
    not?: NestedEnumUserGenderFilter | UserGender
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type OtpListRelationFilter = {
    every?: OtpWhereInput
    some?: OtpWhereInput
    none?: OtpWhereInput
  }

  export type BusinessProfileRelationFilter = {
    is?: BusinessProfileWhereInput | null
    isNot?: BusinessProfileWhereInput | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type PartyListRelationFilter = {
    every?: PartyWhereInput
    some?: PartyWhereInput
    none?: PartyWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type BankDetailsListRelationFilter = {
    every?: BankDetailsWhereInput
    some?: BankDetailsWhereInput
    none?: BankDetailsWhereInput
  }

  export type LoanApplicationListRelationFilter = {
    every?: LoanApplicationWhereInput
    some?: LoanApplicationWhereInput
    none?: LoanApplicationWhereInput
  }

  export type UploadedDocumentListRelationFilter = {
    every?: UploadedDocumentWhereInput
    some?: UploadedDocumentWhereInput
    none?: UploadedDocumentWhereInput
  }

  export type InsuranceListRelationFilter = {
    every?: InsuranceWhereInput
    some?: InsuranceWhereInput
    none?: InsuranceWhereInput
  }

  export type RegisterStartupListRelationFilter = {
    every?: RegisterStartupWhereInput
    some?: RegisterStartupWhereInput
    none?: RegisterStartupWhereInput
  }

  export type ContactUsListRelationFilter = {
    every?: ContactUsWhereInput
    some?: ContactUsWhereInput
    none?: ContactUsWhereInput
  }

  export type JournalEntryListRelationFilter = {
    every?: JournalEntryWhereInput
    some?: JournalEntryWhereInput
    none?: JournalEntryWhereInput
  }

  export type LedgerListRelationFilter = {
    every?: LedgerWhereInput
    some?: LedgerWhereInput
    none?: LedgerWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type AgentRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type Gstr1_4AListRelationFilter = {
    every?: Gstr1_4AWhereInput
    some?: Gstr1_4AWhereInput
    none?: Gstr1_4AWhereInput
  }

  export type Gstr1_5AListRelationFilter = {
    every?: Gstr1_5AWhereInput
    some?: Gstr1_5AWhereInput
    none?: Gstr1_5AWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OtpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UploadedDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsuranceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegisterStartupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactUsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Gstr1_4AOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Gstr1_5AOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: Enumerable<UserOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fatherName?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    pin?: SortOrder
    aadhaar?: SortOrder
    pan?: SortOrder
    dob?: SortOrder
    avatar?: SortOrder
    adminId?: SortOrder
    superadminId?: SortOrder
    verified?: SortOrder
    userType?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    superadminId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fatherName?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    pin?: SortOrder
    aadhaar?: SortOrder
    pan?: SortOrder
    dob?: SortOrder
    avatar?: SortOrder
    adminId?: SortOrder
    superadminId?: SortOrder
    verified?: SortOrder
    userType?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fatherName?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    pin?: SortOrder
    aadhaar?: SortOrder
    pan?: SortOrder
    dob?: SortOrder
    avatar?: SortOrder
    adminId?: SortOrder
    superadminId?: SortOrder
    verified?: SortOrder
    userType?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    superadminId?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumUserGenderWithAggregatesFilter = {
    equals?: UserGender
    in?: Enumerable<UserGender>
    notIn?: Enumerable<UserGender>
    not?: NestedEnumUserGenderWithAggregatesFilter | UserGender
    _count?: NestedIntFilter
    _min?: NestedEnumUserGenderFilter
    _max?: NestedEnumUserGenderFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type OtpOrderByRelevanceInput = {
    fields: Enumerable<OtpOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    otp?: SortOrder
    userId?: SortOrder
    used?: SortOrder
  }

  export type OtpAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    otp?: SortOrder
    userId?: SortOrder
    used?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    otp?: SortOrder
    userId?: SortOrder
    used?: SortOrder
  }

  export type OtpSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type BusinessProfileOrderByRelevanceInput = {
    fields: Enumerable<BusinessProfileOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type BusinessProfileCountOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    gstin?: SortOrder
    address?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    state?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAddressVerified?: SortOrder
    isBusinessNameVerified?: SortOrder
    isGstinVerified?: SortOrder
    isPanVerified?: SortOrder
    isStateVerified?: SortOrder
  }

  export type BusinessProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BusinessProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    gstin?: SortOrder
    address?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    state?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAddressVerified?: SortOrder
    isBusinessNameVerified?: SortOrder
    isGstinVerified?: SortOrder
    isPanVerified?: SortOrder
    isStateVerified?: SortOrder
  }

  export type BusinessProfileMinOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    gstin?: SortOrder
    address?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    state?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAddressVerified?: SortOrder
    isBusinessNameVerified?: SortOrder
    isGstinVerified?: SortOrder
    isPanVerified?: SortOrder
    isStateVerified?: SortOrder
  }

  export type BusinessProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type EnumLedgerTypeFilter = {
    equals?: LedgerType
    in?: Enumerable<LedgerType>
    notIn?: Enumerable<LedgerType>
    not?: NestedEnumLedgerTypeFilter | LedgerType
  }

  export type PartyRelationFilter = {
    is?: PartyWhereInput | null
    isNot?: PartyWhereInput | null
  }

  export type LedgerOrderByRelevanceInput = {
    fields: Enumerable<LedgerOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LedgerCountOrderByAggregateInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    openingBalance?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    partyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    ledgerType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerAvgOrderByAggregateInput = {
    openingBalance?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
  }

  export type LedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    openingBalance?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    partyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    ledgerType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerMinOrderByAggregateInput = {
    id?: SortOrder
    ledgerName?: SortOrder
    openingBalance?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    partyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    ledgerType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerSumOrderByAggregateInput = {
    openingBalance?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type EnumLedgerTypeWithAggregatesFilter = {
    equals?: LedgerType
    in?: Enumerable<LedgerType>
    notIn?: Enumerable<LedgerType>
    not?: NestedEnumLedgerTypeWithAggregatesFilter | LedgerType
    _count?: NestedIntFilter
    _min?: NestedEnumLedgerTypeFilter
    _max?: NestedEnumLedgerTypeFilter
  }

  export type JournalEntryOrderByRelevanceInput = {
    fields: Enumerable<JournalEntryOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    entryDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type JournalEntryAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    entryDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    entryDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type JournalEntrySumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumTransactionTypeFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeFilter | TransactionType
  }

  export type LedgerRelationFilter = {
    is?: LedgerWhereInput | null
    isNot?: LedgerWhereInput | null
  }

  export type JournalEntryRelationFilter = {
    is?: JournalEntryWhereInput | null
    isNot?: JournalEntryWhereInput | null
  }

  export type TransactionOrderByRelevanceInput = {
    fields: Enumerable<TransactionOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    ledgerId?: SortOrder
    journalEntryId?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    userId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    userId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    ledgerId?: SortOrder
    journalEntryId?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    userId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    ledgerId?: SortOrder
    journalEntryId?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    userId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    userId?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeWithAggregatesFilter | TransactionType
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionTypeFilter
    _max?: NestedEnumTransactionTypeFilter
  }

  export type EnumPartyTypeFilter = {
    equals?: PartyType
    in?: Enumerable<PartyType>
    notIn?: Enumerable<PartyType>
    not?: NestedEnumPartyTypeFilter | PartyType
  }

  export type PartyOrderByRelevanceInput = {
    fields: Enumerable<PartyOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PartyCountOrderByAggregateInput = {
    id?: SortOrder
    partyName?: SortOrder
    type?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    upi?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bankName?: SortOrder
    bankAccountNumber?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartyAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type PartyMaxOrderByAggregateInput = {
    id?: SortOrder
    partyName?: SortOrder
    type?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    upi?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bankName?: SortOrder
    bankAccountNumber?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartyMinOrderByAggregateInput = {
    id?: SortOrder
    partyName?: SortOrder
    type?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    upi?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bankName?: SortOrder
    bankAccountNumber?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartySumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumPartyTypeWithAggregatesFilter = {
    equals?: PartyType
    in?: Enumerable<PartyType>
    notIn?: Enumerable<PartyType>
    not?: NestedEnumPartyTypeWithAggregatesFilter | PartyType
    _count?: NestedIntFilter
    _min?: NestedEnumPartyTypeFilter
    _max?: NestedEnumPartyTypeFilter
  }

  export type CategoryOrderByRelevanceInput = {
    fields: Enumerable<CategoryOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    userId?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    userId?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    userId?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumItemUnitFilter = {
    equals?: ItemUnit
    in?: Enumerable<ItemUnit>
    notIn?: Enumerable<ItemUnit>
    not?: NestedEnumItemUnitFilter | ItemUnit
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelevanceInput = {
    fields: Enumerable<ItemOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    openingStock?: SortOrder
    closingStock?: SortOrder
    purchasePrice?: SortOrder
    gst?: SortOrder
    taxExempted?: SortOrder
    description?: SortOrder
    hsnCode?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    price?: SortOrder
    openingStock?: SortOrder
    closingStock?: SortOrder
    purchasePrice?: SortOrder
    gst?: SortOrder
    userId?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    openingStock?: SortOrder
    closingStock?: SortOrder
    purchasePrice?: SortOrder
    gst?: SortOrder
    taxExempted?: SortOrder
    description?: SortOrder
    hsnCode?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    openingStock?: SortOrder
    closingStock?: SortOrder
    purchasePrice?: SortOrder
    gst?: SortOrder
    taxExempted?: SortOrder
    description?: SortOrder
    hsnCode?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    price?: SortOrder
    openingStock?: SortOrder
    closingStock?: SortOrder
    purchasePrice?: SortOrder
    gst?: SortOrder
    userId?: SortOrder
  }

  export type EnumItemUnitWithAggregatesFilter = {
    equals?: ItemUnit
    in?: Enumerable<ItemUnit>
    notIn?: Enumerable<ItemUnit>
    not?: NestedEnumItemUnitWithAggregatesFilter | ItemUnit
    _count?: NestedIntFilter
    _min?: NestedEnumItemUnitFilter
    _max?: NestedEnumItemUnitFilter
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type EnumInvoiceTypeFilter = {
    equals?: InvoiceType
    in?: Enumerable<InvoiceType>
    notIn?: Enumerable<InvoiceType>
    not?: NestedEnumInvoiceTypeFilter | InvoiceType
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type EnumModeOfPaymentFilter = {
    equals?: ModeOfPayment
    in?: Enumerable<ModeOfPayment>
    notIn?: Enumerable<ModeOfPayment>
    not?: NestedEnumModeOfPaymentFilter | ModeOfPayment
  }

  export type EnumInvoiceStatusFilter = {
    equals?: InvoiceStatus
    in?: Enumerable<InvoiceStatus>
    notIn?: Enumerable<InvoiceStatus>
    not?: NestedEnumInvoiceStatusFilter | InvoiceStatus
  }

  export type InvoiceOrderByRelevanceInput = {
    fields: Enumerable<InvoiceOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    totalGst?: SortOrder
    stateOfSupply?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    igst?: SortOrder
    utgst?: SortOrder
    details?: SortOrder
    extraDetails?: SortOrder
    modeOfPayment?: SortOrder
    credit?: SortOrder
    userId?: SortOrder
    partyId?: SortOrder
    gstNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    totalGst?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    igst?: SortOrder
    utgst?: SortOrder
    userId?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    totalGst?: SortOrder
    stateOfSupply?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    igst?: SortOrder
    utgst?: SortOrder
    details?: SortOrder
    extraDetails?: SortOrder
    modeOfPayment?: SortOrder
    credit?: SortOrder
    userId?: SortOrder
    partyId?: SortOrder
    gstNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    totalGst?: SortOrder
    stateOfSupply?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    igst?: SortOrder
    utgst?: SortOrder
    details?: SortOrder
    extraDetails?: SortOrder
    modeOfPayment?: SortOrder
    credit?: SortOrder
    userId?: SortOrder
    partyId?: SortOrder
    gstNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    totalGst?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    igst?: SortOrder
    utgst?: SortOrder
    userId?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter = {
    equals?: InvoiceType
    in?: Enumerable<InvoiceType>
    notIn?: Enumerable<InvoiceType>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter | InvoiceType
    _count?: NestedIntFilter
    _min?: NestedEnumInvoiceTypeFilter
    _max?: NestedEnumInvoiceTypeFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EnumModeOfPaymentWithAggregatesFilter = {
    equals?: ModeOfPayment
    in?: Enumerable<ModeOfPayment>
    notIn?: Enumerable<ModeOfPayment>
    not?: NestedEnumModeOfPaymentWithAggregatesFilter | ModeOfPayment
    _count?: NestedIntFilter
    _min?: NestedEnumModeOfPaymentFilter
    _max?: NestedEnumModeOfPaymentFilter
  }

  export type EnumInvoiceStatusWithAggregatesFilter = {
    equals?: InvoiceStatus
    in?: Enumerable<InvoiceStatus>
    notIn?: Enumerable<InvoiceStatus>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter | InvoiceStatus
    _count?: NestedIntFilter
    _min?: NestedEnumInvoiceStatusFilter
    _max?: NestedEnumInvoiceStatusFilter
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type InvoiceItemOrderByRelevanceInput = {
    fields: Enumerable<InvoiceItemOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    invoiceId?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    discount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    invoiceId?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    invoiceId?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    discount?: SortOrder
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type ServiceOrderByRelevanceInput = {
    fields: Enumerable<ServiceOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceType?: SortOrder
    imgUrl?: SortOrder
    description?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    gst?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceType?: SortOrder
    imgUrl?: SortOrder
    description?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceType?: SortOrder
    imgUrl?: SortOrder
    description?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
    gst?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type EnumOrderStatusFilter = {
    equals?: OrderStatus
    in?: Enumerable<OrderStatus>
    notIn?: Enumerable<OrderStatus>
    not?: NestedEnumOrderStatusFilter | OrderStatus
  }

  export type OrderOrderByRelevanceInput = {
    fields: Enumerable<OrderOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    services?: SortOrder
    status?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    orderTotal?: SortOrder
    stateOfSupply?: SortOrder
    userId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    orderTotal?: SortOrder
    userId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    orderTotal?: SortOrder
    stateOfSupply?: SortOrder
    userId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    orderTotal?: SortOrder
    stateOfSupply?: SortOrder
    userId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    gst?: SortOrder
    orderTotal?: SortOrder
    userId?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter = {
    equals?: OrderStatus
    in?: Enumerable<OrderStatus>
    notIn?: Enumerable<OrderStatus>
    not?: NestedEnumOrderStatusWithAggregatesFilter | OrderStatus
    _count?: NestedIntFilter
    _min?: NestedEnumOrderStatusFilter
    _max?: NestedEnumOrderStatusFilter
  }

  export type EnumPaymentStatusFilter = {
    equals?: PaymentStatus
    in?: Enumerable<PaymentStatus>
    notIn?: Enumerable<PaymentStatus>
    not?: NestedEnumPaymentStatusFilter | PaymentStatus
  }

  export type PaymentOrderByRelevanceInput = {
    fields: Enumerable<PaymentOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    razorpay_order_id?: SortOrder
    razorpay_payment_id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    razorpay_order_id?: SortOrder
    razorpay_payment_id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    razorpay_order_id?: SortOrder
    razorpay_payment_id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter = {
    equals?: PaymentStatus
    in?: Enumerable<PaymentStatus>
    notIn?: Enumerable<PaymentStatus>
    not?: NestedEnumPaymentStatusWithAggregatesFilter | PaymentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentStatusFilter
    _max?: NestedEnumPaymentStatusFilter
  }

  export type LibraryOrderByRelevanceInput = {
    fields: Enumerable<LibraryOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LibraryCountOrderByAggregateInput = {
    id?: SortOrder
    pan?: SortOrder
    section?: SortOrder
    sub_section?: SortOrder
    subject?: SortOrder
    ao_order?: SortOrder
    itat_no?: SortOrder
    rsa_no?: SortOrder
    bench?: SortOrder
    appeal_no?: SortOrder
    appellant?: SortOrder
    respondent?: SortOrder
    appeal_type?: SortOrder
    appeal_filed_by?: SortOrder
    order_result?: SortOrder
    tribunal_order_date?: SortOrder
    assessment_year?: SortOrder
    judgment?: SortOrder
    conclusion?: SortOrder
    download?: SortOrder
    upload?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryMaxOrderByAggregateInput = {
    id?: SortOrder
    pan?: SortOrder
    section?: SortOrder
    sub_section?: SortOrder
    subject?: SortOrder
    ao_order?: SortOrder
    itat_no?: SortOrder
    rsa_no?: SortOrder
    bench?: SortOrder
    appeal_no?: SortOrder
    appellant?: SortOrder
    respondent?: SortOrder
    appeal_type?: SortOrder
    appeal_filed_by?: SortOrder
    order_result?: SortOrder
    tribunal_order_date?: SortOrder
    assessment_year?: SortOrder
    judgment?: SortOrder
    conclusion?: SortOrder
    download?: SortOrder
    upload?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryMinOrderByAggregateInput = {
    id?: SortOrder
    pan?: SortOrder
    section?: SortOrder
    sub_section?: SortOrder
    subject?: SortOrder
    ao_order?: SortOrder
    itat_no?: SortOrder
    rsa_no?: SortOrder
    bench?: SortOrder
    appeal_no?: SortOrder
    appellant?: SortOrder
    respondent?: SortOrder
    appeal_type?: SortOrder
    appeal_filed_by?: SortOrder
    order_result?: SortOrder
    tribunal_order_date?: SortOrder
    assessment_year?: SortOrder
    judgment?: SortOrder
    conclusion?: SortOrder
    download?: SortOrder
    upload?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibrarySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PostOrderByRelevanceInput = {
    fields: Enumerable<PostOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    contentheading?: SortOrder
    contentdiscription?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    contentheading?: SortOrder
    contentdiscription?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    contentheading?: SortOrder
    contentdiscription?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type AccountOrderByRelevanceInput = {
    fields: Enumerable<AccountOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    debitBalance?: SortOrder
    creditBalance?: SortOrder
    date?: SortOrder
    userId?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    debitBalance?: SortOrder
    creditBalance?: SortOrder
    userId?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    debitBalance?: SortOrder
    creditBalance?: SortOrder
    date?: SortOrder
    userId?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    debitBalance?: SortOrder
    creditBalance?: SortOrder
    date?: SortOrder
    userId?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    debitBalance?: SortOrder
    creditBalance?: SortOrder
    userId?: SortOrder
  }

  export type CareerOrderByRelevanceInput = {
    fields: Enumerable<CareerOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CareerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pin?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    skills?: SortOrder
    gender?: SortOrder
    cv?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CareerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pin?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    skills?: SortOrder
    gender?: SortOrder
    cv?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pin?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    skills?: SortOrder
    gender?: SortOrder
    cv?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumpaymentStatusFilter = {
    equals?: paymentStatus
    in?: Enumerable<paymentStatus>
    notIn?: Enumerable<paymentStatus>
    not?: NestedEnumpaymentStatusFilter | paymentStatus
  }

  export type EnumpaymentMethodFilter = {
    equals?: paymentMethod
    in?: Enumerable<paymentMethod>
    notIn?: Enumerable<paymentMethod>
    not?: NestedEnumpaymentMethodFilter | paymentMethod
  }

  export type BillrecieveOrderByRelevanceInput = {
    fields: Enumerable<BillrecieveOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type BillrecieveCountOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    amount?: SortOrder
    tax?: SortOrder
    customerName?: SortOrder
    customerAddress?: SortOrder
    contact?: SortOrder
    itemQuantity?: SortOrder
    itemPrice?: SortOrder
    itemDescription?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    dueDate?: SortOrder
    comment?: SortOrder
  }

  export type BillrecieveAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BillrecieveMaxOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    amount?: SortOrder
    tax?: SortOrder
    customerName?: SortOrder
    customerAddress?: SortOrder
    contact?: SortOrder
    itemQuantity?: SortOrder
    itemPrice?: SortOrder
    itemDescription?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    dueDate?: SortOrder
    comment?: SortOrder
  }

  export type BillrecieveMinOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    amount?: SortOrder
    tax?: SortOrder
    customerName?: SortOrder
    customerAddress?: SortOrder
    contact?: SortOrder
    itemQuantity?: SortOrder
    itemPrice?: SortOrder
    itemDescription?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    dueDate?: SortOrder
    comment?: SortOrder
  }

  export type BillrecieveSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumpaymentStatusWithAggregatesFilter = {
    equals?: paymentStatus
    in?: Enumerable<paymentStatus>
    notIn?: Enumerable<paymentStatus>
    not?: NestedEnumpaymentStatusWithAggregatesFilter | paymentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumpaymentStatusFilter
    _max?: NestedEnumpaymentStatusFilter
  }

  export type EnumpaymentMethodWithAggregatesFilter = {
    equals?: paymentMethod
    in?: Enumerable<paymentMethod>
    notIn?: Enumerable<paymentMethod>
    not?: NestedEnumpaymentMethodWithAggregatesFilter | paymentMethod
    _count?: NestedIntFilter
    _min?: NestedEnumpaymentMethodFilter
    _max?: NestedEnumpaymentMethodFilter
  }

  export type BillpayableOrderByRelevanceInput = {
    fields: Enumerable<BillpayableOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type BillpayableCountOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    supplierAddress?: SortOrder
    contact?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrder
    billAmount?: SortOrder
    billNumber?: SortOrder
    billDiscription?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    paymentDate?: SortOrder
    paymentAmount?: SortOrder
    tax?: SortOrder
    comment?: SortOrder
    invoiceNumber?: SortOrder
  }

  export type BillpayableAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BillpayableMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    supplierAddress?: SortOrder
    contact?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrder
    billAmount?: SortOrder
    billNumber?: SortOrder
    billDiscription?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    paymentDate?: SortOrder
    paymentAmount?: SortOrder
    tax?: SortOrder
    comment?: SortOrder
    invoiceNumber?: SortOrder
  }

  export type BillpayableMinOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    supplierAddress?: SortOrder
    contact?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrder
    billAmount?: SortOrder
    billNumber?: SortOrder
    billDiscription?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    paymentDate?: SortOrder
    paymentAmount?: SortOrder
    tax?: SortOrder
    comment?: SortOrder
    invoiceNumber?: SortOrder
  }

  export type BillpayableSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LoanDocumentListRelationFilter = {
    every?: LoanDocumentWhereInput
    some?: LoanDocumentWhereInput
    none?: LoanDocumentWhereInput
  }

  export type LoanApplicationRelationFilter = {
    is?: LoanApplicationWhereInput | null
    isNot?: LoanApplicationWhereInput | null
  }

  export type LoanDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UploadedDocumentOrderByRelevanceInput = {
    fields: Enumerable<UploadedDocumentOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UploadedDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileName?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedDocumentAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UploadedDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileName?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileName?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedDocumentSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumDocumentTypeFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeFilter | DocumentType
  }

  export type LoanListRelationFilter = {
    every?: LoanWhereInput
    some?: LoanWhereInput
    none?: LoanWhereInput
  }

  export type LoanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanDocumentOrderByRelevanceInput = {
    fields: Enumerable<LoanDocumentOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LoanDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    mandatory?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    mandatory?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    mandatory?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeWithAggregatesFilter | DocumentType
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentTypeFilter
    _max?: NestedEnumDocumentTypeFilter
  }

  export type EnumLoanTypeFilter = {
    equals?: LoanType
    in?: Enumerable<LoanType>
    notIn?: Enumerable<LoanType>
    not?: NestedEnumLoanTypeFilter | LoanType
  }

  export type LoanOrderByRelevanceInput = {
    fields: Enumerable<LoanOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LoanCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    maxAmount?: SortOrder
    minAmount?: SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanAvgOrderByAggregateInput = {
    maxAmount?: SortOrder
    minAmount?: SortOrder
    interest?: SortOrder
  }

  export type LoanMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    maxAmount?: SortOrder
    minAmount?: SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    maxAmount?: SortOrder
    minAmount?: SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanSumOrderByAggregateInput = {
    maxAmount?: SortOrder
    minAmount?: SortOrder
    interest?: SortOrder
  }

  export type EnumLoanTypeWithAggregatesFilter = {
    equals?: LoanType
    in?: Enumerable<LoanType>
    notIn?: Enumerable<LoanType>
    not?: NestedEnumLoanTypeWithAggregatesFilter | LoanType
    _count?: NestedIntFilter
    _min?: NestedEnumLoanTypeFilter
    _max?: NestedEnumLoanTypeFilter
  }

  export type EnumLoanStatusFilter = {
    equals?: LoanStatus
    in?: Enumerable<LoanStatus>
    notIn?: Enumerable<LoanStatus>
    not?: NestedEnumLoanStatusFilter | LoanStatus
  }

  export type EnumNationalityFilter = {
    equals?: Nationality
    in?: Enumerable<Nationality>
    notIn?: Enumerable<Nationality>
    not?: NestedEnumNationalityFilter | Nationality
  }

  export type LoanRelationFilter = {
    is?: LoanWhereInput | null
    isNot?: LoanWhereInput | null
  }

  export type BankDetailsRelationFilter = {
    is?: BankDetailsWhereInput | null
    isNot?: BankDetailsWhereInput | null
  }

  export type LoanApplicationOrderByRelevanceInput = {
    fields: Enumerable<LoanApplicationOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LoanApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    loanAmount?: SortOrder
    loanStatus?: SortOrder
    applicantName?: SortOrder
    applicantAge?: SortOrder
    loanType?: SortOrder
    applicantGender?: SortOrder
    nationality?: SortOrder
    description?: SortOrder
    salaried?: SortOrder
    bankAccountId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    permanentAddress?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanApplicationAvgOrderByAggregateInput = {
    loanAmount?: SortOrder
    applicantAge?: SortOrder
    userId?: SortOrder
  }

  export type LoanApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    loanAmount?: SortOrder
    loanStatus?: SortOrder
    applicantName?: SortOrder
    applicantAge?: SortOrder
    loanType?: SortOrder
    applicantGender?: SortOrder
    nationality?: SortOrder
    description?: SortOrder
    salaried?: SortOrder
    bankAccountId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    permanentAddress?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    loanAmount?: SortOrder
    loanStatus?: SortOrder
    applicantName?: SortOrder
    applicantAge?: SortOrder
    loanType?: SortOrder
    applicantGender?: SortOrder
    nationality?: SortOrder
    description?: SortOrder
    salaried?: SortOrder
    bankAccountId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    permanentAddress?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanApplicationSumOrderByAggregateInput = {
    loanAmount?: SortOrder
    applicantAge?: SortOrder
    userId?: SortOrder
  }

  export type EnumLoanStatusWithAggregatesFilter = {
    equals?: LoanStatus
    in?: Enumerable<LoanStatus>
    notIn?: Enumerable<LoanStatus>
    not?: NestedEnumLoanStatusWithAggregatesFilter | LoanStatus
    _count?: NestedIntFilter
    _min?: NestedEnumLoanStatusFilter
    _max?: NestedEnumLoanStatusFilter
  }

  export type EnumNationalityWithAggregatesFilter = {
    equals?: Nationality
    in?: Enumerable<Nationality>
    notIn?: Enumerable<Nationality>
    not?: NestedEnumNationalityWithAggregatesFilter | Nationality
    _count?: NestedIntFilter
    _min?: NestedEnumNationalityFilter
    _max?: NestedEnumNationalityFilter
  }

  export type EnumBankAccountTypeFilter = {
    equals?: BankAccountType
    in?: Enumerable<BankAccountType>
    notIn?: Enumerable<BankAccountType>
    not?: NestedEnumBankAccountTypeFilter | BankAccountType
  }

  export type BankDetailsOrderByRelevanceInput = {
    fields: Enumerable<BankDetailsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type BankDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    accountHolderName?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    bankAccountType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailsAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type BankDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountHolderName?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    bankAccountType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    accountHolderName?: SortOrder
    bankName?: SortOrder
    bankAccountNo?: SortOrder
    bankIfsc?: SortOrder
    bankBranch?: SortOrder
    bankAccountType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailsSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumBankAccountTypeWithAggregatesFilter = {
    equals?: BankAccountType
    in?: Enumerable<BankAccountType>
    notIn?: Enumerable<BankAccountType>
    not?: NestedEnumBankAccountTypeWithAggregatesFilter | BankAccountType
    _count?: NestedIntFilter
    _min?: NestedEnumBankAccountTypeFilter
    _max?: NestedEnumBankAccountTypeFilter
  }

  export type InsuranceOrderByRelevanceInput = {
    fields: Enumerable<InsuranceOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type InsuranceCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    address?: SortOrder
    dob?: SortOrder
    maritalStatus?: SortOrder
    gender?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type InsuranceMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    address?: SortOrder
    dob?: SortOrder
    maritalStatus?: SortOrder
    gender?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    address?: SortOrder
    dob?: SortOrder
    maritalStatus?: SortOrder
    gender?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ClientOrderByRelevanceInput = {
    fields: Enumerable<ClientOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type AgentOrderByRelevanceInput = {
    fields: Enumerable<AgentOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type VisitorCountOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitorAvgOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
  }

  export type VisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitorMinOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitorSumOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
  }

  export type EnumStartupCategoryFilter = {
    equals?: StartupCategory
    in?: Enumerable<StartupCategory>
    notIn?: Enumerable<StartupCategory>
    not?: NestedEnumStartupCategoryFilter | StartupCategory
  }

  export type RegisterStartupOrderByRelevanceInput = {
    fields: Enumerable<RegisterStartupOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RegisterStartupCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    categories?: SortOrder
  }

  export type RegisterStartupAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RegisterStartupMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    categories?: SortOrder
  }

  export type RegisterStartupMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    categories?: SortOrder
  }

  export type RegisterStartupSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumStartupCategoryWithAggregatesFilter = {
    equals?: StartupCategory
    in?: Enumerable<StartupCategory>
    notIn?: Enumerable<StartupCategory>
    not?: NestedEnumStartupCategoryWithAggregatesFilter | StartupCategory
    _count?: NestedIntFilter
    _min?: NestedEnumStartupCategoryFilter
    _max?: NestedEnumStartupCategoryFilter
  }

  export type ContactUsOrderByRelevanceInput = {
    fields: Enumerable<ContactUsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ContactUsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    phoneNumber?: SortOrder
    userId?: SortOrder
  }

  export type ContactUsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ContactUsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    phoneNumber?: SortOrder
    userId?: SortOrder
  }

  export type ContactUsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    phoneNumber?: SortOrder
    userId?: SortOrder
  }

  export type ContactUsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AboutOrderByRelevanceInput = {
    fields: Enumerable<AboutOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AboutCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    image?: SortOrder
    description?: SortOrder
  }

  export type AboutMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    image?: SortOrder
    description?: SortOrder
  }

  export type AboutMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    image?: SortOrder
    description?: SortOrder
  }

  export type Gstr1_4AOrderByRelevanceInput = {
    fields: Enumerable<Gstr1_4AOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type Gstr1_4ACountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    LegalName?: SortOrder
    GSTN?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    rate?: SortOrder
    nature?: SortOrder
    source?: SortOrder
    cgst?: SortOrder
    igst?: SortOrder
    sgst?: SortOrder
    supply_type?: SortOrder
    fy?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Gstr1_4AAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type Gstr1_4AMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    LegalName?: SortOrder
    GSTN?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    rate?: SortOrder
    nature?: SortOrder
    source?: SortOrder
    cgst?: SortOrder
    igst?: SortOrder
    sgst?: SortOrder
    supply_type?: SortOrder
    fy?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Gstr1_4AMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    LegalName?: SortOrder
    GSTN?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    rate?: SortOrder
    nature?: SortOrder
    source?: SortOrder
    cgst?: SortOrder
    igst?: SortOrder
    sgst?: SortOrder
    supply_type?: SortOrder
    fy?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Gstr1_4ASumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type Gstr1_5A_itemListRelationFilter = {
    every?: Gstr1_5A_itemWhereInput
    some?: Gstr1_5A_itemWhereInput
    none?: Gstr1_5A_itemWhereInput
  }

  export type Gstr1_5A_itemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Gstr1_5AOrderByRelevanceInput = {
    fields: Enumerable<Gstr1_5AOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type Gstr1_5ACountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    supply_type?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    total_invoice_value?: SortOrder
  }

  export type Gstr1_5AAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type Gstr1_5AMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    supply_type?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    total_invoice_value?: SortOrder
  }

  export type Gstr1_5AMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pos?: SortOrder
    invoice_No?: SortOrder
    supply_type?: SortOrder
    invoice_date?: SortOrder
    invoice_value?: SortOrder
    total_invoice_value?: SortOrder
  }

  export type Gstr1_5ASumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type Gstr1_5ARelationFilter = {
    is?: Gstr1_5AWhereInput | null
    isNot?: Gstr1_5AWhereInput | null
  }

  export type Gstr1_5A_itemOrderByRelevanceInput = {
    fields: Enumerable<Gstr1_5A_itemOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type Gstr1_5A_itemCountOrderByAggregateInput = {
    id?: SortOrder
    SN?: SortOrder
    turnover?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    gstr1_5A_id?: SortOrder
  }

  export type Gstr1_5A_itemAvgOrderByAggregateInput = {
    id?: SortOrder
    gstr1_5A_id?: SortOrder
  }

  export type Gstr1_5A_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    SN?: SortOrder
    turnover?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    gstr1_5A_id?: SortOrder
  }

  export type Gstr1_5A_itemMinOrderByAggregateInput = {
    id?: SortOrder
    SN?: SortOrder
    turnover?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    gstr1_5A_id?: SortOrder
  }

  export type Gstr1_5A_itemSumOrderByAggregateInput = {
    id?: SortOrder
    gstr1_5A_id?: SortOrder
  }

  export type OtpCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OtpCreateWithoutUserInput>, Enumerable<OtpUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OtpCreateOrConnectWithoutUserInput>
    createMany?: OtpCreateManyUserInputEnvelope
    connect?: Enumerable<OtpWhereUniqueInput>
  }

  export type BusinessProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<BusinessProfileCreateWithoutUserInput, BusinessProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessProfileCreateOrConnectWithoutUserInput
    connect?: BusinessProfileWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutUserInput>, Enumerable<InvoiceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutUserInput>
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type CategoryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutUserInput>, Enumerable<CategoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutUserInput>
    createMany?: CategoryCreateManyUserInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ItemCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ItemCreateWithoutUserInput>, Enumerable<ItemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutUserInput>
    createMany?: ItemCreateManyUserInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type PartyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PartyCreateWithoutUserInput>, Enumerable<PartyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PartyCreateOrConnectWithoutUserInput>
    createMany?: PartyCreateManyUserInputEnvelope
    connect?: Enumerable<PartyWhereUniqueInput>
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutUserInput>, Enumerable<PaymentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutUserInput>
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type BankDetailsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BankDetailsCreateWithoutUserInput>, Enumerable<BankDetailsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BankDetailsCreateOrConnectWithoutUserInput>
    createMany?: BankDetailsCreateManyUserInputEnvelope
    connect?: Enumerable<BankDetailsWhereUniqueInput>
  }

  export type LoanApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutUserInput>, Enumerable<LoanApplicationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutUserInput>
    createMany?: LoanApplicationCreateManyUserInputEnvelope
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
  }

  export type UploadedDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutUserInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutUserInput>
    createMany?: UploadedDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
  }

  export type InsuranceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InsuranceCreateWithoutUserInput>, Enumerable<InsuranceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InsuranceCreateOrConnectWithoutUserInput>
    createMany?: InsuranceCreateManyUserInputEnvelope
    connect?: Enumerable<InsuranceWhereUniqueInput>
  }

  export type RegisterStartupCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RegisterStartupCreateWithoutUserInput>, Enumerable<RegisterStartupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RegisterStartupCreateOrConnectWithoutUserInput>
    createMany?: RegisterStartupCreateManyUserInputEnvelope
    connect?: Enumerable<RegisterStartupWhereUniqueInput>
  }

  export type ContactUsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ContactUsCreateWithoutUserInput>, Enumerable<ContactUsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ContactUsCreateOrConnectWithoutUserInput>
    createMany?: ContactUsCreateManyUserInputEnvelope
    connect?: Enumerable<ContactUsWhereUniqueInput>
  }

  export type JournalEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<JournalEntryCreateWithoutUserInput>, Enumerable<JournalEntryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<JournalEntryCreateOrConnectWithoutUserInput>
    createMany?: JournalEntryCreateManyUserInputEnvelope
    connect?: Enumerable<JournalEntryWhereUniqueInput>
  }

  export type LedgerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LedgerCreateWithoutUserInput>, Enumerable<LedgerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LedgerCreateOrConnectWithoutUserInput>
    createMany?: LedgerCreateManyUserInputEnvelope
    connect?: Enumerable<LedgerWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type AgentCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type ClientCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientCreateWithoutUserInput>, Enumerable<ClientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutUserInput>
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
  }

  export type Gstr1_4ACreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Gstr1_4ACreateWithoutUserInput>, Enumerable<Gstr1_4AUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Gstr1_4ACreateOrConnectWithoutUserInput>
    createMany?: Gstr1_4ACreateManyUserInputEnvelope
    connect?: Enumerable<Gstr1_4AWhereUniqueInput>
  }

  export type Gstr1_5ACreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Gstr1_5ACreateWithoutUserInput>, Enumerable<Gstr1_5AUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Gstr1_5ACreateOrConnectWithoutUserInput>
    createMany?: Gstr1_5ACreateManyUserInputEnvelope
    connect?: Enumerable<Gstr1_5AWhereUniqueInput>
  }

  export type OtpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OtpCreateWithoutUserInput>, Enumerable<OtpUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OtpCreateOrConnectWithoutUserInput>
    createMany?: OtpCreateManyUserInputEnvelope
    connect?: Enumerable<OtpWhereUniqueInput>
  }

  export type BusinessProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BusinessProfileCreateWithoutUserInput, BusinessProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessProfileCreateOrConnectWithoutUserInput
    connect?: BusinessProfileWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutUserInput>, Enumerable<InvoiceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutUserInput>
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutUserInput>, Enumerable<CategoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutUserInput>
    createMany?: CategoryCreateManyUserInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ItemCreateWithoutUserInput>, Enumerable<ItemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutUserInput>
    createMany?: ItemCreateManyUserInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type PartyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PartyCreateWithoutUserInput>, Enumerable<PartyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PartyCreateOrConnectWithoutUserInput>
    createMany?: PartyCreateManyUserInputEnvelope
    connect?: Enumerable<PartyWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutUserInput>, Enumerable<PaymentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutUserInput>
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type BankDetailsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BankDetailsCreateWithoutUserInput>, Enumerable<BankDetailsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BankDetailsCreateOrConnectWithoutUserInput>
    createMany?: BankDetailsCreateManyUserInputEnvelope
    connect?: Enumerable<BankDetailsWhereUniqueInput>
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutUserInput>, Enumerable<LoanApplicationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutUserInput>
    createMany?: LoanApplicationCreateManyUserInputEnvelope
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
  }

  export type UploadedDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutUserInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutUserInput>
    createMany?: UploadedDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
  }

  export type InsuranceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InsuranceCreateWithoutUserInput>, Enumerable<InsuranceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InsuranceCreateOrConnectWithoutUserInput>
    createMany?: InsuranceCreateManyUserInputEnvelope
    connect?: Enumerable<InsuranceWhereUniqueInput>
  }

  export type RegisterStartupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RegisterStartupCreateWithoutUserInput>, Enumerable<RegisterStartupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RegisterStartupCreateOrConnectWithoutUserInput>
    createMany?: RegisterStartupCreateManyUserInputEnvelope
    connect?: Enumerable<RegisterStartupWhereUniqueInput>
  }

  export type ContactUsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ContactUsCreateWithoutUserInput>, Enumerable<ContactUsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ContactUsCreateOrConnectWithoutUserInput>
    createMany?: ContactUsCreateManyUserInputEnvelope
    connect?: Enumerable<ContactUsWhereUniqueInput>
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<JournalEntryCreateWithoutUserInput>, Enumerable<JournalEntryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<JournalEntryCreateOrConnectWithoutUserInput>
    createMany?: JournalEntryCreateManyUserInputEnvelope
    connect?: Enumerable<JournalEntryWhereUniqueInput>
  }

  export type LedgerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LedgerCreateWithoutUserInput>, Enumerable<LedgerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LedgerCreateOrConnectWithoutUserInput>
    createMany?: LedgerCreateManyUserInputEnvelope
    connect?: Enumerable<LedgerWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type AgentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientCreateWithoutUserInput>, Enumerable<ClientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutUserInput>
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
  }

  export type Gstr1_4AUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Gstr1_4ACreateWithoutUserInput>, Enumerable<Gstr1_4AUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Gstr1_4ACreateOrConnectWithoutUserInput>
    createMany?: Gstr1_4ACreateManyUserInputEnvelope
    connect?: Enumerable<Gstr1_4AWhereUniqueInput>
  }

  export type Gstr1_5AUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Gstr1_5ACreateWithoutUserInput>, Enumerable<Gstr1_5AUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Gstr1_5ACreateOrConnectWithoutUserInput>
    createMany?: Gstr1_5ACreateManyUserInputEnvelope
    connect?: Enumerable<Gstr1_5AWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserGenderFieldUpdateOperationsInput = {
    set?: UserGender
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: UserType
  }

  export type OtpUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OtpCreateWithoutUserInput>, Enumerable<OtpUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OtpCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OtpUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OtpCreateManyUserInputEnvelope
    set?: Enumerable<OtpWhereUniqueInput>
    disconnect?: Enumerable<OtpWhereUniqueInput>
    delete?: Enumerable<OtpWhereUniqueInput>
    connect?: Enumerable<OtpWhereUniqueInput>
    update?: Enumerable<OtpUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OtpUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OtpScalarWhereInput>
  }

  export type BusinessProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<BusinessProfileCreateWithoutUserInput, BusinessProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessProfileCreateOrConnectWithoutUserInput
    upsert?: BusinessProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessProfileWhereUniqueInput
    update?: XOR<BusinessProfileUpdateWithoutUserInput, BusinessProfileUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutUserInput>, Enumerable<InvoiceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type CategoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutUserInput>, Enumerable<CategoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CategoryCreateManyUserInputEnvelope
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutUserInput>, Enumerable<ItemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ItemCreateManyUserInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type PartyUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PartyCreateWithoutUserInput>, Enumerable<PartyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PartyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PartyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PartyCreateManyUserInputEnvelope
    set?: Enumerable<PartyWhereUniqueInput>
    disconnect?: Enumerable<PartyWhereUniqueInput>
    delete?: Enumerable<PartyWhereUniqueInput>
    connect?: Enumerable<PartyWhereUniqueInput>
    update?: Enumerable<PartyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PartyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PartyScalarWhereInput>
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutUserInput>, Enumerable<PaymentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type BankDetailsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BankDetailsCreateWithoutUserInput>, Enumerable<BankDetailsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BankDetailsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BankDetailsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BankDetailsCreateManyUserInputEnvelope
    set?: Enumerable<BankDetailsWhereUniqueInput>
    disconnect?: Enumerable<BankDetailsWhereUniqueInput>
    delete?: Enumerable<BankDetailsWhereUniqueInput>
    connect?: Enumerable<BankDetailsWhereUniqueInput>
    update?: Enumerable<BankDetailsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BankDetailsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BankDetailsScalarWhereInput>
  }

  export type LoanApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutUserInput>, Enumerable<LoanApplicationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LoanApplicationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LoanApplicationCreateManyUserInputEnvelope
    set?: Enumerable<LoanApplicationWhereUniqueInput>
    disconnect?: Enumerable<LoanApplicationWhereUniqueInput>
    delete?: Enumerable<LoanApplicationWhereUniqueInput>
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
    update?: Enumerable<LoanApplicationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LoanApplicationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LoanApplicationScalarWhereInput>
  }

  export type UploadedDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutUserInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UploadedDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UploadedDocumentCreateManyUserInputEnvelope
    set?: Enumerable<UploadedDocumentWhereUniqueInput>
    disconnect?: Enumerable<UploadedDocumentWhereUniqueInput>
    delete?: Enumerable<UploadedDocumentWhereUniqueInput>
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
    update?: Enumerable<UploadedDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UploadedDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UploadedDocumentScalarWhereInput>
  }

  export type InsuranceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<InsuranceCreateWithoutUserInput>, Enumerable<InsuranceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InsuranceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InsuranceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InsuranceCreateManyUserInputEnvelope
    set?: Enumerable<InsuranceWhereUniqueInput>
    disconnect?: Enumerable<InsuranceWhereUniqueInput>
    delete?: Enumerable<InsuranceWhereUniqueInput>
    connect?: Enumerable<InsuranceWhereUniqueInput>
    update?: Enumerable<InsuranceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InsuranceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InsuranceScalarWhereInput>
  }

  export type RegisterStartupUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RegisterStartupCreateWithoutUserInput>, Enumerable<RegisterStartupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RegisterStartupCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RegisterStartupUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RegisterStartupCreateManyUserInputEnvelope
    set?: Enumerable<RegisterStartupWhereUniqueInput>
    disconnect?: Enumerable<RegisterStartupWhereUniqueInput>
    delete?: Enumerable<RegisterStartupWhereUniqueInput>
    connect?: Enumerable<RegisterStartupWhereUniqueInput>
    update?: Enumerable<RegisterStartupUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RegisterStartupUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RegisterStartupScalarWhereInput>
  }

  export type ContactUsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ContactUsCreateWithoutUserInput>, Enumerable<ContactUsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ContactUsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ContactUsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ContactUsCreateManyUserInputEnvelope
    set?: Enumerable<ContactUsWhereUniqueInput>
    disconnect?: Enumerable<ContactUsWhereUniqueInput>
    delete?: Enumerable<ContactUsWhereUniqueInput>
    connect?: Enumerable<ContactUsWhereUniqueInput>
    update?: Enumerable<ContactUsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ContactUsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ContactUsScalarWhereInput>
  }

  export type JournalEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<JournalEntryCreateWithoutUserInput>, Enumerable<JournalEntryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<JournalEntryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<JournalEntryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: JournalEntryCreateManyUserInputEnvelope
    set?: Enumerable<JournalEntryWhereUniqueInput>
    disconnect?: Enumerable<JournalEntryWhereUniqueInput>
    delete?: Enumerable<JournalEntryWhereUniqueInput>
    connect?: Enumerable<JournalEntryWhereUniqueInput>
    update?: Enumerable<JournalEntryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<JournalEntryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<JournalEntryScalarWhereInput>
  }

  export type LedgerUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LedgerCreateWithoutUserInput>, Enumerable<LedgerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LedgerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LedgerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LedgerCreateManyUserInputEnvelope
    set?: Enumerable<LedgerWhereUniqueInput>
    disconnect?: Enumerable<LedgerWhereUniqueInput>
    delete?: Enumerable<LedgerWhereUniqueInput>
    connect?: Enumerable<LedgerWhereUniqueInput>
    update?: Enumerable<LedgerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LedgerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LedgerScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type AgentUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ClientCreateWithoutUserInput>, Enumerable<ClientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ClientCreateManyUserInputEnvelope
    set?: Enumerable<ClientWhereUniqueInput>
    disconnect?: Enumerable<ClientWhereUniqueInput>
    delete?: Enumerable<ClientWhereUniqueInput>
    connect?: Enumerable<ClientWhereUniqueInput>
    update?: Enumerable<ClientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ClientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ClientScalarWhereInput>
  }

  export type Gstr1_4AUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Gstr1_4ACreateWithoutUserInput>, Enumerable<Gstr1_4AUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Gstr1_4ACreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Gstr1_4AUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Gstr1_4ACreateManyUserInputEnvelope
    set?: Enumerable<Gstr1_4AWhereUniqueInput>
    disconnect?: Enumerable<Gstr1_4AWhereUniqueInput>
    delete?: Enumerable<Gstr1_4AWhereUniqueInput>
    connect?: Enumerable<Gstr1_4AWhereUniqueInput>
    update?: Enumerable<Gstr1_4AUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Gstr1_4AUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Gstr1_4AScalarWhereInput>
  }

  export type Gstr1_5AUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Gstr1_5ACreateWithoutUserInput>, Enumerable<Gstr1_5AUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Gstr1_5ACreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Gstr1_5AUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Gstr1_5ACreateManyUserInputEnvelope
    set?: Enumerable<Gstr1_5AWhereUniqueInput>
    disconnect?: Enumerable<Gstr1_5AWhereUniqueInput>
    delete?: Enumerable<Gstr1_5AWhereUniqueInput>
    connect?: Enumerable<Gstr1_5AWhereUniqueInput>
    update?: Enumerable<Gstr1_5AUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Gstr1_5AUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Gstr1_5AScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OtpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OtpCreateWithoutUserInput>, Enumerable<OtpUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OtpCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OtpUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OtpCreateManyUserInputEnvelope
    set?: Enumerable<OtpWhereUniqueInput>
    disconnect?: Enumerable<OtpWhereUniqueInput>
    delete?: Enumerable<OtpWhereUniqueInput>
    connect?: Enumerable<OtpWhereUniqueInput>
    update?: Enumerable<OtpUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OtpUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OtpScalarWhereInput>
  }

  export type BusinessProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BusinessProfileCreateWithoutUserInput, BusinessProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessProfileCreateOrConnectWithoutUserInput
    upsert?: BusinessProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessProfileWhereUniqueInput
    update?: XOR<BusinessProfileUpdateWithoutUserInput, BusinessProfileUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutUserInput>, Enumerable<InvoiceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutUserInput>, Enumerable<CategoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CategoryCreateManyUserInputEnvelope
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutUserInput>, Enumerable<ItemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ItemCreateManyUserInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type PartyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PartyCreateWithoutUserInput>, Enumerable<PartyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PartyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PartyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PartyCreateManyUserInputEnvelope
    set?: Enumerable<PartyWhereUniqueInput>
    disconnect?: Enumerable<PartyWhereUniqueInput>
    delete?: Enumerable<PartyWhereUniqueInput>
    connect?: Enumerable<PartyWhereUniqueInput>
    update?: Enumerable<PartyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PartyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PartyScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutUserInput>, Enumerable<PaymentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type BankDetailsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BankDetailsCreateWithoutUserInput>, Enumerable<BankDetailsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BankDetailsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BankDetailsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BankDetailsCreateManyUserInputEnvelope
    set?: Enumerable<BankDetailsWhereUniqueInput>
    disconnect?: Enumerable<BankDetailsWhereUniqueInput>
    delete?: Enumerable<BankDetailsWhereUniqueInput>
    connect?: Enumerable<BankDetailsWhereUniqueInput>
    update?: Enumerable<BankDetailsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BankDetailsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BankDetailsScalarWhereInput>
  }

  export type LoanApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutUserInput>, Enumerable<LoanApplicationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LoanApplicationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LoanApplicationCreateManyUserInputEnvelope
    set?: Enumerable<LoanApplicationWhereUniqueInput>
    disconnect?: Enumerable<LoanApplicationWhereUniqueInput>
    delete?: Enumerable<LoanApplicationWhereUniqueInput>
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
    update?: Enumerable<LoanApplicationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LoanApplicationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LoanApplicationScalarWhereInput>
  }

  export type UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutUserInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UploadedDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UploadedDocumentCreateManyUserInputEnvelope
    set?: Enumerable<UploadedDocumentWhereUniqueInput>
    disconnect?: Enumerable<UploadedDocumentWhereUniqueInput>
    delete?: Enumerable<UploadedDocumentWhereUniqueInput>
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
    update?: Enumerable<UploadedDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UploadedDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UploadedDocumentScalarWhereInput>
  }

  export type InsuranceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<InsuranceCreateWithoutUserInput>, Enumerable<InsuranceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InsuranceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InsuranceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InsuranceCreateManyUserInputEnvelope
    set?: Enumerable<InsuranceWhereUniqueInput>
    disconnect?: Enumerable<InsuranceWhereUniqueInput>
    delete?: Enumerable<InsuranceWhereUniqueInput>
    connect?: Enumerable<InsuranceWhereUniqueInput>
    update?: Enumerable<InsuranceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InsuranceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InsuranceScalarWhereInput>
  }

  export type RegisterStartupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RegisterStartupCreateWithoutUserInput>, Enumerable<RegisterStartupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RegisterStartupCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RegisterStartupUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RegisterStartupCreateManyUserInputEnvelope
    set?: Enumerable<RegisterStartupWhereUniqueInput>
    disconnect?: Enumerable<RegisterStartupWhereUniqueInput>
    delete?: Enumerable<RegisterStartupWhereUniqueInput>
    connect?: Enumerable<RegisterStartupWhereUniqueInput>
    update?: Enumerable<RegisterStartupUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RegisterStartupUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RegisterStartupScalarWhereInput>
  }

  export type ContactUsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ContactUsCreateWithoutUserInput>, Enumerable<ContactUsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ContactUsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ContactUsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ContactUsCreateManyUserInputEnvelope
    set?: Enumerable<ContactUsWhereUniqueInput>
    disconnect?: Enumerable<ContactUsWhereUniqueInput>
    delete?: Enumerable<ContactUsWhereUniqueInput>
    connect?: Enumerable<ContactUsWhereUniqueInput>
    update?: Enumerable<ContactUsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ContactUsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ContactUsScalarWhereInput>
  }

  export type JournalEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<JournalEntryCreateWithoutUserInput>, Enumerable<JournalEntryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<JournalEntryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<JournalEntryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: JournalEntryCreateManyUserInputEnvelope
    set?: Enumerable<JournalEntryWhereUniqueInput>
    disconnect?: Enumerable<JournalEntryWhereUniqueInput>
    delete?: Enumerable<JournalEntryWhereUniqueInput>
    connect?: Enumerable<JournalEntryWhereUniqueInput>
    update?: Enumerable<JournalEntryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<JournalEntryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<JournalEntryScalarWhereInput>
  }

  export type LedgerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LedgerCreateWithoutUserInput>, Enumerable<LedgerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LedgerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LedgerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LedgerCreateManyUserInputEnvelope
    set?: Enumerable<LedgerWhereUniqueInput>
    disconnect?: Enumerable<LedgerWhereUniqueInput>
    delete?: Enumerable<LedgerWhereUniqueInput>
    connect?: Enumerable<LedgerWhereUniqueInput>
    update?: Enumerable<LedgerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LedgerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LedgerScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type AgentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type ClientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ClientCreateWithoutUserInput>, Enumerable<ClientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ClientCreateManyUserInputEnvelope
    set?: Enumerable<ClientWhereUniqueInput>
    disconnect?: Enumerable<ClientWhereUniqueInput>
    delete?: Enumerable<ClientWhereUniqueInput>
    connect?: Enumerable<ClientWhereUniqueInput>
    update?: Enumerable<ClientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ClientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ClientScalarWhereInput>
  }

  export type Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Gstr1_4ACreateWithoutUserInput>, Enumerable<Gstr1_4AUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Gstr1_4ACreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Gstr1_4AUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Gstr1_4ACreateManyUserInputEnvelope
    set?: Enumerable<Gstr1_4AWhereUniqueInput>
    disconnect?: Enumerable<Gstr1_4AWhereUniqueInput>
    delete?: Enumerable<Gstr1_4AWhereUniqueInput>
    connect?: Enumerable<Gstr1_4AWhereUniqueInput>
    update?: Enumerable<Gstr1_4AUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Gstr1_4AUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Gstr1_4AScalarWhereInput>
  }

  export type Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Gstr1_5ACreateWithoutUserInput>, Enumerable<Gstr1_5AUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Gstr1_5ACreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Gstr1_5AUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Gstr1_5ACreateManyUserInputEnvelope
    set?: Enumerable<Gstr1_5AWhereUniqueInput>
    disconnect?: Enumerable<Gstr1_5AWhereUniqueInput>
    delete?: Enumerable<Gstr1_5AWhereUniqueInput>
    connect?: Enumerable<Gstr1_5AWhereUniqueInput>
    update?: Enumerable<Gstr1_5AUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Gstr1_5AUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Gstr1_5AScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutOtpsInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOtpsNestedInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    upsert?: UserUpsertWithoutOtpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserCreateNestedOneWithoutBusinessProfileInput = {
    create?: XOR<UserCreateWithoutBusinessProfileInput, UserUncheckedCreateWithoutBusinessProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutBusinessProfileNestedInput = {
    create?: XOR<UserCreateWithoutBusinessProfileInput, UserUncheckedCreateWithoutBusinessProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessProfileInput
    upsert?: UserUpsertWithoutBusinessProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBusinessProfileInput, UserUncheckedUpdateWithoutBusinessProfileInput>
  }

  export type UserCreateNestedOneWithoutLegdersInput = {
    create?: XOR<UserCreateWithoutLegdersInput, UserUncheckedCreateWithoutLegdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLegdersInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutLedgerInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutLedgerInput>, Enumerable<TransactionUncheckedCreateWithoutLedgerInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutLedgerInput>
    createMany?: TransactionCreateManyLedgerInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type PartyCreateNestedOneWithoutLedgersInput = {
    create?: XOR<PartyCreateWithoutLedgersInput, PartyUncheckedCreateWithoutLedgersInput>
    connectOrCreate?: PartyCreateOrConnectWithoutLedgersInput
    connect?: PartyWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutLedgerInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutLedgerInput>, Enumerable<TransactionUncheckedCreateWithoutLedgerInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutLedgerInput>
    createMany?: TransactionCreateManyLedgerInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumLedgerTypeFieldUpdateOperationsInput = {
    set?: LedgerType
  }

  export type UserUpdateOneRequiredWithoutLegdersNestedInput = {
    create?: XOR<UserCreateWithoutLegdersInput, UserUncheckedCreateWithoutLegdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLegdersInput
    upsert?: UserUpsertWithoutLegdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLegdersInput, UserUncheckedUpdateWithoutLegdersInput>
  }

  export type TransactionUpdateManyWithoutLedgerNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutLedgerInput>, Enumerable<TransactionUncheckedCreateWithoutLedgerInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutLedgerInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutLedgerInput>
    createMany?: TransactionCreateManyLedgerInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutLedgerInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutLedgerInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type PartyUpdateOneWithoutLedgersNestedInput = {
    create?: XOR<PartyCreateWithoutLedgersInput, PartyUncheckedCreateWithoutLedgersInput>
    connectOrCreate?: PartyCreateOrConnectWithoutLedgersInput
    upsert?: PartyUpsertWithoutLedgersInput
    disconnect?: boolean
    delete?: boolean
    connect?: PartyWhereUniqueInput
    update?: XOR<PartyUpdateWithoutLedgersInput, PartyUncheckedUpdateWithoutLedgersInput>
  }

  export type TransactionUncheckedUpdateManyWithoutLedgerNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutLedgerInput>, Enumerable<TransactionUncheckedCreateWithoutLedgerInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutLedgerInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutLedgerInput>
    createMany?: TransactionCreateManyLedgerInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutLedgerInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutLedgerInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutJournalEntryInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutJournalEntryInput>, Enumerable<TransactionUncheckedCreateWithoutJournalEntryInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutJournalEntryInput>
    createMany?: TransactionCreateManyJournalEntryInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutJournalEntryInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutJournalEntryInput>, Enumerable<TransactionUncheckedCreateWithoutJournalEntryInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutJournalEntryInput>
    createMany?: TransactionCreateManyJournalEntryInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutJournalEntriesNestedInput = {
    create?: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalEntriesInput
    upsert?: UserUpsertWithoutJournalEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutJournalEntriesInput, UserUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type TransactionUpdateManyWithoutJournalEntryNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutJournalEntryInput>, Enumerable<TransactionUncheckedCreateWithoutJournalEntryInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutJournalEntryInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutJournalEntryInput>
    createMany?: TransactionCreateManyJournalEntryInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutJournalEntryInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutJournalEntryInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutJournalEntryNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutJournalEntryInput>, Enumerable<TransactionUncheckedCreateWithoutJournalEntryInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutJournalEntryInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutJournalEntryInput>
    createMany?: TransactionCreateManyJournalEntryInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutJournalEntryInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutJournalEntryInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type LedgerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LedgerCreateWithoutTransactionsInput, LedgerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LedgerCreateOrConnectWithoutTransactionsInput
    connect?: LedgerWhereUniqueInput
  }

  export type JournalEntryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<JournalEntryCreateWithoutTransactionsInput, JournalEntryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutTransactionsInput
    connect?: JournalEntryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: TransactionType
  }

  export type LedgerUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<LedgerCreateWithoutTransactionsInput, LedgerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LedgerCreateOrConnectWithoutTransactionsInput
    upsert?: LedgerUpsertWithoutTransactionsInput
    connect?: LedgerWhereUniqueInput
    update?: XOR<LedgerUpdateWithoutTransactionsInput, LedgerUncheckedUpdateWithoutTransactionsInput>
  }

  export type JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<JournalEntryCreateWithoutTransactionsInput, JournalEntryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutTransactionsInput
    upsert?: JournalEntryUpsertWithoutTransactionsInput
    connect?: JournalEntryWhereUniqueInput
    update?: XOR<JournalEntryUpdateWithoutTransactionsInput, JournalEntryUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceCreateNestedManyWithoutPartyInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutPartyInput>, Enumerable<InvoiceUncheckedCreateWithoutPartyInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutPartyInput>
    createMany?: InvoiceCreateManyPartyInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type ItemCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<ItemCreateWithoutSupplierInput>, Enumerable<ItemUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutSupplierInput>
    createMany?: ItemCreateManySupplierInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutPartiesInput = {
    create?: XOR<UserCreateWithoutPartiesInput, UserUncheckedCreateWithoutPartiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartiesInput
    connect?: UserWhereUniqueInput
  }

  export type LedgerCreateNestedManyWithoutPartyInput = {
    create?: XOR<Enumerable<LedgerCreateWithoutPartyInput>, Enumerable<LedgerUncheckedCreateWithoutPartyInput>>
    connectOrCreate?: Enumerable<LedgerCreateOrConnectWithoutPartyInput>
    createMany?: LedgerCreateManyPartyInputEnvelope
    connect?: Enumerable<LedgerWhereUniqueInput>
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPartyInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutPartyInput>, Enumerable<InvoiceUncheckedCreateWithoutPartyInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutPartyInput>
    createMany?: InvoiceCreateManyPartyInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<ItemCreateWithoutSupplierInput>, Enumerable<ItemUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutSupplierInput>
    createMany?: ItemCreateManySupplierInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type LedgerUncheckedCreateNestedManyWithoutPartyInput = {
    create?: XOR<Enumerable<LedgerCreateWithoutPartyInput>, Enumerable<LedgerUncheckedCreateWithoutPartyInput>>
    connectOrCreate?: Enumerable<LedgerCreateOrConnectWithoutPartyInput>
    createMany?: LedgerCreateManyPartyInputEnvelope
    connect?: Enumerable<LedgerWhereUniqueInput>
  }

  export type EnumPartyTypeFieldUpdateOperationsInput = {
    set?: PartyType
  }

  export type InvoiceUpdateManyWithoutPartyNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutPartyInput>, Enumerable<InvoiceUncheckedCreateWithoutPartyInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutPartyInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutPartyInput>
    createMany?: InvoiceCreateManyPartyInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutPartyInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutPartyInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type ItemUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutSupplierInput>, Enumerable<ItemUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: ItemCreateManySupplierInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutPartiesNestedInput = {
    create?: XOR<UserCreateWithoutPartiesInput, UserUncheckedCreateWithoutPartiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartiesInput
    upsert?: UserUpsertWithoutPartiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPartiesInput, UserUncheckedUpdateWithoutPartiesInput>
  }

  export type LedgerUpdateManyWithoutPartyNestedInput = {
    create?: XOR<Enumerable<LedgerCreateWithoutPartyInput>, Enumerable<LedgerUncheckedCreateWithoutPartyInput>>
    connectOrCreate?: Enumerable<LedgerCreateOrConnectWithoutPartyInput>
    upsert?: Enumerable<LedgerUpsertWithWhereUniqueWithoutPartyInput>
    createMany?: LedgerCreateManyPartyInputEnvelope
    set?: Enumerable<LedgerWhereUniqueInput>
    disconnect?: Enumerable<LedgerWhereUniqueInput>
    delete?: Enumerable<LedgerWhereUniqueInput>
    connect?: Enumerable<LedgerWhereUniqueInput>
    update?: Enumerable<LedgerUpdateWithWhereUniqueWithoutPartyInput>
    updateMany?: Enumerable<LedgerUpdateManyWithWhereWithoutPartyInput>
    deleteMany?: Enumerable<LedgerScalarWhereInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutPartyNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutPartyInput>, Enumerable<InvoiceUncheckedCreateWithoutPartyInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutPartyInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutPartyInput>
    createMany?: InvoiceCreateManyPartyInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutPartyInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutPartyInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutSupplierInput>, Enumerable<ItemUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: ItemCreateManySupplierInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type LedgerUncheckedUpdateManyWithoutPartyNestedInput = {
    create?: XOR<Enumerable<LedgerCreateWithoutPartyInput>, Enumerable<LedgerUncheckedCreateWithoutPartyInput>>
    connectOrCreate?: Enumerable<LedgerCreateOrConnectWithoutPartyInput>
    upsert?: Enumerable<LedgerUpsertWithWhereUniqueWithoutPartyInput>
    createMany?: LedgerCreateManyPartyInputEnvelope
    set?: Enumerable<LedgerWhereUniqueInput>
    disconnect?: Enumerable<LedgerWhereUniqueInput>
    delete?: Enumerable<LedgerWhereUniqueInput>
    connect?: Enumerable<LedgerWhereUniqueInput>
    update?: Enumerable<LedgerUpdateWithWhereUniqueWithoutPartyInput>
    updateMany?: Enumerable<LedgerUpdateManyWithWhereWithoutPartyInput>
    deleteMany?: Enumerable<LedgerScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCategoryInput>, Enumerable<ItemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCategoryInput>
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCategoryInput>, Enumerable<ItemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCategoryInput>
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    upsert?: UserUpsertWithoutCategoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type ItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCategoryInput>, Enumerable<ItemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCategoryInput>, Enumerable<ItemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type CategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<CategoryCreateWithoutItemsInput, CategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutItemsInput
    connect?: CategoryWhereUniqueInput
  }

  export type PartyCreateNestedOneWithoutItemsInput = {
    create?: XOR<PartyCreateWithoutItemsInput, PartyUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PartyCreateOrConnectWithoutItemsInput
    connect?: PartyWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<InvoiceItemCreateWithoutItemInput>, Enumerable<InvoiceItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<InvoiceItemCreateOrConnectWithoutItemInput>
    createMany?: InvoiceItemCreateManyItemInputEnvelope
    connect?: Enumerable<InvoiceItemWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutItemsInput = {
    create?: XOR<UserCreateWithoutItemsInput, UserUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutItemsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<InvoiceItemCreateWithoutItemInput>, Enumerable<InvoiceItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<InvoiceItemCreateOrConnectWithoutItemInput>
    createMany?: InvoiceItemCreateManyItemInputEnvelope
    connect?: Enumerable<InvoiceItemWhereUniqueInput>
  }

  export type EnumItemUnitFieldUpdateOperationsInput = {
    set?: ItemUnit
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CategoryUpdateOneWithoutItemsNestedInput = {
    create?: XOR<CategoryCreateWithoutItemsInput, CategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutItemsInput
    upsert?: CategoryUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutItemsInput, CategoryUncheckedUpdateWithoutItemsInput>
  }

  export type PartyUpdateOneWithoutItemsNestedInput = {
    create?: XOR<PartyCreateWithoutItemsInput, PartyUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PartyCreateOrConnectWithoutItemsInput
    upsert?: PartyUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PartyWhereUniqueInput
    update?: XOR<PartyUpdateWithoutItemsInput, PartyUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<InvoiceItemCreateWithoutItemInput>, Enumerable<InvoiceItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<InvoiceItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<InvoiceItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: InvoiceItemCreateManyItemInputEnvelope
    set?: Enumerable<InvoiceItemWhereUniqueInput>
    disconnect?: Enumerable<InvoiceItemWhereUniqueInput>
    delete?: Enumerable<InvoiceItemWhereUniqueInput>
    connect?: Enumerable<InvoiceItemWhereUniqueInput>
    update?: Enumerable<InvoiceItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<InvoiceItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<InvoiceItemScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<UserCreateWithoutItemsInput, UserUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutItemsInput
    upsert?: UserUpsertWithoutItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutItemsInput, UserUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<InvoiceItemCreateWithoutItemInput>, Enumerable<InvoiceItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<InvoiceItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<InvoiceItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: InvoiceItemCreateManyItemInputEnvelope
    set?: Enumerable<InvoiceItemWhereUniqueInput>
    disconnect?: Enumerable<InvoiceItemWhereUniqueInput>
    delete?: Enumerable<InvoiceItemWhereUniqueInput>
    connect?: Enumerable<InvoiceItemWhereUniqueInput>
    update?: Enumerable<InvoiceItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<InvoiceItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<InvoiceItemScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type PartyCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PartyCreateWithoutInvoicesInput, PartyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PartyCreateOrConnectWithoutInvoicesInput
    connect?: PartyWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<InvoiceItemCreateWithoutInvoiceInput>, Enumerable<InvoiceItemUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceItemCreateOrConnectWithoutInvoiceInput>
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: Enumerable<InvoiceItemWhereUniqueInput>
  }

  export type AccountCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<Enumerable<AccountCreateWithoutInvoicesInput>, Enumerable<AccountUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutInvoicesInput>
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<InvoiceItemCreateWithoutInvoiceInput>, Enumerable<InvoiceItemUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceItemCreateOrConnectWithoutInvoiceInput>
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: Enumerable<InvoiceItemWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<Enumerable<AccountCreateWithoutInvoicesInput>, Enumerable<AccountUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutInvoicesInput>
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: InvoiceType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumModeOfPaymentFieldUpdateOperationsInput = {
    set?: ModeOfPayment
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: InvoiceStatus
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type PartyUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<PartyCreateWithoutInvoicesInput, PartyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PartyCreateOrConnectWithoutInvoicesInput
    upsert?: PartyUpsertWithoutInvoicesInput
    connect?: PartyWhereUniqueInput
    update?: XOR<PartyUpdateWithoutInvoicesInput, PartyUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<InvoiceItemCreateWithoutInvoiceInput>, Enumerable<InvoiceItemUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceItemCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: Enumerable<InvoiceItemWhereUniqueInput>
    disconnect?: Enumerable<InvoiceItemWhereUniqueInput>
    delete?: Enumerable<InvoiceItemWhereUniqueInput>
    connect?: Enumerable<InvoiceItemWhereUniqueInput>
    update?: Enumerable<InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<InvoiceItemUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<InvoiceItemScalarWhereInput>
  }

  export type AccountUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutInvoicesInput>, Enumerable<AccountUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutInvoicesInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutInvoicesInput>
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutInvoicesInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutInvoicesInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<InvoiceItemCreateWithoutInvoiceInput>, Enumerable<InvoiceItemUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceItemCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: Enumerable<InvoiceItemWhereUniqueInput>
    disconnect?: Enumerable<InvoiceItemWhereUniqueInput>
    delete?: Enumerable<InvoiceItemWhereUniqueInput>
    connect?: Enumerable<InvoiceItemWhereUniqueInput>
    update?: Enumerable<InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<InvoiceItemUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<InvoiceItemScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutInvoicesInput>, Enumerable<AccountUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutInvoicesInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutInvoicesInput>
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutInvoicesInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutInvoicesInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type ItemCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ItemCreateWithoutInvoiceItemsInput, ItemUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInvoiceItemsInput
    connect?: ItemWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutInvoiceItemsNestedInput = {
    create?: XOR<ItemCreateWithoutInvoiceItemsInput, ItemUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ItemUpsertWithoutInvoiceItemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutInvoiceItemsInput, ItemUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    upsert?: InvoiceUpsertWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: OrderStatus
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: PaymentStatus
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutAccountsInput>, Enumerable<InvoiceUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutAccountsInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type InvoiceUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutAccountsInput>, Enumerable<InvoiceUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutAccountsInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type InvoiceUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutAccountsInput>, Enumerable<InvoiceUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutAccountsInput>
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutAccountsInput>, Enumerable<InvoiceUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutAccountsInput>
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type EnumpaymentStatusFieldUpdateOperationsInput = {
    set?: paymentStatus
  }

  export type EnumpaymentMethodFieldUpdateOperationsInput = {
    set?: paymentMethod
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type LoanDocumentCreateNestedManyWithoutDocumentsInput = {
    create?: XOR<Enumerable<LoanDocumentCreateWithoutDocumentsInput>, Enumerable<LoanDocumentUncheckedCreateWithoutDocumentsInput>>
    connectOrCreate?: Enumerable<LoanDocumentCreateOrConnectWithoutDocumentsInput>
    connect?: Enumerable<LoanDocumentWhereUniqueInput>
  }

  export type LoanApplicationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<LoanApplicationCreateWithoutDocumentsInput, LoanApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutDocumentsInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type LoanDocumentUncheckedCreateNestedManyWithoutDocumentsInput = {
    create?: XOR<Enumerable<LoanDocumentCreateWithoutDocumentsInput>, Enumerable<LoanDocumentUncheckedCreateWithoutDocumentsInput>>
    connectOrCreate?: Enumerable<LoanDocumentCreateOrConnectWithoutDocumentsInput>
    connect?: Enumerable<LoanDocumentWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type LoanDocumentUpdateManyWithoutDocumentsNestedInput = {
    create?: XOR<Enumerable<LoanDocumentCreateWithoutDocumentsInput>, Enumerable<LoanDocumentUncheckedCreateWithoutDocumentsInput>>
    connectOrCreate?: Enumerable<LoanDocumentCreateOrConnectWithoutDocumentsInput>
    upsert?: Enumerable<LoanDocumentUpsertWithWhereUniqueWithoutDocumentsInput>
    set?: Enumerable<LoanDocumentWhereUniqueInput>
    disconnect?: Enumerable<LoanDocumentWhereUniqueInput>
    delete?: Enumerable<LoanDocumentWhereUniqueInput>
    connect?: Enumerable<LoanDocumentWhereUniqueInput>
    update?: Enumerable<LoanDocumentUpdateWithWhereUniqueWithoutDocumentsInput>
    updateMany?: Enumerable<LoanDocumentUpdateManyWithWhereWithoutDocumentsInput>
    deleteMany?: Enumerable<LoanDocumentScalarWhereInput>
  }

  export type LoanApplicationUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutDocumentsInput, LoanApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutDocumentsInput
    upsert?: LoanApplicationUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<LoanApplicationUpdateWithoutDocumentsInput, LoanApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type LoanDocumentUncheckedUpdateManyWithoutDocumentsNestedInput = {
    create?: XOR<Enumerable<LoanDocumentCreateWithoutDocumentsInput>, Enumerable<LoanDocumentUncheckedCreateWithoutDocumentsInput>>
    connectOrCreate?: Enumerable<LoanDocumentCreateOrConnectWithoutDocumentsInput>
    upsert?: Enumerable<LoanDocumentUpsertWithWhereUniqueWithoutDocumentsInput>
    set?: Enumerable<LoanDocumentWhereUniqueInput>
    disconnect?: Enumerable<LoanDocumentWhereUniqueInput>
    delete?: Enumerable<LoanDocumentWhereUniqueInput>
    connect?: Enumerable<LoanDocumentWhereUniqueInput>
    update?: Enumerable<LoanDocumentUpdateWithWhereUniqueWithoutDocumentsInput>
    updateMany?: Enumerable<LoanDocumentUpdateManyWithWhereWithoutDocumentsInput>
    deleteMany?: Enumerable<LoanDocumentScalarWhereInput>
  }

  export type UploadedDocumentCreateNestedManyWithoutDocsInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutDocsInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutDocsInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutDocsInput>
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
  }

  export type LoanCreateNestedManyWithoutDocumentsInput = {
    create?: XOR<Enumerable<LoanCreateWithoutDocumentsInput>, Enumerable<LoanUncheckedCreateWithoutDocumentsInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutDocumentsInput>
    connect?: Enumerable<LoanWhereUniqueInput>
  }

  export type UploadedDocumentUncheckedCreateNestedManyWithoutDocsInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutDocsInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutDocsInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutDocsInput>
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
  }

  export type LoanUncheckedCreateNestedManyWithoutDocumentsInput = {
    create?: XOR<Enumerable<LoanCreateWithoutDocumentsInput>, Enumerable<LoanUncheckedCreateWithoutDocumentsInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutDocumentsInput>
    connect?: Enumerable<LoanWhereUniqueInput>
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: DocumentType
  }

  export type UploadedDocumentUpdateManyWithoutDocsNestedInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutDocsInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutDocsInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutDocsInput>
    upsert?: Enumerable<UploadedDocumentUpsertWithWhereUniqueWithoutDocsInput>
    set?: Enumerable<UploadedDocumentWhereUniqueInput>
    disconnect?: Enumerable<UploadedDocumentWhereUniqueInput>
    delete?: Enumerable<UploadedDocumentWhereUniqueInput>
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
    update?: Enumerable<UploadedDocumentUpdateWithWhereUniqueWithoutDocsInput>
    updateMany?: Enumerable<UploadedDocumentUpdateManyWithWhereWithoutDocsInput>
    deleteMany?: Enumerable<UploadedDocumentScalarWhereInput>
  }

  export type LoanUpdateManyWithoutDocumentsNestedInput = {
    create?: XOR<Enumerable<LoanCreateWithoutDocumentsInput>, Enumerable<LoanUncheckedCreateWithoutDocumentsInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutDocumentsInput>
    upsert?: Enumerable<LoanUpsertWithWhereUniqueWithoutDocumentsInput>
    set?: Enumerable<LoanWhereUniqueInput>
    disconnect?: Enumerable<LoanWhereUniqueInput>
    delete?: Enumerable<LoanWhereUniqueInput>
    connect?: Enumerable<LoanWhereUniqueInput>
    update?: Enumerable<LoanUpdateWithWhereUniqueWithoutDocumentsInput>
    updateMany?: Enumerable<LoanUpdateManyWithWhereWithoutDocumentsInput>
    deleteMany?: Enumerable<LoanScalarWhereInput>
  }

  export type UploadedDocumentUncheckedUpdateManyWithoutDocsNestedInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutDocsInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutDocsInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutDocsInput>
    upsert?: Enumerable<UploadedDocumentUpsertWithWhereUniqueWithoutDocsInput>
    set?: Enumerable<UploadedDocumentWhereUniqueInput>
    disconnect?: Enumerable<UploadedDocumentWhereUniqueInput>
    delete?: Enumerable<UploadedDocumentWhereUniqueInput>
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
    update?: Enumerable<UploadedDocumentUpdateWithWhereUniqueWithoutDocsInput>
    updateMany?: Enumerable<UploadedDocumentUpdateManyWithWhereWithoutDocsInput>
    deleteMany?: Enumerable<UploadedDocumentScalarWhereInput>
  }

  export type LoanUncheckedUpdateManyWithoutDocumentsNestedInput = {
    create?: XOR<Enumerable<LoanCreateWithoutDocumentsInput>, Enumerable<LoanUncheckedCreateWithoutDocumentsInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutDocumentsInput>
    upsert?: Enumerable<LoanUpsertWithWhereUniqueWithoutDocumentsInput>
    set?: Enumerable<LoanWhereUniqueInput>
    disconnect?: Enumerable<LoanWhereUniqueInput>
    delete?: Enumerable<LoanWhereUniqueInput>
    connect?: Enumerable<LoanWhereUniqueInput>
    update?: Enumerable<LoanUpdateWithWhereUniqueWithoutDocumentsInput>
    updateMany?: Enumerable<LoanUpdateManyWithWhereWithoutDocumentsInput>
    deleteMany?: Enumerable<LoanScalarWhereInput>
  }

  export type LoanDocumentCreateNestedManyWithoutLoansInput = {
    create?: XOR<Enumerable<LoanDocumentCreateWithoutLoansInput>, Enumerable<LoanDocumentUncheckedCreateWithoutLoansInput>>
    connectOrCreate?: Enumerable<LoanDocumentCreateOrConnectWithoutLoansInput>
    connect?: Enumerable<LoanDocumentWhereUniqueInput>
  }

  export type LoanApplicationCreateNestedManyWithoutLoanInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutLoanInput>, Enumerable<LoanApplicationUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutLoanInput>
    createMany?: LoanApplicationCreateManyLoanInputEnvelope
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
  }

  export type LoanDocumentUncheckedCreateNestedManyWithoutLoansInput = {
    create?: XOR<Enumerable<LoanDocumentCreateWithoutLoansInput>, Enumerable<LoanDocumentUncheckedCreateWithoutLoansInput>>
    connectOrCreate?: Enumerable<LoanDocumentCreateOrConnectWithoutLoansInput>
    connect?: Enumerable<LoanDocumentWhereUniqueInput>
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutLoanInput>, Enumerable<LoanApplicationUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutLoanInput>
    createMany?: LoanApplicationCreateManyLoanInputEnvelope
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
  }

  export type EnumLoanTypeFieldUpdateOperationsInput = {
    set?: LoanType
  }

  export type LoanDocumentUpdateManyWithoutLoansNestedInput = {
    create?: XOR<Enumerable<LoanDocumentCreateWithoutLoansInput>, Enumerable<LoanDocumentUncheckedCreateWithoutLoansInput>>
    connectOrCreate?: Enumerable<LoanDocumentCreateOrConnectWithoutLoansInput>
    upsert?: Enumerable<LoanDocumentUpsertWithWhereUniqueWithoutLoansInput>
    set?: Enumerable<LoanDocumentWhereUniqueInput>
    disconnect?: Enumerable<LoanDocumentWhereUniqueInput>
    delete?: Enumerable<LoanDocumentWhereUniqueInput>
    connect?: Enumerable<LoanDocumentWhereUniqueInput>
    update?: Enumerable<LoanDocumentUpdateWithWhereUniqueWithoutLoansInput>
    updateMany?: Enumerable<LoanDocumentUpdateManyWithWhereWithoutLoansInput>
    deleteMany?: Enumerable<LoanDocumentScalarWhereInput>
  }

  export type LoanApplicationUpdateManyWithoutLoanNestedInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutLoanInput>, Enumerable<LoanApplicationUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutLoanInput>
    upsert?: Enumerable<LoanApplicationUpsertWithWhereUniqueWithoutLoanInput>
    createMany?: LoanApplicationCreateManyLoanInputEnvelope
    set?: Enumerable<LoanApplicationWhereUniqueInput>
    disconnect?: Enumerable<LoanApplicationWhereUniqueInput>
    delete?: Enumerable<LoanApplicationWhereUniqueInput>
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
    update?: Enumerable<LoanApplicationUpdateWithWhereUniqueWithoutLoanInput>
    updateMany?: Enumerable<LoanApplicationUpdateManyWithWhereWithoutLoanInput>
    deleteMany?: Enumerable<LoanApplicationScalarWhereInput>
  }

  export type LoanDocumentUncheckedUpdateManyWithoutLoansNestedInput = {
    create?: XOR<Enumerable<LoanDocumentCreateWithoutLoansInput>, Enumerable<LoanDocumentUncheckedCreateWithoutLoansInput>>
    connectOrCreate?: Enumerable<LoanDocumentCreateOrConnectWithoutLoansInput>
    upsert?: Enumerable<LoanDocumentUpsertWithWhereUniqueWithoutLoansInput>
    set?: Enumerable<LoanDocumentWhereUniqueInput>
    disconnect?: Enumerable<LoanDocumentWhereUniqueInput>
    delete?: Enumerable<LoanDocumentWhereUniqueInput>
    connect?: Enumerable<LoanDocumentWhereUniqueInput>
    update?: Enumerable<LoanDocumentUpdateWithWhereUniqueWithoutLoansInput>
    updateMany?: Enumerable<LoanDocumentUpdateManyWithWhereWithoutLoansInput>
    deleteMany?: Enumerable<LoanDocumentScalarWhereInput>
  }

  export type LoanApplicationUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutLoanInput>, Enumerable<LoanApplicationUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutLoanInput>
    upsert?: Enumerable<LoanApplicationUpsertWithWhereUniqueWithoutLoanInput>
    createMany?: LoanApplicationCreateManyLoanInputEnvelope
    set?: Enumerable<LoanApplicationWhereUniqueInput>
    disconnect?: Enumerable<LoanApplicationWhereUniqueInput>
    delete?: Enumerable<LoanApplicationWhereUniqueInput>
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
    update?: Enumerable<LoanApplicationUpdateWithWhereUniqueWithoutLoanInput>
    updateMany?: Enumerable<LoanApplicationUpdateManyWithWhereWithoutLoanInput>
    deleteMany?: Enumerable<LoanApplicationScalarWhereInput>
  }

  export type LoanCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<LoanCreateWithoutApplicationsInput, LoanUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutApplicationsInput
    connect?: LoanWhereUniqueInput
  }

  export type UploadedDocumentCreateNestedManyWithoutApplicationInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutApplicationInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutApplicationInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutApplicationInput>
    createMany?: UploadedDocumentCreateManyApplicationInputEnvelope
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
  }

  export type BankDetailsCreateNestedOneWithoutLoansInput = {
    create?: XOR<BankDetailsCreateWithoutLoansInput, BankDetailsUncheckedCreateWithoutLoansInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutLoansInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLoansInput = {
    create?: XOR<UserCreateWithoutLoansInput, UserUncheckedCreateWithoutLoansInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoansInput
    connect?: UserWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutLoansInput = {
    create?: XOR<AgentCreateWithoutLoansInput, AgentUncheckedCreateWithoutLoansInput>
    connectOrCreate?: AgentCreateOrConnectWithoutLoansInput
    connect?: AgentWhereUniqueInput
  }

  export type UploadedDocumentUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutApplicationInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutApplicationInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutApplicationInput>
    createMany?: UploadedDocumentCreateManyApplicationInputEnvelope
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
  }

  export type EnumLoanStatusFieldUpdateOperationsInput = {
    set?: LoanStatus
  }

  export type EnumNationalityFieldUpdateOperationsInput = {
    set?: Nationality
  }

  export type LoanUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<LoanCreateWithoutApplicationsInput, LoanUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutApplicationsInput
    upsert?: LoanUpsertWithoutApplicationsInput
    connect?: LoanWhereUniqueInput
    update?: XOR<LoanUpdateWithoutApplicationsInput, LoanUncheckedUpdateWithoutApplicationsInput>
  }

  export type UploadedDocumentUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutApplicationInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutApplicationInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutApplicationInput>
    upsert?: Enumerable<UploadedDocumentUpsertWithWhereUniqueWithoutApplicationInput>
    createMany?: UploadedDocumentCreateManyApplicationInputEnvelope
    set?: Enumerable<UploadedDocumentWhereUniqueInput>
    disconnect?: Enumerable<UploadedDocumentWhereUniqueInput>
    delete?: Enumerable<UploadedDocumentWhereUniqueInput>
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
    update?: Enumerable<UploadedDocumentUpdateWithWhereUniqueWithoutApplicationInput>
    updateMany?: Enumerable<UploadedDocumentUpdateManyWithWhereWithoutApplicationInput>
    deleteMany?: Enumerable<UploadedDocumentScalarWhereInput>
  }

  export type BankDetailsUpdateOneRequiredWithoutLoansNestedInput = {
    create?: XOR<BankDetailsCreateWithoutLoansInput, BankDetailsUncheckedCreateWithoutLoansInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutLoansInput
    upsert?: BankDetailsUpsertWithoutLoansInput
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<BankDetailsUpdateWithoutLoansInput, BankDetailsUncheckedUpdateWithoutLoansInput>
  }

  export type UserUpdateOneRequiredWithoutLoansNestedInput = {
    create?: XOR<UserCreateWithoutLoansInput, UserUncheckedCreateWithoutLoansInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoansInput
    upsert?: UserUpsertWithoutLoansInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLoansInput, UserUncheckedUpdateWithoutLoansInput>
  }

  export type AgentUpdateOneWithoutLoansNestedInput = {
    create?: XOR<AgentCreateWithoutLoansInput, AgentUncheckedCreateWithoutLoansInput>
    connectOrCreate?: AgentCreateOrConnectWithoutLoansInput
    upsert?: AgentUpsertWithoutLoansInput
    disconnect?: boolean
    delete?: boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<AgentUpdateWithoutLoansInput, AgentUncheckedUpdateWithoutLoansInput>
  }

  export type UploadedDocumentUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<Enumerable<UploadedDocumentCreateWithoutApplicationInput>, Enumerable<UploadedDocumentUncheckedCreateWithoutApplicationInput>>
    connectOrCreate?: Enumerable<UploadedDocumentCreateOrConnectWithoutApplicationInput>
    upsert?: Enumerable<UploadedDocumentUpsertWithWhereUniqueWithoutApplicationInput>
    createMany?: UploadedDocumentCreateManyApplicationInputEnvelope
    set?: Enumerable<UploadedDocumentWhereUniqueInput>
    disconnect?: Enumerable<UploadedDocumentWhereUniqueInput>
    delete?: Enumerable<UploadedDocumentWhereUniqueInput>
    connect?: Enumerable<UploadedDocumentWhereUniqueInput>
    update?: Enumerable<UploadedDocumentUpdateWithWhereUniqueWithoutApplicationInput>
    updateMany?: Enumerable<UploadedDocumentUpdateManyWithWhereWithoutApplicationInput>
    deleteMany?: Enumerable<UploadedDocumentScalarWhereInput>
  }

  export type LoanApplicationCreateNestedManyWithoutBankDetailsInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutBankDetailsInput>, Enumerable<LoanApplicationUncheckedCreateWithoutBankDetailsInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutBankDetailsInput>
    createMany?: LoanApplicationCreateManyBankDetailsInputEnvelope
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutBankAccountsInput = {
    create?: XOR<UserCreateWithoutBankAccountsInput, UserUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBankAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutBankDetailsInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutBankDetailsInput>, Enumerable<LoanApplicationUncheckedCreateWithoutBankDetailsInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutBankDetailsInput>
    createMany?: LoanApplicationCreateManyBankDetailsInputEnvelope
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
  }

  export type EnumBankAccountTypeFieldUpdateOperationsInput = {
    set?: BankAccountType
  }

  export type LoanApplicationUpdateManyWithoutBankDetailsNestedInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutBankDetailsInput>, Enumerable<LoanApplicationUncheckedCreateWithoutBankDetailsInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutBankDetailsInput>
    upsert?: Enumerable<LoanApplicationUpsertWithWhereUniqueWithoutBankDetailsInput>
    createMany?: LoanApplicationCreateManyBankDetailsInputEnvelope
    set?: Enumerable<LoanApplicationWhereUniqueInput>
    disconnect?: Enumerable<LoanApplicationWhereUniqueInput>
    delete?: Enumerable<LoanApplicationWhereUniqueInput>
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
    update?: Enumerable<LoanApplicationUpdateWithWhereUniqueWithoutBankDetailsInput>
    updateMany?: Enumerable<LoanApplicationUpdateManyWithWhereWithoutBankDetailsInput>
    deleteMany?: Enumerable<LoanApplicationScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutBankAccountsNestedInput = {
    create?: XOR<UserCreateWithoutBankAccountsInput, UserUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBankAccountsInput
    upsert?: UserUpsertWithoutBankAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBankAccountsInput, UserUncheckedUpdateWithoutBankAccountsInput>
  }

  export type LoanApplicationUncheckedUpdateManyWithoutBankDetailsNestedInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutBankDetailsInput>, Enumerable<LoanApplicationUncheckedCreateWithoutBankDetailsInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutBankDetailsInput>
    upsert?: Enumerable<LoanApplicationUpsertWithWhereUniqueWithoutBankDetailsInput>
    createMany?: LoanApplicationCreateManyBankDetailsInputEnvelope
    set?: Enumerable<LoanApplicationWhereUniqueInput>
    disconnect?: Enumerable<LoanApplicationWhereUniqueInput>
    delete?: Enumerable<LoanApplicationWhereUniqueInput>
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
    update?: Enumerable<LoanApplicationUpdateWithWhereUniqueWithoutBankDetailsInput>
    updateMany?: Enumerable<LoanApplicationUpdateManyWithWhereWithoutBankDetailsInput>
    deleteMany?: Enumerable<LoanApplicationScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutInsurancesInput = {
    create?: XOR<UserCreateWithoutInsurancesInput, UserUncheckedCreateWithoutInsurancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsurancesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInsurancesNestedInput = {
    create?: XOR<UserCreateWithoutInsurancesInput, UserUncheckedCreateWithoutInsurancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsurancesInput
    upsert?: UserUpsertWithoutInsurancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInsurancesInput, UserUncheckedUpdateWithoutInsurancesInput>
  }

  export type UserCreateNestedOneWithoutClientAccountsInput = {
    create?: XOR<UserCreateWithoutClientAccountsInput, UserUncheckedCreateWithoutClientAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutClientsInput = {
    create?: XOR<AgentCreateWithoutClientsInput, AgentUncheckedCreateWithoutClientsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutClientsInput
    connect?: AgentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutClientAccountsNestedInput = {
    create?: XOR<UserCreateWithoutClientAccountsInput, UserUncheckedCreateWithoutClientAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientAccountsInput
    upsert?: UserUpsertWithoutClientAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutClientAccountsInput, UserUncheckedUpdateWithoutClientAccountsInput>
  }

  export type AgentUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<AgentCreateWithoutClientsInput, AgentUncheckedCreateWithoutClientsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutClientsInput
    upsert?: AgentUpsertWithoutClientsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<AgentUpdateWithoutClientsInput, AgentUncheckedUpdateWithoutClientsInput>
  }

  export type ClientCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<ClientCreateWithoutAgentInput>, Enumerable<ClientUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutAgentInput>
    createMany?: ClientCreateManyAgentInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutAgentIdInput = {
    create?: XOR<UserCreateWithoutAgentIdInput, UserUncheckedCreateWithoutAgentIdInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentIdInput
    connect?: UserWhereUniqueInput
  }

  export type LoanApplicationCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutAgentInput>, Enumerable<LoanApplicationUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutAgentInput>
    createMany?: LoanApplicationCreateManyAgentInputEnvelope
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
  }

  export type ClientUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<ClientCreateWithoutAgentInput>, Enumerable<ClientUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutAgentInput>
    createMany?: ClientCreateManyAgentInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutAgentInput>, Enumerable<LoanApplicationUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutAgentInput>
    createMany?: LoanApplicationCreateManyAgentInputEnvelope
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
  }

  export type ClientUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<ClientCreateWithoutAgentInput>, Enumerable<ClientUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: ClientCreateManyAgentInputEnvelope
    set?: Enumerable<ClientWhereUniqueInput>
    disconnect?: Enumerable<ClientWhereUniqueInput>
    delete?: Enumerable<ClientWhereUniqueInput>
    connect?: Enumerable<ClientWhereUniqueInput>
    update?: Enumerable<ClientUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<ClientUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<ClientScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutAgentIdNestedInput = {
    create?: XOR<UserCreateWithoutAgentIdInput, UserUncheckedCreateWithoutAgentIdInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentIdInput
    upsert?: UserUpsertWithoutAgentIdInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAgentIdInput, UserUncheckedUpdateWithoutAgentIdInput>
  }

  export type LoanApplicationUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutAgentInput>, Enumerable<LoanApplicationUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<LoanApplicationUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: LoanApplicationCreateManyAgentInputEnvelope
    set?: Enumerable<LoanApplicationWhereUniqueInput>
    disconnect?: Enumerable<LoanApplicationWhereUniqueInput>
    delete?: Enumerable<LoanApplicationWhereUniqueInput>
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
    update?: Enumerable<LoanApplicationUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<LoanApplicationUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<LoanApplicationScalarWhereInput>
  }

  export type ClientUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<ClientCreateWithoutAgentInput>, Enumerable<ClientUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: ClientCreateManyAgentInputEnvelope
    set?: Enumerable<ClientWhereUniqueInput>
    disconnect?: Enumerable<ClientWhereUniqueInput>
    delete?: Enumerable<ClientWhereUniqueInput>
    connect?: Enumerable<ClientWhereUniqueInput>
    update?: Enumerable<ClientUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<ClientUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<ClientScalarWhereInput>
  }

  export type LoanApplicationUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<LoanApplicationCreateWithoutAgentInput>, Enumerable<LoanApplicationUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<LoanApplicationCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<LoanApplicationUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: LoanApplicationCreateManyAgentInputEnvelope
    set?: Enumerable<LoanApplicationWhereUniqueInput>
    disconnect?: Enumerable<LoanApplicationWhereUniqueInput>
    delete?: Enumerable<LoanApplicationWhereUniqueInput>
    connect?: Enumerable<LoanApplicationWhereUniqueInput>
    update?: Enumerable<LoanApplicationUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<LoanApplicationUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<LoanApplicationScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutRegisterStartupInput = {
    create?: XOR<UserCreateWithoutRegisterStartupInput, UserUncheckedCreateWithoutRegisterStartupInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegisterStartupInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStartupCategoryFieldUpdateOperationsInput = {
    set?: StartupCategory
  }

  export type UserUpdateOneRequiredWithoutRegisterStartupNestedInput = {
    create?: XOR<UserCreateWithoutRegisterStartupInput, UserUncheckedCreateWithoutRegisterStartupInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegisterStartupInput
    upsert?: UserUpsertWithoutRegisterStartupInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRegisterStartupInput, UserUncheckedUpdateWithoutRegisterStartupInput>
  }

  export type UserCreateNestedOneWithoutContactUsInput = {
    create?: XOR<UserCreateWithoutContactUsInput, UserUncheckedCreateWithoutContactUsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactUsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutContactUsNestedInput = {
    create?: XOR<UserCreateWithoutContactUsInput, UserUncheckedCreateWithoutContactUsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactUsInput
    upsert?: UserUpsertWithoutContactUsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutContactUsInput, UserUncheckedUpdateWithoutContactUsInput>
  }

  export type UserCreateNestedOneWithoutGstr1Input = {
    create?: XOR<UserCreateWithoutGstr1Input, UserUncheckedCreateWithoutGstr1Input>
    connectOrCreate?: UserCreateOrConnectWithoutGstr1Input
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGstr1NestedInput = {
    create?: XOR<UserCreateWithoutGstr1Input, UserUncheckedCreateWithoutGstr1Input>
    connectOrCreate?: UserCreateOrConnectWithoutGstr1Input
    upsert?: UserUpsertWithoutGstr1Input
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGstr1Input, UserUncheckedUpdateWithoutGstr1Input>
  }

  export type UserCreateNestedOneWithoutGstr1_5AInput = {
    create?: XOR<UserCreateWithoutGstr1_5AInput, UserUncheckedCreateWithoutGstr1_5AInput>
    connectOrCreate?: UserCreateOrConnectWithoutGstr1_5AInput
    connect?: UserWhereUniqueInput
  }

  export type Gstr1_5A_itemCreateNestedManyWithoutGstr1_5AInput = {
    create?: XOR<Enumerable<Gstr1_5A_itemCreateWithoutGstr1_5AInput>, Enumerable<Gstr1_5A_itemUncheckedCreateWithoutGstr1_5AInput>>
    connectOrCreate?: Enumerable<Gstr1_5A_itemCreateOrConnectWithoutGstr1_5AInput>
    createMany?: Gstr1_5A_itemCreateManyGstr1_5AInputEnvelope
    connect?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
  }

  export type Gstr1_5A_itemUncheckedCreateNestedManyWithoutGstr1_5AInput = {
    create?: XOR<Enumerable<Gstr1_5A_itemCreateWithoutGstr1_5AInput>, Enumerable<Gstr1_5A_itemUncheckedCreateWithoutGstr1_5AInput>>
    connectOrCreate?: Enumerable<Gstr1_5A_itemCreateOrConnectWithoutGstr1_5AInput>
    createMany?: Gstr1_5A_itemCreateManyGstr1_5AInputEnvelope
    connect?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutGstr1_5ANestedInput = {
    create?: XOR<UserCreateWithoutGstr1_5AInput, UserUncheckedCreateWithoutGstr1_5AInput>
    connectOrCreate?: UserCreateOrConnectWithoutGstr1_5AInput
    upsert?: UserUpsertWithoutGstr1_5AInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGstr1_5AInput, UserUncheckedUpdateWithoutGstr1_5AInput>
  }

  export type Gstr1_5A_itemUpdateManyWithoutGstr1_5ANestedInput = {
    create?: XOR<Enumerable<Gstr1_5A_itemCreateWithoutGstr1_5AInput>, Enumerable<Gstr1_5A_itemUncheckedCreateWithoutGstr1_5AInput>>
    connectOrCreate?: Enumerable<Gstr1_5A_itemCreateOrConnectWithoutGstr1_5AInput>
    upsert?: Enumerable<Gstr1_5A_itemUpsertWithWhereUniqueWithoutGstr1_5AInput>
    createMany?: Gstr1_5A_itemCreateManyGstr1_5AInputEnvelope
    set?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
    disconnect?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
    delete?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
    connect?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
    update?: Enumerable<Gstr1_5A_itemUpdateWithWhereUniqueWithoutGstr1_5AInput>
    updateMany?: Enumerable<Gstr1_5A_itemUpdateManyWithWhereWithoutGstr1_5AInput>
    deleteMany?: Enumerable<Gstr1_5A_itemScalarWhereInput>
  }

  export type Gstr1_5A_itemUncheckedUpdateManyWithoutGstr1_5ANestedInput = {
    create?: XOR<Enumerable<Gstr1_5A_itemCreateWithoutGstr1_5AInput>, Enumerable<Gstr1_5A_itemUncheckedCreateWithoutGstr1_5AInput>>
    connectOrCreate?: Enumerable<Gstr1_5A_itemCreateOrConnectWithoutGstr1_5AInput>
    upsert?: Enumerable<Gstr1_5A_itemUpsertWithWhereUniqueWithoutGstr1_5AInput>
    createMany?: Gstr1_5A_itemCreateManyGstr1_5AInputEnvelope
    set?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
    disconnect?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
    delete?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
    connect?: Enumerable<Gstr1_5A_itemWhereUniqueInput>
    update?: Enumerable<Gstr1_5A_itemUpdateWithWhereUniqueWithoutGstr1_5AInput>
    updateMany?: Enumerable<Gstr1_5A_itemUpdateManyWithWhereWithoutGstr1_5AInput>
    deleteMany?: Enumerable<Gstr1_5A_itemScalarWhereInput>
  }

  export type Gstr1_5ACreateNestedOneWithoutGstr1_5A_itemsInput = {
    create?: XOR<Gstr1_5ACreateWithoutGstr1_5A_itemsInput, Gstr1_5AUncheckedCreateWithoutGstr1_5A_itemsInput>
    connectOrCreate?: Gstr1_5ACreateOrConnectWithoutGstr1_5A_itemsInput
    connect?: Gstr1_5AWhereUniqueInput
  }

  export type Gstr1_5AUpdateOneRequiredWithoutGstr1_5A_itemsNestedInput = {
    create?: XOR<Gstr1_5ACreateWithoutGstr1_5A_itemsInput, Gstr1_5AUncheckedCreateWithoutGstr1_5A_itemsInput>
    connectOrCreate?: Gstr1_5ACreateOrConnectWithoutGstr1_5A_itemsInput
    upsert?: Gstr1_5AUpsertWithoutGstr1_5A_itemsInput
    connect?: Gstr1_5AWhereUniqueInput
    update?: XOR<Gstr1_5AUpdateWithoutGstr1_5A_itemsInput, Gstr1_5AUncheckedUpdateWithoutGstr1_5A_itemsInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumUserGenderFilter = {
    equals?: UserGender
    in?: Enumerable<UserGender>
    notIn?: Enumerable<UserGender>
    not?: NestedEnumUserGenderFilter | UserGender
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumUserGenderWithAggregatesFilter = {
    equals?: UserGender
    in?: Enumerable<UserGender>
    notIn?: Enumerable<UserGender>
    not?: NestedEnumUserGenderWithAggregatesFilter | UserGender
    _count?: NestedIntFilter
    _min?: NestedEnumUserGenderFilter
    _max?: NestedEnumUserGenderFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumLedgerTypeFilter = {
    equals?: LedgerType
    in?: Enumerable<LedgerType>
    notIn?: Enumerable<LedgerType>
    not?: NestedEnumLedgerTypeFilter | LedgerType
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedEnumLedgerTypeWithAggregatesFilter = {
    equals?: LedgerType
    in?: Enumerable<LedgerType>
    notIn?: Enumerable<LedgerType>
    not?: NestedEnumLedgerTypeWithAggregatesFilter | LedgerType
    _count?: NestedIntFilter
    _min?: NestedEnumLedgerTypeFilter
    _max?: NestedEnumLedgerTypeFilter
  }

  export type NestedEnumTransactionTypeFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeFilter | TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeWithAggregatesFilter | TransactionType
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionTypeFilter
    _max?: NestedEnumTransactionTypeFilter
  }

  export type NestedEnumPartyTypeFilter = {
    equals?: PartyType
    in?: Enumerable<PartyType>
    notIn?: Enumerable<PartyType>
    not?: NestedEnumPartyTypeFilter | PartyType
  }

  export type NestedEnumPartyTypeWithAggregatesFilter = {
    equals?: PartyType
    in?: Enumerable<PartyType>
    notIn?: Enumerable<PartyType>
    not?: NestedEnumPartyTypeWithAggregatesFilter | PartyType
    _count?: NestedIntFilter
    _min?: NestedEnumPartyTypeFilter
    _max?: NestedEnumPartyTypeFilter
  }

  export type NestedEnumItemUnitFilter = {
    equals?: ItemUnit
    in?: Enumerable<ItemUnit>
    notIn?: Enumerable<ItemUnit>
    not?: NestedEnumItemUnitFilter | ItemUnit
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumItemUnitWithAggregatesFilter = {
    equals?: ItemUnit
    in?: Enumerable<ItemUnit>
    notIn?: Enumerable<ItemUnit>
    not?: NestedEnumItemUnitWithAggregatesFilter | ItemUnit
    _count?: NestedIntFilter
    _min?: NestedEnumItemUnitFilter
    _max?: NestedEnumItemUnitFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedEnumInvoiceTypeFilter = {
    equals?: InvoiceType
    in?: Enumerable<InvoiceType>
    notIn?: Enumerable<InvoiceType>
    not?: NestedEnumInvoiceTypeFilter | InvoiceType
  }

  export type NestedEnumModeOfPaymentFilter = {
    equals?: ModeOfPayment
    in?: Enumerable<ModeOfPayment>
    notIn?: Enumerable<ModeOfPayment>
    not?: NestedEnumModeOfPaymentFilter | ModeOfPayment
  }

  export type NestedEnumInvoiceStatusFilter = {
    equals?: InvoiceStatus
    in?: Enumerable<InvoiceStatus>
    notIn?: Enumerable<InvoiceStatus>
    not?: NestedEnumInvoiceStatusFilter | InvoiceStatus
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter = {
    equals?: InvoiceType
    in?: Enumerable<InvoiceType>
    notIn?: Enumerable<InvoiceType>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter | InvoiceType
    _count?: NestedIntFilter
    _min?: NestedEnumInvoiceTypeFilter
    _max?: NestedEnumInvoiceTypeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumModeOfPaymentWithAggregatesFilter = {
    equals?: ModeOfPayment
    in?: Enumerable<ModeOfPayment>
    notIn?: Enumerable<ModeOfPayment>
    not?: NestedEnumModeOfPaymentWithAggregatesFilter | ModeOfPayment
    _count?: NestedIntFilter
    _min?: NestedEnumModeOfPaymentFilter
    _max?: NestedEnumModeOfPaymentFilter
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter = {
    equals?: InvoiceStatus
    in?: Enumerable<InvoiceStatus>
    notIn?: Enumerable<InvoiceStatus>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter | InvoiceStatus
    _count?: NestedIntFilter
    _min?: NestedEnumInvoiceStatusFilter
    _max?: NestedEnumInvoiceStatusFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumOrderStatusFilter = {
    equals?: OrderStatus
    in?: Enumerable<OrderStatus>
    notIn?: Enumerable<OrderStatus>
    not?: NestedEnumOrderStatusFilter | OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter = {
    equals?: OrderStatus
    in?: Enumerable<OrderStatus>
    notIn?: Enumerable<OrderStatus>
    not?: NestedEnumOrderStatusWithAggregatesFilter | OrderStatus
    _count?: NestedIntFilter
    _min?: NestedEnumOrderStatusFilter
    _max?: NestedEnumOrderStatusFilter
  }

  export type NestedEnumPaymentStatusFilter = {
    equals?: PaymentStatus
    in?: Enumerable<PaymentStatus>
    notIn?: Enumerable<PaymentStatus>
    not?: NestedEnumPaymentStatusFilter | PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter = {
    equals?: PaymentStatus
    in?: Enumerable<PaymentStatus>
    notIn?: Enumerable<PaymentStatus>
    not?: NestedEnumPaymentStatusWithAggregatesFilter | PaymentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentStatusFilter
    _max?: NestedEnumPaymentStatusFilter
  }

  export type NestedEnumpaymentStatusFilter = {
    equals?: paymentStatus
    in?: Enumerable<paymentStatus>
    notIn?: Enumerable<paymentStatus>
    not?: NestedEnumpaymentStatusFilter | paymentStatus
  }

  export type NestedEnumpaymentMethodFilter = {
    equals?: paymentMethod
    in?: Enumerable<paymentMethod>
    notIn?: Enumerable<paymentMethod>
    not?: NestedEnumpaymentMethodFilter | paymentMethod
  }

  export type NestedEnumpaymentStatusWithAggregatesFilter = {
    equals?: paymentStatus
    in?: Enumerable<paymentStatus>
    notIn?: Enumerable<paymentStatus>
    not?: NestedEnumpaymentStatusWithAggregatesFilter | paymentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumpaymentStatusFilter
    _max?: NestedEnumpaymentStatusFilter
  }

  export type NestedEnumpaymentMethodWithAggregatesFilter = {
    equals?: paymentMethod
    in?: Enumerable<paymentMethod>
    notIn?: Enumerable<paymentMethod>
    not?: NestedEnumpaymentMethodWithAggregatesFilter | paymentMethod
    _count?: NestedIntFilter
    _min?: NestedEnumpaymentMethodFilter
    _max?: NestedEnumpaymentMethodFilter
  }

  export type NestedEnumDocumentTypeFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeFilter | DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeWithAggregatesFilter | DocumentType
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentTypeFilter
    _max?: NestedEnumDocumentTypeFilter
  }

  export type NestedEnumLoanTypeFilter = {
    equals?: LoanType
    in?: Enumerable<LoanType>
    notIn?: Enumerable<LoanType>
    not?: NestedEnumLoanTypeFilter | LoanType
  }

  export type NestedEnumLoanTypeWithAggregatesFilter = {
    equals?: LoanType
    in?: Enumerable<LoanType>
    notIn?: Enumerable<LoanType>
    not?: NestedEnumLoanTypeWithAggregatesFilter | LoanType
    _count?: NestedIntFilter
    _min?: NestedEnumLoanTypeFilter
    _max?: NestedEnumLoanTypeFilter
  }

  export type NestedEnumLoanStatusFilter = {
    equals?: LoanStatus
    in?: Enumerable<LoanStatus>
    notIn?: Enumerable<LoanStatus>
    not?: NestedEnumLoanStatusFilter | LoanStatus
  }

  export type NestedEnumNationalityFilter = {
    equals?: Nationality
    in?: Enumerable<Nationality>
    notIn?: Enumerable<Nationality>
    not?: NestedEnumNationalityFilter | Nationality
  }

  export type NestedEnumLoanStatusWithAggregatesFilter = {
    equals?: LoanStatus
    in?: Enumerable<LoanStatus>
    notIn?: Enumerable<LoanStatus>
    not?: NestedEnumLoanStatusWithAggregatesFilter | LoanStatus
    _count?: NestedIntFilter
    _min?: NestedEnumLoanStatusFilter
    _max?: NestedEnumLoanStatusFilter
  }

  export type NestedEnumNationalityWithAggregatesFilter = {
    equals?: Nationality
    in?: Enumerable<Nationality>
    notIn?: Enumerable<Nationality>
    not?: NestedEnumNationalityWithAggregatesFilter | Nationality
    _count?: NestedIntFilter
    _min?: NestedEnumNationalityFilter
    _max?: NestedEnumNationalityFilter
  }

  export type NestedEnumBankAccountTypeFilter = {
    equals?: BankAccountType
    in?: Enumerable<BankAccountType>
    notIn?: Enumerable<BankAccountType>
    not?: NestedEnumBankAccountTypeFilter | BankAccountType
  }

  export type NestedEnumBankAccountTypeWithAggregatesFilter = {
    equals?: BankAccountType
    in?: Enumerable<BankAccountType>
    notIn?: Enumerable<BankAccountType>
    not?: NestedEnumBankAccountTypeWithAggregatesFilter | BankAccountType
    _count?: NestedIntFilter
    _min?: NestedEnumBankAccountTypeFilter
    _max?: NestedEnumBankAccountTypeFilter
  }

  export type NestedEnumStartupCategoryFilter = {
    equals?: StartupCategory
    in?: Enumerable<StartupCategory>
    notIn?: Enumerable<StartupCategory>
    not?: NestedEnumStartupCategoryFilter | StartupCategory
  }

  export type NestedEnumStartupCategoryWithAggregatesFilter = {
    equals?: StartupCategory
    in?: Enumerable<StartupCategory>
    notIn?: Enumerable<StartupCategory>
    not?: NestedEnumStartupCategoryWithAggregatesFilter | StartupCategory
    _count?: NestedIntFilter
    _min?: NestedEnumStartupCategoryFilter
    _max?: NestedEnumStartupCategoryFilter
  }

  export type OtpCreateWithoutUserInput = {
    createdAt?: Date | string
    otp: string
    used?: boolean
  }

  export type OtpUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    otp: string
    used?: boolean
  }

  export type OtpCreateOrConnectWithoutUserInput = {
    where: OtpWhereUniqueInput
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type OtpCreateManyUserInputEnvelope = {
    data: Enumerable<OtpCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BusinessProfileCreateWithoutUserInput = {
    businessName: string
    pan?: string | null
    tan?: string | null
    gstin?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAddressVerified?: boolean | null
    isBusinessNameVerified?: boolean | null
    isGstinVerified?: boolean | null
    isPanVerified?: boolean | null
    isStateVerified?: boolean | null
  }

  export type BusinessProfileUncheckedCreateWithoutUserInput = {
    id?: number
    businessName: string
    pan?: string | null
    tan?: string | null
    gstin?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNo?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAddressVerified?: boolean | null
    isBusinessNameVerified?: boolean | null
    isGstinVerified?: boolean | null
    isPanVerified?: boolean | null
    isStateVerified?: boolean | null
  }

  export type BusinessProfileCreateOrConnectWithoutUserInput = {
    where: BusinessProfileWhereUniqueInput
    create: XOR<BusinessProfileCreateWithoutUserInput, BusinessProfileUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    party: PartyCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    accounts?: AccountCreateNestedManyWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    partyId: string
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: Enumerable<InvoiceCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutUserInput = {
    id?: string
    categoryName: string
    items?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutUserInput = {
    id?: string
    categoryName: string
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutUserInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput>
  }

  export type CategoryCreateManyUserInputEnvelope = {
    data: Enumerable<CategoryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutUserInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutItemsInput
    supplier?: PartyCreateNestedOneWithoutItemsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutUserInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    categoryId?: string | null
    supplierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutUserInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutUserInput, ItemUncheckedCreateWithoutUserInput>
  }

  export type ItemCreateManyUserInputEnvelope = {
    data: Enumerable<ItemCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PartyCreateWithoutUserInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPartyInput
    items?: ItemCreateNestedManyWithoutSupplierInput
    ledgers?: LedgerCreateNestedManyWithoutPartyInput
  }

  export type PartyUncheckedCreateWithoutUserInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPartyInput
    items?: ItemUncheckedCreateNestedManyWithoutSupplierInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutPartyInput
  }

  export type PartyCreateOrConnectWithoutUserInput = {
    where: PartyWhereUniqueInput
    create: XOR<PartyCreateWithoutUserInput, PartyUncheckedCreateWithoutUserInput>
  }

  export type PartyCreateManyUserInputEnvelope = {
    data: Enumerable<PartyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    razorpay_order_id: string
    razorpay_payment_id: string
    status?: PaymentStatus
    orderId: number
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    razorpay_order_id: string
    razorpay_payment_id: string
    status?: PaymentStatus
    orderId: number
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: Enumerable<PaymentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    services: JsonNullValueInput | InputJsonValue
    status?: OrderStatus
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    orderTotal: Decimal | DecimalJsLike | number | string
    stateOfSupply: string
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    services: JsonNullValueInput | InputJsonValue
    status?: OrderStatus
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    orderTotal: Decimal | DecimalJsLike | number | string
    stateOfSupply: string
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: Enumerable<OrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutUserInput = {
    id?: string
    title: string
    contentheading: string
    contentdiscription: string
    category: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    contentheading: string
    contentdiscription: string
    category: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: Enumerable<PostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountName: string
    totalDebit?: Decimal | DecimalJsLike | number | string
    totalCredit?: Decimal | DecimalJsLike | number | string
    debitBalance?: Decimal | DecimalJsLike | number | string
    creditBalance?: Decimal | DecimalJsLike | number | string
    date?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountName: string
    totalDebit?: Decimal | DecimalJsLike | number | string
    totalCredit?: Decimal | DecimalJsLike | number | string
    debitBalance?: Decimal | DecimalJsLike | number | string
    creditBalance?: Decimal | DecimalJsLike | number | string
    date?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BankDetailsCreateWithoutUserInput = {
    id?: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    createdAt?: Date | string
    updatedAt?: Date | string
    loans?: LoanApplicationCreateNestedManyWithoutBankDetailsInput
  }

  export type BankDetailsUncheckedCreateWithoutUserInput = {
    id?: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    createdAt?: Date | string
    updatedAt?: Date | string
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutBankDetailsInput
  }

  export type BankDetailsCreateOrConnectWithoutUserInput = {
    where: BankDetailsWhereUniqueInput
    create: XOR<BankDetailsCreateWithoutUserInput, BankDetailsUncheckedCreateWithoutUserInput>
  }

  export type BankDetailsCreateManyUserInputEnvelope = {
    data: Enumerable<BankDetailsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LoanApplicationCreateWithoutUserInput = {
    id?: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutApplicationsInput
    documents?: UploadedDocumentCreateNestedManyWithoutApplicationInput
    bankDetails: BankDetailsCreateNestedOneWithoutLoansInput
    agent?: AgentCreateNestedOneWithoutLoansInput
  }

  export type LoanApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type LoanApplicationCreateOrConnectWithoutUserInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutUserInput, LoanApplicationUncheckedCreateWithoutUserInput>
  }

  export type LoanApplicationCreateManyUserInputEnvelope = {
    data: Enumerable<LoanApplicationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UploadedDocumentCreateWithoutUserInput = {
    id?: string
    fileName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    docs?: LoanDocumentCreateNestedManyWithoutDocumentsInput
    application?: LoanApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type UploadedDocumentUncheckedCreateWithoutUserInput = {
    id?: string
    fileName: string
    applicationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    docs?: LoanDocumentUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type UploadedDocumentCreateOrConnectWithoutUserInput = {
    where: UploadedDocumentWhereUniqueInput
    create: XOR<UploadedDocumentCreateWithoutUserInput, UploadedDocumentUncheckedCreateWithoutUserInput>
  }

  export type UploadedDocumentCreateManyUserInputEnvelope = {
    data: Enumerable<UploadedDocumentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type InsuranceCreateWithoutUserInput = {
    id?: string
    type: string
    name: string
    mobile: string
    email: string
    address: string
    dob: Date | string
    maritalStatus: string
    gender: UserGender
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    name: string
    mobile: string
    email: string
    address: string
    dob: Date | string
    maritalStatus: string
    gender: UserGender
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceCreateOrConnectWithoutUserInput = {
    where: InsuranceWhereUniqueInput
    create: XOR<InsuranceCreateWithoutUserInput, InsuranceUncheckedCreateWithoutUserInput>
  }

  export type InsuranceCreateManyUserInputEnvelope = {
    data: Enumerable<InsuranceCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RegisterStartupCreateWithoutUserInput = {
    title: string
    image: string
    categories: StartupCategory
  }

  export type RegisterStartupUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    image: string
    categories: StartupCategory
  }

  export type RegisterStartupCreateOrConnectWithoutUserInput = {
    where: RegisterStartupWhereUniqueInput
    create: XOR<RegisterStartupCreateWithoutUserInput, RegisterStartupUncheckedCreateWithoutUserInput>
  }

  export type RegisterStartupCreateManyUserInputEnvelope = {
    data: Enumerable<RegisterStartupCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ContactUsCreateWithoutUserInput = {
    name: string
    email: string
    message: string
    phoneNumber: string
  }

  export type ContactUsUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email: string
    message: string
    phoneNumber: string
  }

  export type ContactUsCreateOrConnectWithoutUserInput = {
    where: ContactUsWhereUniqueInput
    create: XOR<ContactUsCreateWithoutUserInput, ContactUsUncheckedCreateWithoutUserInput>
  }

  export type ContactUsCreateManyUserInputEnvelope = {
    data: Enumerable<ContactUsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type JournalEntryCreateWithoutUserInput = {
    id?: string
    entryDate?: Date | string
    description: string
    transactions?: TransactionCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUncheckedCreateWithoutUserInput = {
    id?: string
    entryDate?: Date | string
    description: string
    transactions?: TransactionUncheckedCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryCreateOrConnectWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryCreateManyUserInputEnvelope = {
    data: Enumerable<JournalEntryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LedgerCreateWithoutUserInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutLedgerInput
    party?: PartyCreateNestedOneWithoutLedgersInput
  }

  export type LedgerUncheckedCreateWithoutUserInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    partyId?: string | null
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutLedgerInput
  }

  export type LedgerCreateOrConnectWithoutUserInput = {
    where: LedgerWhereUniqueInput
    create: XOR<LedgerCreateWithoutUserInput, LedgerUncheckedCreateWithoutUserInput>
  }

  export type LedgerCreateManyUserInputEnvelope = {
    data: Enumerable<LedgerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    ledger: LedgerCreateNestedOneWithoutTransactionsInput
    journalEntry: JournalEntryCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    ledgerId: string
    journalEntryId: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: Enumerable<TransactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientCreateNestedManyWithoutAgentInput
    loans?: LoanApplicationCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientUncheckedCreateNestedManyWithoutAgentInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutUserInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: string
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateManyUserInputEnvelope = {
    data: Enumerable<ClientCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type Gstr1_4ACreateWithoutUserInput = {
    LegalName: string
    GSTN: string
    pos: string
    invoice_No: string
    invoice_date: string
    invoice_value: string
    rate: string
    nature: string
    source: string
    cgst: string
    igst: string
    sgst: string
    supply_type: string
    fy: string
    period: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Gstr1_4AUncheckedCreateWithoutUserInput = {
    id?: number
    LegalName: string
    GSTN: string
    pos: string
    invoice_No: string
    invoice_date: string
    invoice_value: string
    rate: string
    nature: string
    source: string
    cgst: string
    igst: string
    sgst: string
    supply_type: string
    fy: string
    period: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Gstr1_4ACreateOrConnectWithoutUserInput = {
    where: Gstr1_4AWhereUniqueInput
    create: XOR<Gstr1_4ACreateWithoutUserInput, Gstr1_4AUncheckedCreateWithoutUserInput>
  }

  export type Gstr1_4ACreateManyUserInputEnvelope = {
    data: Enumerable<Gstr1_4ACreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type Gstr1_5ACreateWithoutUserInput = {
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
    gstr1_5A_items?: Gstr1_5A_itemCreateNestedManyWithoutGstr1_5AInput
  }

  export type Gstr1_5AUncheckedCreateWithoutUserInput = {
    id?: number
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
    gstr1_5A_items?: Gstr1_5A_itemUncheckedCreateNestedManyWithoutGstr1_5AInput
  }

  export type Gstr1_5ACreateOrConnectWithoutUserInput = {
    where: Gstr1_5AWhereUniqueInput
    create: XOR<Gstr1_5ACreateWithoutUserInput, Gstr1_5AUncheckedCreateWithoutUserInput>
  }

  export type Gstr1_5ACreateManyUserInputEnvelope = {
    data: Enumerable<Gstr1_5ACreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OtpUpsertWithWhereUniqueWithoutUserInput = {
    where: OtpWhereUniqueInput
    update: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type OtpUpdateWithWhereUniqueWithoutUserInput = {
    where: OtpWhereUniqueInput
    data: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
  }

  export type OtpUpdateManyWithWhereWithoutUserInput = {
    where: OtpScalarWhereInput
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyWithoutOtpsInput>
  }

  export type OtpScalarWhereInput = {
    AND?: Enumerable<OtpScalarWhereInput>
    OR?: Enumerable<OtpScalarWhereInput>
    NOT?: Enumerable<OtpScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    otp?: StringFilter | string
    userId?: IntFilter | number
    used?: BoolFilter | boolean
  }

  export type BusinessProfileUpsertWithoutUserInput = {
    update: XOR<BusinessProfileUpdateWithoutUserInput, BusinessProfileUncheckedUpdateWithoutUserInput>
    create: XOR<BusinessProfileCreateWithoutUserInput, BusinessProfileUncheckedCreateWithoutUserInput>
  }

  export type BusinessProfileUpdateWithoutUserInput = {
    businessName?: StringFieldUpdateOperationsInput | string
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAddressVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isBusinessNameVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isGstinVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPanVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isStateVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BusinessProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessName?: StringFieldUpdateOperationsInput | string
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAddressVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isBusinessNameVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isGstinVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPanVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isStateVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: Enumerable<InvoiceScalarWhereInput>
    OR?: Enumerable<InvoiceScalarWhereInput>
    NOT?: Enumerable<InvoiceScalarWhereInput>
    id?: StringFilter | string
    invoiceNumber?: StringNullableFilter | string | null
    type?: EnumInvoiceTypeFilter | InvoiceType
    totalAmount?: FloatFilter | number
    totalGst?: FloatNullableFilter | number | null
    stateOfSupply?: StringFilter | string
    cgst?: FloatNullableFilter | number | null
    sgst?: FloatNullableFilter | number | null
    igst?: FloatNullableFilter | number | null
    utgst?: FloatNullableFilter | number | null
    details?: StringNullableFilter | string | null
    extraDetails?: StringNullableFilter | string | null
    modeOfPayment?: EnumModeOfPaymentFilter | ModeOfPayment
    credit?: BoolFilter | boolean
    userId?: IntFilter | number
    partyId?: StringFilter | string
    gstNumber?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: EnumInvoiceStatusFilter | InvoiceStatus
  }

  export type CategoryUpsertWithWhereUniqueWithoutUserInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutUserInput, CategoryUncheckedUpdateWithoutUserInput>
    create: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutUserInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutUserInput, CategoryUncheckedUpdateWithoutUserInput>
  }

  export type CategoryUpdateManyWithWhereWithoutUserInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: Enumerable<CategoryScalarWhereInput>
    OR?: Enumerable<CategoryScalarWhereInput>
    NOT?: Enumerable<CategoryScalarWhereInput>
    id?: StringFilter | string
    categoryName?: StringFilter | string
    userId?: IntFilter | number
  }

  export type ItemUpsertWithWhereUniqueWithoutUserInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutUserInput, ItemUncheckedUpdateWithoutUserInput>
    create: XOR<ItemCreateWithoutUserInput, ItemUncheckedCreateWithoutUserInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutUserInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutUserInput, ItemUncheckedUpdateWithoutUserInput>
  }

  export type ItemUpdateManyWithWhereWithoutUserInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type ItemScalarWhereInput = {
    AND?: Enumerable<ItemScalarWhereInput>
    OR?: Enumerable<ItemScalarWhereInput>
    NOT?: Enumerable<ItemScalarWhereInput>
    id?: StringFilter | string
    itemName?: StringFilter | string
    unit?: EnumItemUnitFilter | ItemUnit
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    closingStock?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    gst?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    hsnCode?: StringNullableFilter | string | null
    categoryId?: StringNullableFilter | string | null
    supplierId?: StringNullableFilter | string | null
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PartyUpsertWithWhereUniqueWithoutUserInput = {
    where: PartyWhereUniqueInput
    update: XOR<PartyUpdateWithoutUserInput, PartyUncheckedUpdateWithoutUserInput>
    create: XOR<PartyCreateWithoutUserInput, PartyUncheckedCreateWithoutUserInput>
  }

  export type PartyUpdateWithWhereUniqueWithoutUserInput = {
    where: PartyWhereUniqueInput
    data: XOR<PartyUpdateWithoutUserInput, PartyUncheckedUpdateWithoutUserInput>
  }

  export type PartyUpdateManyWithWhereWithoutUserInput = {
    where: PartyScalarWhereInput
    data: XOR<PartyUpdateManyMutationInput, PartyUncheckedUpdateManyWithoutPartiesInput>
  }

  export type PartyScalarWhereInput = {
    AND?: Enumerable<PartyScalarWhereInput>
    OR?: Enumerable<PartyScalarWhereInput>
    NOT?: Enumerable<PartyScalarWhereInput>
    id?: StringFilter | string
    partyName?: StringFilter | string
    type?: EnumPartyTypeFilter | PartyType
    gstin?: StringNullableFilter | string | null
    pan?: StringNullableFilter | string | null
    tan?: StringNullableFilter | string | null
    upi?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    bankName?: StringNullableFilter | string | null
    bankAccountNumber?: StringNullableFilter | string | null
    bankIfsc?: StringNullableFilter | string | null
    bankBranch?: StringNullableFilter | string | null
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: Enumerable<PaymentScalarWhereInput>
    OR?: Enumerable<PaymentScalarWhereInput>
    NOT?: Enumerable<PaymentScalarWhereInput>
    id?: StringFilter | string
    razorpay_order_id?: StringFilter | string
    razorpay_payment_id?: StringFilter | string
    status?: EnumPaymentStatusFilter | PaymentStatus
    userId?: IntFilter | number
    orderId?: IntFilter | number
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: IntFilter | number
    services?: JsonFilter
    status?: EnumOrderStatusFilter | OrderStatus
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    gst?: DecimalFilter | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFilter | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFilter | string
    userId?: IntFilter | number
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostScalarWhereInput = {
    AND?: Enumerable<PostScalarWhereInput>
    OR?: Enumerable<PostScalarWhereInput>
    NOT?: Enumerable<PostScalarWhereInput>
    id?: StringFilter | string
    userId?: IntFilter | number
    title?: StringFilter | string
    contentheading?: StringFilter | string
    contentdiscription?: StringFilter | string
    category?: StringFilter | string
    imageUrl?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    accountName?: StringFilter | string
    totalDebit?: DecimalFilter | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFilter | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter | Date | string
    userId?: IntFilter | number
  }

  export type BankDetailsUpsertWithWhereUniqueWithoutUserInput = {
    where: BankDetailsWhereUniqueInput
    update: XOR<BankDetailsUpdateWithoutUserInput, BankDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<BankDetailsCreateWithoutUserInput, BankDetailsUncheckedCreateWithoutUserInput>
  }

  export type BankDetailsUpdateWithWhereUniqueWithoutUserInput = {
    where: BankDetailsWhereUniqueInput
    data: XOR<BankDetailsUpdateWithoutUserInput, BankDetailsUncheckedUpdateWithoutUserInput>
  }

  export type BankDetailsUpdateManyWithWhereWithoutUserInput = {
    where: BankDetailsScalarWhereInput
    data: XOR<BankDetailsUpdateManyMutationInput, BankDetailsUncheckedUpdateManyWithoutBankAccountsInput>
  }

  export type BankDetailsScalarWhereInput = {
    AND?: Enumerable<BankDetailsScalarWhereInput>
    OR?: Enumerable<BankDetailsScalarWhereInput>
    NOT?: Enumerable<BankDetailsScalarWhereInput>
    id?: StringFilter | string
    accountHolderName?: StringFilter | string
    bankName?: StringFilter | string
    bankAccountNo?: StringFilter | string
    bankIfsc?: StringFilter | string
    bankBranch?: StringFilter | string
    bankAccountType?: EnumBankAccountTypeFilter | BankAccountType
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutUserInput, LoanApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<LoanApplicationCreateWithoutUserInput, LoanApplicationUncheckedCreateWithoutUserInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutUserInput, LoanApplicationUncheckedUpdateWithoutUserInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutUserInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutLoansInput>
  }

  export type LoanApplicationScalarWhereInput = {
    AND?: Enumerable<LoanApplicationScalarWhereInput>
    OR?: Enumerable<LoanApplicationScalarWhereInput>
    NOT?: Enumerable<LoanApplicationScalarWhereInput>
    id?: StringFilter | string
    loanId?: StringFilter | string
    loanAmount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFilter | LoanStatus
    applicantName?: StringFilter | string
    applicantAge?: IntFilter | number
    loanType?: EnumLoanTypeFilter | LoanType
    applicantGender?: EnumUserGenderFilter | UserGender
    nationality?: EnumNationalityFilter | Nationality
    description?: StringFilter | string
    salaried?: BoolFilter | boolean
    bankAccountId?: StringFilter | string
    phone?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    permanentAddress?: StringFilter | string
    userId?: IntFilter | number
    agentId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UploadedDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: UploadedDocumentWhereUniqueInput
    update: XOR<UploadedDocumentUpdateWithoutUserInput, UploadedDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<UploadedDocumentCreateWithoutUserInput, UploadedDocumentUncheckedCreateWithoutUserInput>
  }

  export type UploadedDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: UploadedDocumentWhereUniqueInput
    data: XOR<UploadedDocumentUpdateWithoutUserInput, UploadedDocumentUncheckedUpdateWithoutUserInput>
  }

  export type UploadedDocumentUpdateManyWithWhereWithoutUserInput = {
    where: UploadedDocumentScalarWhereInput
    data: XOR<UploadedDocumentUpdateManyMutationInput, UploadedDocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type UploadedDocumentScalarWhereInput = {
    AND?: Enumerable<UploadedDocumentScalarWhereInput>
    OR?: Enumerable<UploadedDocumentScalarWhereInput>
    NOT?: Enumerable<UploadedDocumentScalarWhereInput>
    id?: StringFilter | string
    userId?: IntFilter | number
    fileName?: StringFilter | string
    applicationId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InsuranceUpsertWithWhereUniqueWithoutUserInput = {
    where: InsuranceWhereUniqueInput
    update: XOR<InsuranceUpdateWithoutUserInput, InsuranceUncheckedUpdateWithoutUserInput>
    create: XOR<InsuranceCreateWithoutUserInput, InsuranceUncheckedCreateWithoutUserInput>
  }

  export type InsuranceUpdateWithWhereUniqueWithoutUserInput = {
    where: InsuranceWhereUniqueInput
    data: XOR<InsuranceUpdateWithoutUserInput, InsuranceUncheckedUpdateWithoutUserInput>
  }

  export type InsuranceUpdateManyWithWhereWithoutUserInput = {
    where: InsuranceScalarWhereInput
    data: XOR<InsuranceUpdateManyMutationInput, InsuranceUncheckedUpdateManyWithoutInsurancesInput>
  }

  export type InsuranceScalarWhereInput = {
    AND?: Enumerable<InsuranceScalarWhereInput>
    OR?: Enumerable<InsuranceScalarWhereInput>
    NOT?: Enumerable<InsuranceScalarWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    name?: StringFilter | string
    mobile?: StringFilter | string
    email?: StringFilter | string
    address?: StringFilter | string
    dob?: DateTimeFilter | Date | string
    maritalStatus?: StringFilter | string
    gender?: EnumUserGenderFilter | UserGender
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RegisterStartupUpsertWithWhereUniqueWithoutUserInput = {
    where: RegisterStartupWhereUniqueInput
    update: XOR<RegisterStartupUpdateWithoutUserInput, RegisterStartupUncheckedUpdateWithoutUserInput>
    create: XOR<RegisterStartupCreateWithoutUserInput, RegisterStartupUncheckedCreateWithoutUserInput>
  }

  export type RegisterStartupUpdateWithWhereUniqueWithoutUserInput = {
    where: RegisterStartupWhereUniqueInput
    data: XOR<RegisterStartupUpdateWithoutUserInput, RegisterStartupUncheckedUpdateWithoutUserInput>
  }

  export type RegisterStartupUpdateManyWithWhereWithoutUserInput = {
    where: RegisterStartupScalarWhereInput
    data: XOR<RegisterStartupUpdateManyMutationInput, RegisterStartupUncheckedUpdateManyWithoutRegisterStartupInput>
  }

  export type RegisterStartupScalarWhereInput = {
    AND?: Enumerable<RegisterStartupScalarWhereInput>
    OR?: Enumerable<RegisterStartupScalarWhereInput>
    NOT?: Enumerable<RegisterStartupScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    image?: StringFilter | string
    userId?: IntFilter | number
    categories?: EnumStartupCategoryFilter | StartupCategory
  }

  export type ContactUsUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactUsWhereUniqueInput
    update: XOR<ContactUsUpdateWithoutUserInput, ContactUsUncheckedUpdateWithoutUserInput>
    create: XOR<ContactUsCreateWithoutUserInput, ContactUsUncheckedCreateWithoutUserInput>
  }

  export type ContactUsUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactUsWhereUniqueInput
    data: XOR<ContactUsUpdateWithoutUserInput, ContactUsUncheckedUpdateWithoutUserInput>
  }

  export type ContactUsUpdateManyWithWhereWithoutUserInput = {
    where: ContactUsScalarWhereInput
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyWithoutContactUsInput>
  }

  export type ContactUsScalarWhereInput = {
    AND?: Enumerable<ContactUsScalarWhereInput>
    OR?: Enumerable<ContactUsScalarWhereInput>
    NOT?: Enumerable<ContactUsScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    message?: StringFilter | string
    phoneNumber?: StringFilter | string
    userId?: IntFilter | number
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutUserInput, JournalEntryUncheckedUpdateWithoutUserInput>
    create: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutUserInput, JournalEntryUncheckedUpdateWithoutUserInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutUserInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutJournalEntriesInput>
  }

  export type JournalEntryScalarWhereInput = {
    AND?: Enumerable<JournalEntryScalarWhereInput>
    OR?: Enumerable<JournalEntryScalarWhereInput>
    NOT?: Enumerable<JournalEntryScalarWhereInput>
    id?: StringFilter | string
    entryDate?: DateTimeFilter | Date | string
    description?: StringFilter | string
    userId?: IntFilter | number
  }

  export type LedgerUpsertWithWhereUniqueWithoutUserInput = {
    where: LedgerWhereUniqueInput
    update: XOR<LedgerUpdateWithoutUserInput, LedgerUncheckedUpdateWithoutUserInput>
    create: XOR<LedgerCreateWithoutUserInput, LedgerUncheckedCreateWithoutUserInput>
  }

  export type LedgerUpdateWithWhereUniqueWithoutUserInput = {
    where: LedgerWhereUniqueInput
    data: XOR<LedgerUpdateWithoutUserInput, LedgerUncheckedUpdateWithoutUserInput>
  }

  export type LedgerUpdateManyWithWhereWithoutUserInput = {
    where: LedgerScalarWhereInput
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyWithoutLegdersInput>
  }

  export type LedgerScalarWhereInput = {
    AND?: Enumerable<LedgerScalarWhereInput>
    OR?: Enumerable<LedgerScalarWhereInput>
    NOT?: Enumerable<LedgerScalarWhereInput>
    id?: StringFilter | string
    ledgerName?: StringFilter | string
    openingBalance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    userId?: IntFilter | number
    partyId?: StringNullableFilter | string | null
    year?: IntFilter | number
    month?: IntFilter | number
    ledgerType?: EnumLedgerTypeFilter | LedgerType
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: Enumerable<TransactionScalarWhereInput>
    OR?: Enumerable<TransactionScalarWhereInput>
    NOT?: Enumerable<TransactionScalarWhereInput>
    id?: StringFilter | string
    ledgerId?: StringFilter | string
    journalEntryId?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFilter | TransactionType
    userId?: IntFilter | number
  }

  export type AgentUpsertWithoutUserInput = {
    update: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type AgentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUpdateManyWithoutAgentNestedInput
    loans?: LoanApplicationUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUncheckedUpdateManyWithoutAgentNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ClientUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateManyWithWhereWithoutUserInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutClientAccountsInput>
  }

  export type ClientScalarWhereInput = {
    AND?: Enumerable<ClientScalarWhereInput>
    OR?: Enumerable<ClientScalarWhereInput>
    NOT?: Enumerable<ClientScalarWhereInput>
    id?: StringFilter | string
    userId?: IntFilter | number
    agentId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type Gstr1_4AUpsertWithWhereUniqueWithoutUserInput = {
    where: Gstr1_4AWhereUniqueInput
    update: XOR<Gstr1_4AUpdateWithoutUserInput, Gstr1_4AUncheckedUpdateWithoutUserInput>
    create: XOR<Gstr1_4ACreateWithoutUserInput, Gstr1_4AUncheckedCreateWithoutUserInput>
  }

  export type Gstr1_4AUpdateWithWhereUniqueWithoutUserInput = {
    where: Gstr1_4AWhereUniqueInput
    data: XOR<Gstr1_4AUpdateWithoutUserInput, Gstr1_4AUncheckedUpdateWithoutUserInput>
  }

  export type Gstr1_4AUpdateManyWithWhereWithoutUserInput = {
    where: Gstr1_4AScalarWhereInput
    data: XOR<Gstr1_4AUpdateManyMutationInput, Gstr1_4AUncheckedUpdateManyWithoutGstr1Input>
  }

  export type Gstr1_4AScalarWhereInput = {
    AND?: Enumerable<Gstr1_4AScalarWhereInput>
    OR?: Enumerable<Gstr1_4AScalarWhereInput>
    NOT?: Enumerable<Gstr1_4AScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    LegalName?: StringFilter | string
    GSTN?: StringFilter | string
    pos?: StringFilter | string
    invoice_No?: StringFilter | string
    invoice_date?: StringFilter | string
    invoice_value?: StringFilter | string
    rate?: StringFilter | string
    nature?: StringFilter | string
    source?: StringFilter | string
    cgst?: StringFilter | string
    igst?: StringFilter | string
    sgst?: StringFilter | string
    supply_type?: StringFilter | string
    fy?: StringFilter | string
    period?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type Gstr1_5AUpsertWithWhereUniqueWithoutUserInput = {
    where: Gstr1_5AWhereUniqueInput
    update: XOR<Gstr1_5AUpdateWithoutUserInput, Gstr1_5AUncheckedUpdateWithoutUserInput>
    create: XOR<Gstr1_5ACreateWithoutUserInput, Gstr1_5AUncheckedCreateWithoutUserInput>
  }

  export type Gstr1_5AUpdateWithWhereUniqueWithoutUserInput = {
    where: Gstr1_5AWhereUniqueInput
    data: XOR<Gstr1_5AUpdateWithoutUserInput, Gstr1_5AUncheckedUpdateWithoutUserInput>
  }

  export type Gstr1_5AUpdateManyWithWhereWithoutUserInput = {
    where: Gstr1_5AScalarWhereInput
    data: XOR<Gstr1_5AUpdateManyMutationInput, Gstr1_5AUncheckedUpdateManyWithoutGstr1_5AInput>
  }

  export type Gstr1_5AScalarWhereInput = {
    AND?: Enumerable<Gstr1_5AScalarWhereInput>
    OR?: Enumerable<Gstr1_5AScalarWhereInput>
    NOT?: Enumerable<Gstr1_5AScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    pos?: StringFilter | string
    invoice_No?: StringFilter | string
    supply_type?: StringFilter | string
    invoice_date?: StringFilter | string
    invoice_value?: StringFilter | string
    total_invoice_value?: StringFilter | string
  }

  export type UserCreateWithoutOtpsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
  }

  export type UserUpsertWithoutOtpsInput = {
    update: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
  }

  export type UserUpdateWithoutOtpsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBusinessProfileInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBusinessProfileInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBusinessProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBusinessProfileInput, UserUncheckedCreateWithoutBusinessProfileInput>
  }

  export type UserUpsertWithoutBusinessProfileInput = {
    update: XOR<UserUpdateWithoutBusinessProfileInput, UserUncheckedUpdateWithoutBusinessProfileInput>
    create: XOR<UserCreateWithoutBusinessProfileInput, UserUncheckedCreateWithoutBusinessProfileInput>
  }

  export type UserUpdateWithoutBusinessProfileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBusinessProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLegdersInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLegdersInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLegdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLegdersInput, UserUncheckedCreateWithoutLegdersInput>
  }

  export type TransactionCreateWithoutLedgerInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    journalEntry: JournalEntryCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutLedgerInput = {
    id?: string
    journalEntryId: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    userId: number
  }

  export type TransactionCreateOrConnectWithoutLedgerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutLedgerInput, TransactionUncheckedCreateWithoutLedgerInput>
  }

  export type TransactionCreateManyLedgerInputEnvelope = {
    data: Enumerable<TransactionCreateManyLedgerInput>
    skipDuplicates?: boolean
  }

  export type PartyCreateWithoutLedgersInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPartyInput
    items?: ItemCreateNestedManyWithoutSupplierInput
    user: UserCreateNestedOneWithoutPartiesInput
  }

  export type PartyUncheckedCreateWithoutLedgersInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPartyInput
    items?: ItemUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type PartyCreateOrConnectWithoutLedgersInput = {
    where: PartyWhereUniqueInput
    create: XOR<PartyCreateWithoutLedgersInput, PartyUncheckedCreateWithoutLedgersInput>
  }

  export type UserUpsertWithoutLegdersInput = {
    update: XOR<UserUpdateWithoutLegdersInput, UserUncheckedUpdateWithoutLegdersInput>
    create: XOR<UserCreateWithoutLegdersInput, UserUncheckedCreateWithoutLegdersInput>
  }

  export type UserUpdateWithoutLegdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLegdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutLedgerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutLedgerInput, TransactionUncheckedUpdateWithoutLedgerInput>
    create: XOR<TransactionCreateWithoutLedgerInput, TransactionUncheckedCreateWithoutLedgerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutLedgerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutLedgerInput, TransactionUncheckedUpdateWithoutLedgerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutLedgerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type PartyUpsertWithoutLedgersInput = {
    update: XOR<PartyUpdateWithoutLedgersInput, PartyUncheckedUpdateWithoutLedgersInput>
    create: XOR<PartyCreateWithoutLedgersInput, PartyUncheckedCreateWithoutLedgersInput>
  }

  export type PartyUpdateWithoutLedgersInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPartyNestedInput
    items?: ItemUpdateManyWithoutSupplierNestedInput
    user?: UserUpdateOneRequiredWithoutPartiesNestedInput
  }

  export type PartyUncheckedUpdateWithoutLedgersInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPartyNestedInput
    items?: ItemUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type UserCreateWithoutJournalEntriesInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJournalEntriesInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJournalEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
  }

  export type TransactionCreateWithoutJournalEntryInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    ledger: LedgerCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutJournalEntryInput = {
    id?: string
    ledgerId: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    userId: number
  }

  export type TransactionCreateOrConnectWithoutJournalEntryInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutJournalEntryInput, TransactionUncheckedCreateWithoutJournalEntryInput>
  }

  export type TransactionCreateManyJournalEntryInputEnvelope = {
    data: Enumerable<TransactionCreateManyJournalEntryInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutJournalEntriesInput = {
    update: XOR<UserUpdateWithoutJournalEntriesInput, UserUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
  }

  export type UserUpdateWithoutJournalEntriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJournalEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutJournalEntryInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutJournalEntryInput, TransactionUncheckedUpdateWithoutJournalEntryInput>
    create: XOR<TransactionCreateWithoutJournalEntryInput, TransactionUncheckedCreateWithoutJournalEntryInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutJournalEntryInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutJournalEntryInput, TransactionUncheckedUpdateWithoutJournalEntryInput>
  }

  export type TransactionUpdateManyWithWhereWithoutJournalEntryInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type LedgerCreateWithoutTransactionsInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLegdersInput
    party?: PartyCreateNestedOneWithoutLedgersInput
  }

  export type LedgerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    userId: number
    partyId?: string | null
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerCreateOrConnectWithoutTransactionsInput = {
    where: LedgerWhereUniqueInput
    create: XOR<LedgerCreateWithoutTransactionsInput, LedgerUncheckedCreateWithoutTransactionsInput>
  }

  export type JournalEntryCreateWithoutTransactionsInput = {
    id?: string
    entryDate?: Date | string
    description: string
    user: UserCreateNestedOneWithoutJournalEntriesInput
  }

  export type JournalEntryUncheckedCreateWithoutTransactionsInput = {
    id?: string
    entryDate?: Date | string
    description: string
    userId: number
  }

  export type JournalEntryCreateOrConnectWithoutTransactionsInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutTransactionsInput, JournalEntryUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type LedgerUpsertWithoutTransactionsInput = {
    update: XOR<LedgerUpdateWithoutTransactionsInput, LedgerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LedgerCreateWithoutTransactionsInput, LedgerUncheckedCreateWithoutTransactionsInput>
  }

  export type LedgerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLegdersNestedInput
    party?: PartyUpdateOneWithoutLedgersNestedInput
  }

  export type LedgerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: IntFieldUpdateOperationsInput | number
    partyId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUpsertWithoutTransactionsInput = {
    update: XOR<JournalEntryUpdateWithoutTransactionsInput, JournalEntryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<JournalEntryCreateWithoutTransactionsInput, JournalEntryUncheckedCreateWithoutTransactionsInput>
  }

  export type JournalEntryUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutJournalEntriesNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceCreateWithoutPartyInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    user: UserCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    accounts?: AccountCreateNestedManyWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPartyInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    userId: number
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoiceCreateOrConnectWithoutPartyInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPartyInput, InvoiceUncheckedCreateWithoutPartyInput>
  }

  export type InvoiceCreateManyPartyInputEnvelope = {
    data: Enumerable<InvoiceCreateManyPartyInput>
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutSupplierInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutItemsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutItemInput
    user: UserCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutSupplierInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    categoryId?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSupplierInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSupplierInput, ItemUncheckedCreateWithoutSupplierInput>
  }

  export type ItemCreateManySupplierInputEnvelope = {
    data: Enumerable<ItemCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPartiesInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPartiesInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPartiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPartiesInput, UserUncheckedCreateWithoutPartiesInput>
  }

  export type LedgerCreateWithoutPartyInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLegdersInput
    transactions?: TransactionCreateNestedManyWithoutLedgerInput
  }

  export type LedgerUncheckedCreateWithoutPartyInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    userId: number
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutLedgerInput
  }

  export type LedgerCreateOrConnectWithoutPartyInput = {
    where: LedgerWhereUniqueInput
    create: XOR<LedgerCreateWithoutPartyInput, LedgerUncheckedCreateWithoutPartyInput>
  }

  export type LedgerCreateManyPartyInputEnvelope = {
    data: Enumerable<LedgerCreateManyPartyInput>
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPartyInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPartyInput, InvoiceUncheckedUpdateWithoutPartyInput>
    create: XOR<InvoiceCreateWithoutPartyInput, InvoiceUncheckedCreateWithoutPartyInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPartyInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPartyInput, InvoiceUncheckedUpdateWithoutPartyInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPartyInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type ItemUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutSupplierInput, ItemUncheckedUpdateWithoutSupplierInput>
    create: XOR<ItemCreateWithoutSupplierInput, ItemUncheckedCreateWithoutSupplierInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutSupplierInput, ItemUncheckedUpdateWithoutSupplierInput>
  }

  export type ItemUpdateManyWithWhereWithoutSupplierInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type UserUpsertWithoutPartiesInput = {
    update: XOR<UserUpdateWithoutPartiesInput, UserUncheckedUpdateWithoutPartiesInput>
    create: XOR<UserCreateWithoutPartiesInput, UserUncheckedCreateWithoutPartiesInput>
  }

  export type UserUpdateWithoutPartiesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPartiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LedgerUpsertWithWhereUniqueWithoutPartyInput = {
    where: LedgerWhereUniqueInput
    update: XOR<LedgerUpdateWithoutPartyInput, LedgerUncheckedUpdateWithoutPartyInput>
    create: XOR<LedgerCreateWithoutPartyInput, LedgerUncheckedCreateWithoutPartyInput>
  }

  export type LedgerUpdateWithWhereUniqueWithoutPartyInput = {
    where: LedgerWhereUniqueInput
    data: XOR<LedgerUpdateWithoutPartyInput, LedgerUncheckedUpdateWithoutPartyInput>
  }

  export type LedgerUpdateManyWithWhereWithoutPartyInput = {
    where: LedgerScalarWhereInput
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyWithoutLedgersInput>
  }

  export type UserCreateWithoutCategoriesInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCategoriesInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
  }

  export type ItemCreateWithoutCategoryInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: PartyCreateNestedOneWithoutItemsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutItemInput
    user: UserCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutCategoryInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    supplierId?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCreateManyCategoryInputEnvelope = {
    data: Enumerable<ItemCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCategoriesInput = {
    update: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
  }

  export type UserUpdateWithoutCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type CategoryCreateWithoutItemsInput = {
    id?: string
    categoryName: string
    user: UserCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutItemsInput = {
    id?: string
    categoryName: string
    userId: number
  }

  export type CategoryCreateOrConnectWithoutItemsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutItemsInput, CategoryUncheckedCreateWithoutItemsInput>
  }

  export type PartyCreateWithoutItemsInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPartyInput
    user: UserCreateNestedOneWithoutPartiesInput
    ledgers?: LedgerCreateNestedManyWithoutPartyInput
  }

  export type PartyUncheckedCreateWithoutItemsInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPartyInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutPartyInput
  }

  export type PartyCreateOrConnectWithoutItemsInput = {
    where: PartyWhereUniqueInput
    create: XOR<PartyCreateWithoutItemsInput, PartyUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceItemCreateWithoutItemInput = {
    id?: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutItemInput = {
    id?: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    invoiceId: string
  }

  export type InvoiceItemCreateOrConnectWithoutItemInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutItemInput, InvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type InvoiceItemCreateManyItemInputEnvelope = {
    data: Enumerable<InvoiceItemCreateManyItemInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutItemsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutItemsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutItemsInput, UserUncheckedCreateWithoutItemsInput>
  }

  export type CategoryUpsertWithoutItemsInput = {
    update: XOR<CategoryUpdateWithoutItemsInput, CategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<CategoryCreateWithoutItemsInput, CategoryUncheckedCreateWithoutItemsInput>
  }

  export type CategoryUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PartyUpsertWithoutItemsInput = {
    update: XOR<PartyUpdateWithoutItemsInput, PartyUncheckedUpdateWithoutItemsInput>
    create: XOR<PartyCreateWithoutItemsInput, PartyUncheckedCreateWithoutItemsInput>
  }

  export type PartyUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPartyNestedInput
    user?: UserUpdateOneRequiredWithoutPartiesNestedInput
    ledgers?: LedgerUpdateManyWithoutPartyNestedInput
  }

  export type PartyUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPartyNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutPartyNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutItemInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutItemInput, InvoiceItemUncheckedUpdateWithoutItemInput>
    create: XOR<InvoiceItemCreateWithoutItemInput, InvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutItemInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutItemInput, InvoiceItemUncheckedUpdateWithoutItemInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutItemInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceItemsInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: Enumerable<InvoiceItemScalarWhereInput>
    OR?: Enumerable<InvoiceItemScalarWhereInput>
    NOT?: Enumerable<InvoiceItemScalarWhereInput>
    id?: StringFilter | string
    itemId?: StringFilter | string
    quantity?: IntFilter | number
    discount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFilter | string
  }

  export type UserUpsertWithoutItemsInput = {
    update: XOR<UserUpdateWithoutItemsInput, UserUncheckedUpdateWithoutItemsInput>
    create: XOR<UserCreateWithoutItemsInput, UserUncheckedCreateWithoutItemsInput>
  }

  export type UserUpdateWithoutItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInvoicesInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type PartyCreateWithoutInvoicesInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemCreateNestedManyWithoutSupplierInput
    user: UserCreateNestedOneWithoutPartiesInput
    ledgers?: LedgerCreateNestedManyWithoutPartyInput
  }

  export type PartyUncheckedCreateWithoutInvoicesInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemUncheckedCreateNestedManyWithoutSupplierInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutPartyInput
  }

  export type PartyCreateOrConnectWithoutInvoicesInput = {
    where: PartyWhereUniqueInput
    create: XOR<PartyCreateWithoutInvoicesInput, PartyUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    itemId: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: Enumerable<InvoiceItemCreateManyInvoiceInput>
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutInvoicesInput = {
    id?: string
    accountName: string
    totalDebit?: Decimal | DecimalJsLike | number | string
    totalCredit?: Decimal | DecimalJsLike | number | string
    debitBalance?: Decimal | DecimalJsLike | number | string
    creditBalance?: Decimal | DecimalJsLike | number | string
    date?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutInvoicesInput = {
    id?: string
    accountName: string
    totalDebit?: Decimal | DecimalJsLike | number | string
    totalCredit?: Decimal | DecimalJsLike | number | string
    debitBalance?: Decimal | DecimalJsLike | number | string
    creditBalance?: Decimal | DecimalJsLike | number | string
    date?: Date | string
    userId: number
  }

  export type AccountCreateOrConnectWithoutInvoicesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PartyUpsertWithoutInvoicesInput = {
    update: XOR<PartyUpdateWithoutInvoicesInput, PartyUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PartyCreateWithoutInvoicesInput, PartyUncheckedCreateWithoutInvoicesInput>
  }

  export type PartyUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUpdateManyWithoutSupplierNestedInput
    user?: UserUpdateOneRequiredWithoutPartiesNestedInput
    ledgers?: LedgerUpdateManyWithoutPartyNestedInput
  }

  export type PartyUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUncheckedUpdateManyWithoutSupplierNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutPartyNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceItemsInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutInvoicesInput, AccountUncheckedUpdateWithoutInvoicesInput>
    create: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutInvoicesInput, AccountUncheckedUpdateWithoutInvoicesInput>
  }

  export type AccountUpdateManyWithWhereWithoutInvoicesInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type ItemCreateWithoutInvoiceItemsInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutItemsInput
    supplier?: PartyCreateNestedOneWithoutItemsInput
    user: UserCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    categoryId?: string | null
    supplierId?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutInvoiceItemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInvoiceItemsInput, ItemUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceCreateWithoutInvoiceItemsInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    user: UserCreateNestedOneWithoutInvoicesInput
    party: PartyCreateNestedOneWithoutInvoicesInput
    accounts?: AccountCreateNestedManyWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    userId: number
    partyId: string
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    accounts?: AccountUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type ItemUpsertWithoutInvoiceItemsInput = {
    update: XOR<ItemUpdateWithoutInvoiceItemsInput, ItemUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ItemCreateWithoutInvoiceItemsInput, ItemUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type ItemUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutItemsNestedInput
    supplier?: PartyUpdateOneWithoutItemsNestedInput
    user?: UserUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    party?: PartyUpdateOneRequiredWithoutInvoicesNestedInput
    accounts?: AccountUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    partyId?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    accounts?: AccountUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type InvoiceCreateWithoutAccountsInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    user: UserCreateNestedOneWithoutInvoicesInput
    party: PartyCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutAccountsInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    userId: number
    partyId: string
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutAccountsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAccountsInput, InvoiceUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutAccountsInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutAccountsInput, InvoiceUncheckedUpdateWithoutAccountsInput>
    create: XOR<InvoiceCreateWithoutAccountsInput, InvoiceUncheckedCreateWithoutAccountsInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutAccountsInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutAccountsInput, InvoiceUncheckedUpdateWithoutAccountsInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutAccountsInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type UserCreateWithoutDocumentsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type LoanDocumentCreateWithoutDocumentsInput = {
    id?: string
    name: string
    shortName: string
    mandatory?: boolean
    type: DocumentType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loans?: LoanCreateNestedManyWithoutDocumentsInput
  }

  export type LoanDocumentUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    shortName: string
    mandatory?: boolean
    type: DocumentType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loans?: LoanUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type LoanDocumentCreateOrConnectWithoutDocumentsInput = {
    where: LoanDocumentWhereUniqueInput
    create: XOR<LoanDocumentCreateWithoutDocumentsInput, LoanDocumentUncheckedCreateWithoutDocumentsInput>
  }

  export type LoanApplicationCreateWithoutDocumentsInput = {
    id?: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutApplicationsInput
    bankDetails: BankDetailsCreateNestedOneWithoutLoansInput
    user: UserCreateNestedOneWithoutLoansInput
    agent?: AgentCreateNestedOneWithoutLoansInput
  }

  export type LoanApplicationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationCreateOrConnectWithoutDocumentsInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutDocumentsInput, LoanApplicationUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LoanDocumentUpsertWithWhereUniqueWithoutDocumentsInput = {
    where: LoanDocumentWhereUniqueInput
    update: XOR<LoanDocumentUpdateWithoutDocumentsInput, LoanDocumentUncheckedUpdateWithoutDocumentsInput>
    create: XOR<LoanDocumentCreateWithoutDocumentsInput, LoanDocumentUncheckedCreateWithoutDocumentsInput>
  }

  export type LoanDocumentUpdateWithWhereUniqueWithoutDocumentsInput = {
    where: LoanDocumentWhereUniqueInput
    data: XOR<LoanDocumentUpdateWithoutDocumentsInput, LoanDocumentUncheckedUpdateWithoutDocumentsInput>
  }

  export type LoanDocumentUpdateManyWithWhereWithoutDocumentsInput = {
    where: LoanDocumentScalarWhereInput
    data: XOR<LoanDocumentUpdateManyMutationInput, LoanDocumentUncheckedUpdateManyWithoutDocsInput>
  }

  export type LoanDocumentScalarWhereInput = {
    AND?: Enumerable<LoanDocumentScalarWhereInput>
    OR?: Enumerable<LoanDocumentScalarWhereInput>
    NOT?: Enumerable<LoanDocumentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    shortName?: StringFilter | string
    mandatory?: BoolFilter | boolean
    type?: EnumDocumentTypeFilter | DocumentType
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LoanApplicationUpsertWithoutDocumentsInput = {
    update: XOR<LoanApplicationUpdateWithoutDocumentsInput, LoanApplicationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<LoanApplicationCreateWithoutDocumentsInput, LoanApplicationUncheckedCreateWithoutDocumentsInput>
  }

  export type LoanApplicationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutApplicationsNestedInput
    bankDetails?: BankDetailsUpdateOneRequiredWithoutLoansNestedInput
    user?: UserUpdateOneRequiredWithoutLoansNestedInput
    agent?: AgentUpdateOneWithoutLoansNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    bankAccountId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedDocumentCreateWithoutDocsInput = {
    id?: string
    fileName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    application?: LoanApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type UploadedDocumentUncheckedCreateWithoutDocsInput = {
    id?: string
    userId: number
    fileName: string
    applicationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedDocumentCreateOrConnectWithoutDocsInput = {
    where: UploadedDocumentWhereUniqueInput
    create: XOR<UploadedDocumentCreateWithoutDocsInput, UploadedDocumentUncheckedCreateWithoutDocsInput>
  }

  export type LoanCreateWithoutDocumentsInput = {
    id?: string
    type: LoanType
    name: string
    shortName?: string | null
    description?: string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    interest: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: LoanApplicationCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateWithoutDocumentsInput = {
    id?: string
    type: LoanType
    name: string
    shortName?: string | null
    description?: string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    interest: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: LoanApplicationUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanCreateOrConnectWithoutDocumentsInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutDocumentsInput, LoanUncheckedCreateWithoutDocumentsInput>
  }

  export type UploadedDocumentUpsertWithWhereUniqueWithoutDocsInput = {
    where: UploadedDocumentWhereUniqueInput
    update: XOR<UploadedDocumentUpdateWithoutDocsInput, UploadedDocumentUncheckedUpdateWithoutDocsInput>
    create: XOR<UploadedDocumentCreateWithoutDocsInput, UploadedDocumentUncheckedCreateWithoutDocsInput>
  }

  export type UploadedDocumentUpdateWithWhereUniqueWithoutDocsInput = {
    where: UploadedDocumentWhereUniqueInput
    data: XOR<UploadedDocumentUpdateWithoutDocsInput, UploadedDocumentUncheckedUpdateWithoutDocsInput>
  }

  export type UploadedDocumentUpdateManyWithWhereWithoutDocsInput = {
    where: UploadedDocumentScalarWhereInput
    data: XOR<UploadedDocumentUpdateManyMutationInput, UploadedDocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type LoanUpsertWithWhereUniqueWithoutDocumentsInput = {
    where: LoanWhereUniqueInput
    update: XOR<LoanUpdateWithoutDocumentsInput, LoanUncheckedUpdateWithoutDocumentsInput>
    create: XOR<LoanCreateWithoutDocumentsInput, LoanUncheckedCreateWithoutDocumentsInput>
  }

  export type LoanUpdateWithWhereUniqueWithoutDocumentsInput = {
    where: LoanWhereUniqueInput
    data: XOR<LoanUpdateWithoutDocumentsInput, LoanUncheckedUpdateWithoutDocumentsInput>
  }

  export type LoanUpdateManyWithWhereWithoutDocumentsInput = {
    where: LoanScalarWhereInput
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyWithoutLoansInput>
  }

  export type LoanScalarWhereInput = {
    AND?: Enumerable<LoanScalarWhereInput>
    OR?: Enumerable<LoanScalarWhereInput>
    NOT?: Enumerable<LoanScalarWhereInput>
    id?: StringFilter | string
    type?: EnumLoanTypeFilter | LoanType
    name?: StringFilter | string
    shortName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    maxAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    minAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LoanDocumentCreateWithoutLoansInput = {
    id?: string
    name: string
    shortName: string
    mandatory?: boolean
    type: DocumentType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentCreateNestedManyWithoutDocsInput
  }

  export type LoanDocumentUncheckedCreateWithoutLoansInput = {
    id?: string
    name: string
    shortName: string
    mandatory?: boolean
    type: DocumentType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutDocsInput
  }

  export type LoanDocumentCreateOrConnectWithoutLoansInput = {
    where: LoanDocumentWhereUniqueInput
    create: XOR<LoanDocumentCreateWithoutLoansInput, LoanDocumentUncheckedCreateWithoutLoansInput>
  }

  export type LoanApplicationCreateWithoutLoanInput = {
    id?: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentCreateNestedManyWithoutApplicationInput
    bankDetails: BankDetailsCreateNestedOneWithoutLoansInput
    user: UserCreateNestedOneWithoutLoansInput
    agent?: AgentCreateNestedOneWithoutLoansInput
  }

  export type LoanApplicationUncheckedCreateWithoutLoanInput = {
    id?: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type LoanApplicationCreateOrConnectWithoutLoanInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutLoanInput, LoanApplicationUncheckedCreateWithoutLoanInput>
  }

  export type LoanApplicationCreateManyLoanInputEnvelope = {
    data: Enumerable<LoanApplicationCreateManyLoanInput>
    skipDuplicates?: boolean
  }

  export type LoanDocumentUpsertWithWhereUniqueWithoutLoansInput = {
    where: LoanDocumentWhereUniqueInput
    update: XOR<LoanDocumentUpdateWithoutLoansInput, LoanDocumentUncheckedUpdateWithoutLoansInput>
    create: XOR<LoanDocumentCreateWithoutLoansInput, LoanDocumentUncheckedCreateWithoutLoansInput>
  }

  export type LoanDocumentUpdateWithWhereUniqueWithoutLoansInput = {
    where: LoanDocumentWhereUniqueInput
    data: XOR<LoanDocumentUpdateWithoutLoansInput, LoanDocumentUncheckedUpdateWithoutLoansInput>
  }

  export type LoanDocumentUpdateManyWithWhereWithoutLoansInput = {
    where: LoanDocumentScalarWhereInput
    data: XOR<LoanDocumentUpdateManyMutationInput, LoanDocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutLoanInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutLoanInput, LoanApplicationUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanApplicationCreateWithoutLoanInput, LoanApplicationUncheckedCreateWithoutLoanInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutLoanInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutLoanInput, LoanApplicationUncheckedUpdateWithoutLoanInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutLoanInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutApplicationsInput>
  }

  export type LoanCreateWithoutApplicationsInput = {
    id?: string
    type: LoanType
    name: string
    shortName?: string | null
    description?: string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    interest: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: LoanDocumentCreateNestedManyWithoutLoansInput
  }

  export type LoanUncheckedCreateWithoutApplicationsInput = {
    id?: string
    type: LoanType
    name: string
    shortName?: string | null
    description?: string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    interest: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: LoanDocumentUncheckedCreateNestedManyWithoutLoansInput
  }

  export type LoanCreateOrConnectWithoutApplicationsInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutApplicationsInput, LoanUncheckedCreateWithoutApplicationsInput>
  }

  export type UploadedDocumentCreateWithoutApplicationInput = {
    id?: string
    fileName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    docs?: LoanDocumentCreateNestedManyWithoutDocumentsInput
  }

  export type UploadedDocumentUncheckedCreateWithoutApplicationInput = {
    id?: string
    userId: number
    fileName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    docs?: LoanDocumentUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type UploadedDocumentCreateOrConnectWithoutApplicationInput = {
    where: UploadedDocumentWhereUniqueInput
    create: XOR<UploadedDocumentCreateWithoutApplicationInput, UploadedDocumentUncheckedCreateWithoutApplicationInput>
  }

  export type UploadedDocumentCreateManyApplicationInputEnvelope = {
    data: Enumerable<UploadedDocumentCreateManyApplicationInput>
    skipDuplicates?: boolean
  }

  export type BankDetailsCreateWithoutLoansInput = {
    id?: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBankAccountsInput
  }

  export type BankDetailsUncheckedCreateWithoutLoansInput = {
    id?: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailsCreateOrConnectWithoutLoansInput = {
    where: BankDetailsWhereUniqueInput
    create: XOR<BankDetailsCreateWithoutLoansInput, BankDetailsUncheckedCreateWithoutLoansInput>
  }

  export type UserCreateWithoutLoansInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoansInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoansInput, UserUncheckedCreateWithoutLoansInput>
  }

  export type AgentCreateWithoutLoansInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentIdInput
  }

  export type AgentUncheckedCreateWithoutLoansInput = {
    id?: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutLoansInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutLoansInput, AgentUncheckedCreateWithoutLoansInput>
  }

  export type LoanUpsertWithoutApplicationsInput = {
    update: XOR<LoanUpdateWithoutApplicationsInput, LoanUncheckedUpdateWithoutApplicationsInput>
    create: XOR<LoanCreateWithoutApplicationsInput, LoanUncheckedCreateWithoutApplicationsInput>
  }

  export type LoanUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: LoanDocumentUpdateManyWithoutLoansNestedInput
  }

  export type LoanUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: LoanDocumentUncheckedUpdateManyWithoutLoansNestedInput
  }

  export type UploadedDocumentUpsertWithWhereUniqueWithoutApplicationInput = {
    where: UploadedDocumentWhereUniqueInput
    update: XOR<UploadedDocumentUpdateWithoutApplicationInput, UploadedDocumentUncheckedUpdateWithoutApplicationInput>
    create: XOR<UploadedDocumentCreateWithoutApplicationInput, UploadedDocumentUncheckedCreateWithoutApplicationInput>
  }

  export type UploadedDocumentUpdateWithWhereUniqueWithoutApplicationInput = {
    where: UploadedDocumentWhereUniqueInput
    data: XOR<UploadedDocumentUpdateWithoutApplicationInput, UploadedDocumentUncheckedUpdateWithoutApplicationInput>
  }

  export type UploadedDocumentUpdateManyWithWhereWithoutApplicationInput = {
    where: UploadedDocumentScalarWhereInput
    data: XOR<UploadedDocumentUpdateManyMutationInput, UploadedDocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type BankDetailsUpsertWithoutLoansInput = {
    update: XOR<BankDetailsUpdateWithoutLoansInput, BankDetailsUncheckedUpdateWithoutLoansInput>
    create: XOR<BankDetailsCreateWithoutLoansInput, BankDetailsUncheckedCreateWithoutLoansInput>
  }

  export type BankDetailsUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBankAccountsNestedInput
  }

  export type BankDetailsUncheckedUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutLoansInput = {
    update: XOR<UserUpdateWithoutLoansInput, UserUncheckedUpdateWithoutLoansInput>
    create: XOR<UserCreateWithoutLoansInput, UserUncheckedCreateWithoutLoansInput>
  }

  export type UserUpdateWithoutLoansInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoansInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgentUpsertWithoutLoansInput = {
    update: XOR<AgentUpdateWithoutLoansInput, AgentUncheckedUpdateWithoutLoansInput>
    create: XOR<AgentCreateWithoutLoansInput, AgentUncheckedCreateWithoutLoansInput>
  }

  export type AgentUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentIdNestedInput
  }

  export type AgentUncheckedUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type LoanApplicationCreateWithoutBankDetailsInput = {
    id?: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutApplicationsInput
    documents?: UploadedDocumentCreateNestedManyWithoutApplicationInput
    user: UserCreateNestedOneWithoutLoansInput
    agent?: AgentCreateNestedOneWithoutLoansInput
  }

  export type LoanApplicationUncheckedCreateWithoutBankDetailsInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type LoanApplicationCreateOrConnectWithoutBankDetailsInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutBankDetailsInput, LoanApplicationUncheckedCreateWithoutBankDetailsInput>
  }

  export type LoanApplicationCreateManyBankDetailsInputEnvelope = {
    data: Enumerable<LoanApplicationCreateManyBankDetailsInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBankAccountsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBankAccountsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBankAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBankAccountsInput, UserUncheckedCreateWithoutBankAccountsInput>
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutBankDetailsInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutBankDetailsInput, LoanApplicationUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<LoanApplicationCreateWithoutBankDetailsInput, LoanApplicationUncheckedCreateWithoutBankDetailsInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutBankDetailsInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutBankDetailsInput, LoanApplicationUncheckedUpdateWithoutBankDetailsInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutBankDetailsInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutLoansInput>
  }

  export type UserUpsertWithoutBankAccountsInput = {
    update: XOR<UserUpdateWithoutBankAccountsInput, UserUncheckedUpdateWithoutBankAccountsInput>
    create: XOR<UserCreateWithoutBankAccountsInput, UserUncheckedCreateWithoutBankAccountsInput>
  }

  export type UserUpdateWithoutBankAccountsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBankAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInsurancesInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInsurancesInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInsurancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsurancesInput, UserUncheckedCreateWithoutInsurancesInput>
  }

  export type UserUpsertWithoutInsurancesInput = {
    update: XOR<UserUpdateWithoutInsurancesInput, UserUncheckedUpdateWithoutInsurancesInput>
    create: XOR<UserCreateWithoutInsurancesInput, UserUncheckedCreateWithoutInsurancesInput>
  }

  export type UserUpdateWithoutInsurancesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInsurancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutClientAccountsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientAccountsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientAccountsInput, UserUncheckedCreateWithoutClientAccountsInput>
  }

  export type AgentCreateWithoutClientsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentIdInput
    loans?: LoanApplicationCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutClientsInput = {
    id?: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutClientsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutClientsInput, AgentUncheckedCreateWithoutClientsInput>
  }

  export type UserUpsertWithoutClientAccountsInput = {
    update: XOR<UserUpdateWithoutClientAccountsInput, UserUncheckedUpdateWithoutClientAccountsInput>
    create: XOR<UserCreateWithoutClientAccountsInput, UserUncheckedCreateWithoutClientAccountsInput>
  }

  export type UserUpdateWithoutClientAccountsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgentUpsertWithoutClientsInput = {
    update: XOR<AgentUpdateWithoutClientsInput, AgentUncheckedUpdateWithoutClientsInput>
    create: XOR<AgentCreateWithoutClientsInput, AgentUncheckedCreateWithoutClientsInput>
  }

  export type AgentUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentIdNestedInput
    loans?: LoanApplicationUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanApplicationUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ClientCreateWithoutAgentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientAccountsInput
  }

  export type ClientUncheckedCreateWithoutAgentInput = {
    id?: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutAgentInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAgentInput, ClientUncheckedCreateWithoutAgentInput>
  }

  export type ClientCreateManyAgentInputEnvelope = {
    data: Enumerable<ClientCreateManyAgentInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAgentIdInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentIdInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentIdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentIdInput, UserUncheckedCreateWithoutAgentIdInput>
  }

  export type LoanApplicationCreateWithoutAgentInput = {
    id?: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutApplicationsInput
    documents?: UploadedDocumentCreateNestedManyWithoutApplicationInput
    bankDetails: BankDetailsCreateNestedOneWithoutLoansInput
    user: UserCreateNestedOneWithoutLoansInput
  }

  export type LoanApplicationUncheckedCreateWithoutAgentInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type LoanApplicationCreateOrConnectWithoutAgentInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutAgentInput, LoanApplicationUncheckedCreateWithoutAgentInput>
  }

  export type LoanApplicationCreateManyAgentInputEnvelope = {
    data: Enumerable<LoanApplicationCreateManyAgentInput>
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithWhereUniqueWithoutAgentInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutAgentInput, ClientUncheckedUpdateWithoutAgentInput>
    create: XOR<ClientCreateWithoutAgentInput, ClientUncheckedCreateWithoutAgentInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutAgentInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutAgentInput, ClientUncheckedUpdateWithoutAgentInput>
  }

  export type ClientUpdateManyWithWhereWithoutAgentInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutClientsInput>
  }

  export type UserUpsertWithoutAgentIdInput = {
    update: XOR<UserUpdateWithoutAgentIdInput, UserUncheckedUpdateWithoutAgentIdInput>
    create: XOR<UserCreateWithoutAgentIdInput, UserUncheckedCreateWithoutAgentIdInput>
  }

  export type UserUpdateWithoutAgentIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutAgentInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutAgentInput, LoanApplicationUncheckedUpdateWithoutAgentInput>
    create: XOR<LoanApplicationCreateWithoutAgentInput, LoanApplicationUncheckedCreateWithoutAgentInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutAgentInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutAgentInput, LoanApplicationUncheckedUpdateWithoutAgentInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutAgentInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutLoansInput>
  }

  export type UserCreateWithoutRegisterStartupInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRegisterStartupInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRegisterStartupInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegisterStartupInput, UserUncheckedCreateWithoutRegisterStartupInput>
  }

  export type UserUpsertWithoutRegisterStartupInput = {
    update: XOR<UserUpdateWithoutRegisterStartupInput, UserUncheckedUpdateWithoutRegisterStartupInput>
    create: XOR<UserCreateWithoutRegisterStartupInput, UserUncheckedCreateWithoutRegisterStartupInput>
  }

  export type UserUpdateWithoutRegisterStartupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRegisterStartupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutContactUsInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactUsInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactUsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactUsInput, UserUncheckedCreateWithoutContactUsInput>
  }

  export type UserUpsertWithoutContactUsInput = {
    update: XOR<UserUpdateWithoutContactUsInput, UserUncheckedUpdateWithoutContactUsInput>
    create: XOR<UserCreateWithoutContactUsInput, UserUncheckedCreateWithoutContactUsInput>
  }

  export type UserUpdateWithoutContactUsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactUsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGstr1Input = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGstr1Input = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1_5A?: Gstr1_5AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGstr1Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGstr1Input, UserUncheckedCreateWithoutGstr1Input>
  }

  export type UserUpsertWithoutGstr1Input = {
    update: XOR<UserUpdateWithoutGstr1Input, UserUncheckedUpdateWithoutGstr1Input>
    create: XOR<UserCreateWithoutGstr1Input, UserUncheckedCreateWithoutGstr1Input>
  }

  export type UserUpdateWithoutGstr1Input = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGstr1Input = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1_5A?: Gstr1_5AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGstr1_5AInput = {
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    items?: ItemCreateNestedManyWithoutUserInput
    parties?: PartyCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsCreateNestedManyWithoutUserInput
    loans?: LoanApplicationCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentCreateNestedManyWithoutUserInput
    insurances?: InsuranceCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupCreateNestedManyWithoutUserInput
    contactUs?: ContactUsCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    legders?: LedgerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    agentId?: AgentCreateNestedOneWithoutUserInput
    clientAccounts?: ClientCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4ACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGstr1_5AInput = {
    id?: number
    createdAt?: Date | string
    email: string
    password: string
    firstName: string
    lastName?: string | null
    fatherName?: string | null
    phone?: string | null
    gender: UserGender
    address?: string | null
    pin?: string | null
    aadhaar?: string | null
    pan?: string | null
    dob?: Date | string | null
    avatar?: string | null
    adminId?: number | null
    superadminId?: number | null
    verified?: boolean
    userType?: UserType
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    businessProfile?: BusinessProfileUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    items?: ItemUncheckedCreateNestedManyWithoutUserInput
    parties?: PartyUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bankAccounts?: BankDetailsUncheckedCreateNestedManyWithoutUserInput
    loans?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    documents?: UploadedDocumentUncheckedCreateNestedManyWithoutUserInput
    insurances?: InsuranceUncheckedCreateNestedManyWithoutUserInput
    registerStartup?: RegisterStartupUncheckedCreateNestedManyWithoutUserInput
    contactUs?: ContactUsUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    legders?: LedgerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    agentId?: AgentUncheckedCreateNestedOneWithoutUserInput
    clientAccounts?: ClientUncheckedCreateNestedManyWithoutUserInput
    gstr1?: Gstr1_4AUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGstr1_5AInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGstr1_5AInput, UserUncheckedCreateWithoutGstr1_5AInput>
  }

  export type Gstr1_5A_itemCreateWithoutGstr1_5AInput = {
    SN?: string
    turnover: string
    cgst: string
    sgst: string
  }

  export type Gstr1_5A_itemUncheckedCreateWithoutGstr1_5AInput = {
    id?: number
    SN?: string
    turnover: string
    cgst: string
    sgst: string
  }

  export type Gstr1_5A_itemCreateOrConnectWithoutGstr1_5AInput = {
    where: Gstr1_5A_itemWhereUniqueInput
    create: XOR<Gstr1_5A_itemCreateWithoutGstr1_5AInput, Gstr1_5A_itemUncheckedCreateWithoutGstr1_5AInput>
  }

  export type Gstr1_5A_itemCreateManyGstr1_5AInputEnvelope = {
    data: Enumerable<Gstr1_5A_itemCreateManyGstr1_5AInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGstr1_5AInput = {
    update: XOR<UserUpdateWithoutGstr1_5AInput, UserUncheckedUpdateWithoutGstr1_5AInput>
    create: XOR<UserCreateWithoutGstr1_5AInput, UserUncheckedCreateWithoutGstr1_5AInput>
  }

  export type UserUpdateWithoutGstr1_5AInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    items?: ItemUpdateManyWithoutUserNestedInput
    parties?: PartyUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    legders?: LedgerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    agentId?: AgentUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGstr1_5AInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    superadminId?: NullableIntFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    businessProfile?: BusinessProfileUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    items?: ItemUncheckedUpdateManyWithoutUserNestedInput
    parties?: PartyUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bankAccounts?: BankDetailsUncheckedUpdateManyWithoutUserNestedInput
    loans?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: UploadedDocumentUncheckedUpdateManyWithoutUserNestedInput
    insurances?: InsuranceUncheckedUpdateManyWithoutUserNestedInput
    registerStartup?: RegisterStartupUncheckedUpdateManyWithoutUserNestedInput
    contactUs?: ContactUsUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    legders?: LedgerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    agentId?: AgentUncheckedUpdateOneWithoutUserNestedInput
    clientAccounts?: ClientUncheckedUpdateManyWithoutUserNestedInput
    gstr1?: Gstr1_4AUncheckedUpdateManyWithoutUserNestedInput
  }

  export type Gstr1_5A_itemUpsertWithWhereUniqueWithoutGstr1_5AInput = {
    where: Gstr1_5A_itemWhereUniqueInput
    update: XOR<Gstr1_5A_itemUpdateWithoutGstr1_5AInput, Gstr1_5A_itemUncheckedUpdateWithoutGstr1_5AInput>
    create: XOR<Gstr1_5A_itemCreateWithoutGstr1_5AInput, Gstr1_5A_itemUncheckedCreateWithoutGstr1_5AInput>
  }

  export type Gstr1_5A_itemUpdateWithWhereUniqueWithoutGstr1_5AInput = {
    where: Gstr1_5A_itemWhereUniqueInput
    data: XOR<Gstr1_5A_itemUpdateWithoutGstr1_5AInput, Gstr1_5A_itemUncheckedUpdateWithoutGstr1_5AInput>
  }

  export type Gstr1_5A_itemUpdateManyWithWhereWithoutGstr1_5AInput = {
    where: Gstr1_5A_itemScalarWhereInput
    data: XOR<Gstr1_5A_itemUpdateManyMutationInput, Gstr1_5A_itemUncheckedUpdateManyWithoutGstr1_5A_itemsInput>
  }

  export type Gstr1_5A_itemScalarWhereInput = {
    AND?: Enumerable<Gstr1_5A_itemScalarWhereInput>
    OR?: Enumerable<Gstr1_5A_itemScalarWhereInput>
    NOT?: Enumerable<Gstr1_5A_itemScalarWhereInput>
    id?: IntFilter | number
    SN?: StringFilter | string
    turnover?: StringFilter | string
    cgst?: StringFilter | string
    sgst?: StringFilter | string
    gstr1_5A_id?: IntFilter | number
  }

  export type Gstr1_5ACreateWithoutGstr1_5A_itemsInput = {
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
    user: UserCreateNestedOneWithoutGstr1_5AInput
  }

  export type Gstr1_5AUncheckedCreateWithoutGstr1_5A_itemsInput = {
    id?: number
    userId: number
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
  }

  export type Gstr1_5ACreateOrConnectWithoutGstr1_5A_itemsInput = {
    where: Gstr1_5AWhereUniqueInput
    create: XOR<Gstr1_5ACreateWithoutGstr1_5A_itemsInput, Gstr1_5AUncheckedCreateWithoutGstr1_5A_itemsInput>
  }

  export type Gstr1_5AUpsertWithoutGstr1_5A_itemsInput = {
    update: XOR<Gstr1_5AUpdateWithoutGstr1_5A_itemsInput, Gstr1_5AUncheckedUpdateWithoutGstr1_5A_itemsInput>
    create: XOR<Gstr1_5ACreateWithoutGstr1_5A_itemsInput, Gstr1_5AUncheckedCreateWithoutGstr1_5A_itemsInput>
  }

  export type Gstr1_5AUpdateWithoutGstr1_5A_itemsInput = {
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutGstr1_5ANestedInput
  }

  export type Gstr1_5AUncheckedUpdateWithoutGstr1_5A_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
  }

  export type OtpCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    otp: string
    used?: boolean
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    partyId: string
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
  }

  export type CategoryCreateManyUserInput = {
    id?: string
    categoryName: string
  }

  export type ItemCreateManyUserInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    categoryId?: string | null
    supplierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartyCreateManyUserInput = {
    id?: string
    partyName: string
    type: PartyType
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    upi?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    bankName?: string | null
    bankAccountNumber?: string | null
    bankIfsc?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    razorpay_order_id: string
    razorpay_payment_id: string
    status?: PaymentStatus
    orderId: number
  }

  export type OrderCreateManyUserInput = {
    id?: number
    services: JsonNullValueInput | InputJsonValue
    status?: OrderStatus
    price: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    orderTotal: Decimal | DecimalJsLike | number | string
    stateOfSupply: string
  }

  export type PostCreateManyUserInput = {
    id?: string
    title: string
    contentheading: string
    contentdiscription: string
    category: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountName: string
    totalDebit?: Decimal | DecimalJsLike | number | string
    totalCredit?: Decimal | DecimalJsLike | number | string
    debitBalance?: Decimal | DecimalJsLike | number | string
    creditBalance?: Decimal | DecimalJsLike | number | string
    date?: Date | string
  }

  export type BankDetailsCreateManyUserInput = {
    id?: string
    accountHolderName: string
    bankName: string
    bankAccountNo: string
    bankIfsc: string
    bankBranch: string
    bankAccountType: BankAccountType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationCreateManyUserInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedDocumentCreateManyUserInput = {
    id?: string
    fileName: string
    applicationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceCreateManyUserInput = {
    id?: string
    type: string
    name: string
    mobile: string
    email: string
    address: string
    dob: Date | string
    maritalStatus: string
    gender: UserGender
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegisterStartupCreateManyUserInput = {
    id?: number
    title: string
    image: string
    categories: StartupCategory
  }

  export type ContactUsCreateManyUserInput = {
    id?: number
    name: string
    email: string
    message: string
    phoneNumber: string
  }

  export type JournalEntryCreateManyUserInput = {
    id?: string
    entryDate?: Date | string
    description: string
  }

  export type LedgerCreateManyUserInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    partyId?: string | null
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    ledgerId: string
    journalEntryId: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
  }

  export type ClientCreateManyUserInput = {
    id?: string
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Gstr1_4ACreateManyUserInput = {
    id?: number
    LegalName: string
    GSTN: string
    pos: string
    invoice_No: string
    invoice_date: string
    invoice_value: string
    rate: string
    nature: string
    source: string
    cgst: string
    igst: string
    sgst: string
    supply_type: string
    fy: string
    period: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Gstr1_5ACreateManyUserInput = {
    id?: number
    pos: string
    invoice_No: string
    supply_type: string
    invoice_date: string
    invoice_value: string
    total_invoice_value: string
  }

  export type OtpUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OtpUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OtpUncheckedUpdateManyWithoutOtpsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    party?: PartyUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    accounts?: AccountUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    partyId?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    partyId?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
  }

  export type CategoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type ItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutItemsNestedInput
    supplier?: PartyUpdateOneWithoutItemsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPartyNestedInput
    items?: ItemUpdateManyWithoutSupplierNestedInput
    ledgers?: LedgerUpdateManyWithoutPartyNestedInput
  }

  export type PartyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPartyNestedInput
    items?: ItemUncheckedUpdateManyWithoutSupplierNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutPartyNestedInput
  }

  export type PartyUncheckedUpdateManyWithoutPartiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    partyName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartyTypeFieldUpdateOperationsInput | PartyType
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankIfsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpay_order_id?: StringFieldUpdateOperationsInput | string
    razorpay_payment_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpay_order_id?: StringFieldUpdateOperationsInput | string
    razorpay_payment_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpay_order_id?: StringFieldUpdateOperationsInput | string
    razorpay_payment_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderUpdateWithoutUserInput = {
    services?: JsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    services?: JsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    services?: JsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stateOfSupply?: StringFieldUpdateOperationsInput | string
  }

  export type PostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    contentheading?: StringFieldUpdateOperationsInput | string
    contentdiscription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    contentheading?: StringFieldUpdateOperationsInput | string
    contentdiscription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    contentheading?: StringFieldUpdateOperationsInput | string
    contentdiscription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanApplicationUpdateManyWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanApplicationUncheckedUpdateManyWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateManyWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    bankIfsc?: StringFieldUpdateOperationsInput | string
    bankBranch?: StringFieldUpdateOperationsInput | string
    bankAccountType?: EnumBankAccountTypeFieldUpdateOperationsInput | BankAccountType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutApplicationsNestedInput
    documents?: UploadedDocumentUpdateManyWithoutApplicationNestedInput
    bankDetails?: BankDetailsUpdateOneRequiredWithoutLoansNestedInput
    agent?: AgentUpdateOneWithoutLoansNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    bankAccountId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type LoanApplicationUncheckedUpdateManyWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    bankAccountId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedDocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    docs?: LoanDocumentUpdateManyWithoutDocumentsNestedInput
    application?: LoanApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type UploadedDocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    docs?: LoanDocumentUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type UploadedDocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceUncheckedUpdateManyWithoutInsurancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisterStartupUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    categories?: EnumStartupCategoryFieldUpdateOperationsInput | StartupCategory
  }

  export type RegisterStartupUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    categories?: EnumStartupCategoryFieldUpdateOperationsInput | StartupCategory
  }

  export type RegisterStartupUncheckedUpdateManyWithoutRegisterStartupInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    categories?: EnumStartupCategoryFieldUpdateOperationsInput | StartupCategory
  }

  export type ContactUsUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUsUncheckedUpdateManyWithoutContactUsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type JournalEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    transactions?: TransactionUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    transactions?: TransactionUncheckedUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateManyWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type LedgerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutLedgerNestedInput
    party?: PartyUpdateOneWithoutLedgersNestedInput
  }

  export type LedgerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partyId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutLedgerNestedInput
  }

  export type LedgerUncheckedUpdateManyWithoutLegdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partyId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    ledger?: LedgerUpdateOneRequiredWithoutTransactionsNestedInput
    journalEntry?: JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerId?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerId?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
  }

  export type ClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyWithoutClientAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Gstr1_4AUpdateWithoutUserInput = {
    LegalName?: StringFieldUpdateOperationsInput | string
    GSTN?: StringFieldUpdateOperationsInput | string
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    igst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    fy?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Gstr1_4AUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    LegalName?: StringFieldUpdateOperationsInput | string
    GSTN?: StringFieldUpdateOperationsInput | string
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    igst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    fy?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Gstr1_4AUncheckedUpdateManyWithoutGstr1Input = {
    id?: IntFieldUpdateOperationsInput | number
    LegalName?: StringFieldUpdateOperationsInput | string
    GSTN?: StringFieldUpdateOperationsInput | string
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    igst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    fy?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Gstr1_5AUpdateWithoutUserInput = {
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
    gstr1_5A_items?: Gstr1_5A_itemUpdateManyWithoutGstr1_5ANestedInput
  }

  export type Gstr1_5AUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
    gstr1_5A_items?: Gstr1_5A_itemUncheckedUpdateManyWithoutGstr1_5ANestedInput
  }

  export type Gstr1_5AUncheckedUpdateManyWithoutGstr1_5AInput = {
    id?: IntFieldUpdateOperationsInput | number
    pos?: StringFieldUpdateOperationsInput | string
    invoice_No?: StringFieldUpdateOperationsInput | string
    supply_type?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    invoice_value?: StringFieldUpdateOperationsInput | string
    total_invoice_value?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateManyLedgerInput = {
    id?: string
    journalEntryId: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    userId: number
  }

  export type TransactionUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    journalEntry?: JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyJournalEntryInput = {
    id?: string
    ledgerId: string
    amount: Decimal | DecimalJsLike | number | string
    transactionType: TransactionType
    userId: number
  }

  export type TransactionUpdateWithoutJournalEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    ledger?: LedgerUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutJournalEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateManyPartyInput = {
    id?: string
    invoiceNumber?: string | null
    type: InvoiceType
    totalAmount: number
    totalGst?: number | null
    stateOfSupply: string
    cgst?: number | null
    sgst?: number | null
    igst?: number | null
    utgst?: number | null
    details?: string | null
    extraDetails?: string | null
    modeOfPayment: ModeOfPayment
    credit: boolean
    userId: number
    gstNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: InvoiceStatus
  }

  export type ItemCreateManySupplierInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    categoryId?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerCreateManyPartyInput = {
    id?: string
    ledgerName: string
    openingBalance?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    userId: number
    year?: number
    month?: number
    ledgerType: LedgerType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutPartyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    accounts?: AccountUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPartyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type ItemUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutItemsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutItemNestedInput
    user?: UserUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type LedgerUpdateWithoutPartyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLegdersNestedInput
    transactions?: TransactionUpdateManyWithoutLedgerNestedInput
  }

  export type LedgerUncheckedUpdateWithoutPartyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutLedgerNestedInput
  }

  export type LedgerUncheckedUpdateManyWithoutLedgersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ledgerName?: StringFieldUpdateOperationsInput | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    ledgerType?: EnumLedgerTypeFieldUpdateOperationsInput | LedgerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyCategoryInput = {
    id?: string
    itemName: string
    unit?: ItemUnit
    price: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string | null
    closingStock?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    gst?: Decimal | DecimalJsLike | number | string | null
    taxExempted?: boolean
    description?: string | null
    hsnCode?: string | null
    supplierId?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: PartyUpdateOneWithoutItemsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutItemNestedInput
    user?: UserUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    unit?: EnumItemUnitFieldUpdateOperationsInput | ItemUnit
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    closingStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxExempted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hsnCode?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InvoiceItemCreateManyItemInput = {
    id?: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
    invoiceId: string
  }

  export type InvoiceItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    itemId: string
    quantity: number
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AccountUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    party?: PartyUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | InvoiceType
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalGst?: NullableFloatFieldUpdateOperationsInput | number | null
    stateOfSupply?: StringFieldUpdateOperationsInput | string
    cgst?: NullableFloatFieldUpdateOperationsInput | number | null
    sgst?: NullableFloatFieldUpdateOperationsInput | number | null
    igst?: NullableFloatFieldUpdateOperationsInput | number | null
    utgst?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    extraDetails?: NullableStringFieldUpdateOperationsInput | string | null
    modeOfPayment?: EnumModeOfPaymentFieldUpdateOperationsInput | ModeOfPayment
    credit?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    partyId?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type LoanDocumentUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanUpdateManyWithoutDocumentsNestedInput
  }

  export type LoanDocumentUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type LoanDocumentUncheckedUpdateManyWithoutDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedDocumentUpdateWithoutDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    application?: LoanApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type UploadedDocumentUncheckedUpdateWithoutDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: LoanApplicationUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: LoanApplicationUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateManyWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interest?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationCreateManyLoanInput = {
    id?: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanDocumentUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUpdateManyWithoutDocsNestedInput
  }

  export type LoanDocumentUncheckedUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUncheckedUpdateManyWithoutDocsNestedInput
  }

  export type LoanDocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUpdateManyWithoutApplicationNestedInput
    bankDetails?: BankDetailsUpdateOneRequiredWithoutLoansNestedInput
    user?: UserUpdateOneRequiredWithoutLoansNestedInput
    agent?: AgentUpdateOneWithoutLoansNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    bankAccountId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type LoanApplicationUncheckedUpdateManyWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    bankAccountId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedDocumentCreateManyApplicationInput = {
    id?: string
    userId: number
    fileName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedDocumentUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    docs?: LoanDocumentUpdateManyWithoutDocumentsNestedInput
  }

  export type UploadedDocumentUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    docs?: LoanDocumentUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type LoanApplicationCreateManyBankDetailsInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationUpdateWithoutBankDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutApplicationsNestedInput
    documents?: UploadedDocumentUpdateManyWithoutApplicationNestedInput
    user?: UserUpdateOneRequiredWithoutLoansNestedInput
    agent?: AgentUpdateOneWithoutLoansNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutBankDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ClientCreateManyAgentInput = {
    id?: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationCreateManyAgentInput = {
    id?: string
    loanId: string
    loanAmount: Decimal | DecimalJsLike | number | string
    loanStatus?: LoanStatus
    applicantName: string
    applicantAge: number
    loanType: LoanType
    applicantGender: UserGender
    nationality: Nationality
    description: string
    salaried: boolean
    bankAccountId: string
    phone?: string | null
    email?: string | null
    address?: string | null
    permanentAddress: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientAccountsNestedInput
  }

  export type ClientUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutApplicationsNestedInput
    documents?: UploadedDocumentUpdateManyWithoutApplicationNestedInput
    bankDetails?: BankDetailsUpdateOneRequiredWithoutLoansNestedInput
    user?: UserUpdateOneRequiredWithoutLoansNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    loanAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanStatus?: EnumLoanStatusFieldUpdateOperationsInput | LoanStatus
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantAge?: IntFieldUpdateOperationsInput | number
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | LoanType
    applicantGender?: EnumUserGenderFieldUpdateOperationsInput | UserGender
    nationality?: EnumNationalityFieldUpdateOperationsInput | Nationality
    description?: StringFieldUpdateOperationsInput | string
    salaried?: BoolFieldUpdateOperationsInput | boolean
    bankAccountId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UploadedDocumentUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type Gstr1_5A_itemCreateManyGstr1_5AInput = {
    id?: number
    SN?: string
    turnover: string
    cgst: string
    sgst: string
  }

  export type Gstr1_5A_itemUpdateWithoutGstr1_5AInput = {
    SN?: StringFieldUpdateOperationsInput | string
    turnover?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
  }

  export type Gstr1_5A_itemUncheckedUpdateWithoutGstr1_5AInput = {
    id?: IntFieldUpdateOperationsInput | number
    SN?: StringFieldUpdateOperationsInput | string
    turnover?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
  }

  export type Gstr1_5A_itemUncheckedUpdateManyWithoutGstr1_5A_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    SN?: StringFieldUpdateOperationsInput | string
    turnover?: StringFieldUpdateOperationsInput | string
    cgst?: StringFieldUpdateOperationsInput | string
    sgst?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}